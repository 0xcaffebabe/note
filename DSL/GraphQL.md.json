{"name":"GraphQL","id":"DSL-GraphQL","content":"> GraphQL 是由 Facebook 创造的用于描述复杂数据模型的一种查询语言。这里查询语言所指的并不是常规意义上的类似 sql 语句的查询语言，而是一种用于前后端数据查询方式的规范\n\n# Restful的不足\n\n- 扩展性，单个RESTful接口返回数据越来越臃肿\n- 某个前端展现，实际需要调用多个独立的RESTful API才能获取到足够的数据\n\n# GraphQL的优势\n\n- 按需索取数据\n- 一次查询多个数据\n- API演进无需划分版本\n\n# 查询规范\n\n## 字段\n\n在GraphQL的查询中，请求结构中包含了所预期结果的结构，这个就是字段。并且响应的结构和请求结构基本一致\n\n```gql\n{\n  hero {\n    name\n  }\n}\n```\n\n```json\n{\n  \"data\": {\n    \"hero\": {\n      \"name\": \"R2-D2\"\n    }\n  }\n}\n```\n\n## 参数\n\n语法：(参数名:参数值)\n\n```gql\n{\n  human(id: \"1000\") {\n    name\n    height\n  }\n}\n```\n\n```json\n{\n  \"data\": {\n    \"human\": {\n      \"name\": \"Luke Skywalker\",\n      \"height\": 1.72\n    }\n  }\n}\n```\n\n## 别名\n\n如果一次查询多个相同对象，但是值不同，这个时候就需要起别名了，否则json的语法就不能通过了\n\n```gql\n{\n  empireHero: hero(episode: EMPIRE) {\n    name\n  }\n  jediHero: hero(episode: JEDI) {\n    name\n  }\n}\n```\n\n```json\n{\n  \"data\": {\n    \"empireHero\": {\n      \"name\": \"Luke Skywalker\"\n    },\n    \"jediHero\": {\n      \"name\": \"R2-D2\"\n    }\n  }\n}\n```\n\n## 片段\n\n查询对的属相如果相同，可以采用片段的方式进行简化定义\n\n```gql\n{\n  leftComparison: hero(episode: EMPIRE) {\n    ...comparisonFields\n  }\n  rightComparison: hero(episode: JEDI) {\n    ...comparisonFields\n  }\n}\n\nfragment comparisonFields on Character {\n  name\n  appearsIn\n  friends {\n    name\n  }\n}\n```\n\n```json\n{\n  \"data\": {\n    \"leftComparison\": {\n      \"name\": \"Luke Skywalker\",\n      \"appearsIn\": [\n        \"NEWHOPE\",\n        \"EMPIRE\",\n        \"JEDI\"\n      ],\n      \"friends\": [\n        {\n          \"name\": \"Han Solo\"\n        },\n        {\n          \"name\": \"Leia Organa\"\n        },\n        {\n          \"name\": \"C-3PO\"\n        },\n        {\n          \"name\": \"R2-D2\"\n        }\n      ]\n    },\n    \"rightComparison\": {\n      \"name\": \"R2-D2\",\n      \"appearsIn\": [\n        \"NEWHOPE\",\n        \"EMPIRE\",\n        \"JEDI\"\n      ],\n      \"friends\": [\n        {\n          \"name\": \"Luke Skywalker\"\n        },\n        {\n          \"name\": \"Han Solo\"\n        },\n        {\n          \"name\": \"Leia Organa\"\n        }\n      ]\n    }\n  }\n}\n```\n\n## Schema\n\nSchema 是用于定义数据结构的，比如说，User对象中有哪些属性，对象与对象之间是什么关系等\n\n```gql\nschema { #定义查询 \n    query: UserQuery \n}\ntype UserQuery { #定义查询的类型 \n    user(id:ID) : User #指定对象以及参数类型 \n}\ntype User {#定义对象 \n    id:ID! # !表示该属性是非空项 \n    name:String age:Int \n}\n```\n\n# 类型规范\n\n## 标量类型\n\n- Int ：有符号 32 位整数。\n- Float ：有符号双精度浮点值。\n- String ：UTF‐8 字符序列。\n- Boolean ： true 或者 false 。 ID ：\n- ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。\n\n## 枚举类型\n\n枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内\n\n```gql\nenum Episode { # 定义枚举\n  NEWHOPE\n  EMPIRE\n  JEDI\n}\ntype Character { # 使用枚举\n  name: String!\n  appearsIn: [Episode]!\n}\n```\n\n## 接口\n\n跟许多类型系统一样，GraphQL 支持接口。一个接口是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口\n\n```gql\ninterface Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n}\ntype Human implements Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n  starships: [Starship]\n  totalCredits: Int\n}\n```\n\n\n","metadata":"","hasMoreCommit":false,"totalCommits":1,"commitList":[{"date":"2019-12-09T22:20:54+08:00","author":"MY","message":"新增graphql","hash":"76baeab4ca47af3afefc2bb0de4b5691d8d8edfa"}],"createTime":"2019-12-09T22:20:54+08:00"}