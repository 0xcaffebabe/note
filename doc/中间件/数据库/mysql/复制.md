# 复制

解决的问题：

- 分布式数据
- 负载均衡压力
- 对于备份的补充
- 故障切换

## 主从复制

![复制原理](/assets/2020310201955.png)

- binlog线程：将master服务器上的数据写入binlog
- io线程：读取master的binlog到replica的relay log（中继日志）
- sql线程：读取中继日志，将数据写入到replica

这种架构实现了获取与重放的解耦 但代价是主库上并行的操作，在从库上会串行执行，所以从库会有一定的数据延迟

### 复制方式

#### 基于语句

这种方式只要把造成数据变化的SQL发送到从库执行即可，实现简单，但有一些限制，如依赖于触发器、当前时间等的语句执行

#### 基于行

重放的是修改后的数据，某些情况下比居于语句高效，同时几乎可以处理所有的复制场景

### 半同步复制与并行复制

- 半同步复制是主库接收到一个写命令会将这个写命令同步给从库，只有当收到至少一个从库的ack确认，才会认为写操作完成
- 并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志

由于这个特性，所以做主从分离写代码可能需要注意插入的数据，可能不一定能马上查到

### 复制配置

- master配置

```conf
server_id=177  ###服务器id
log-bin=mysql-bin   ###开启日志文件
```

```sh
show master status; # 查看master日志与当前日志位置
```

- slave配置

```conf
server_id=178  ###从服务器server_id
log-bin=mysql-bin  ###日志文件同步方式
binlog_do_db=test   ###同步数据库
```

```sh
show slave status;
```

- 从服务器执行

```sh
change master to master_host='192.168.182.131',master_user='root',master_password='123',   master_log_file='mysql-bin.000002',master_log_pos=0;
```

```sh
start slave
```

## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作

读写分离提高性能的原因：

- 缓解了锁的争用
- 从服务器只做读，资源利用率更高
- 增加冗余数据，提高可用性