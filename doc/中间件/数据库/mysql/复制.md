# 复制

解决的问题：

- 分布式数据
- 负载均衡压力
- 对于备份的补充
- 故障切换

## 主从复制

![复制原理](/assets/2020310201955.png)

- binlog线程：将master服务器上的数据写入binlog
- io线程：读取master的binlog到replica的relay log（中继日志）
- sql线程：读取中继日志，将数据写入到replica

这种架构实现了获取与重放的解耦 但代价是主库上并行的操作，在从库上会串行执行，所以从库会有一定的数据延迟

### 复制方式

#### 基于语句

这种方式只要把造成数据变化的SQL发送到从库执行即可，实现简单，但有一些限制，如依赖于触发器、当前时间等的语句执行

#### 基于行

重放的是修改后的数据，某些情况下比居于语句高效，同时几乎可以处理所有的复制场景

### 半同步复制与并行复制

- 半同步复制是主库接收到一个写命令会将这个写命令同步给从库，只有当收到至少一个从库的ack确认，才会认为写操作完成
- 并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志

由于这个特性，所以做主从分离写代码可能需要注意插入的数据，可能不一定能马上查到

### 复制配置

- master配置

```conf
server_id=177  ###服务器id
log-bin=mysql-bin   ###开启日志文件
```

```sh
show master status; # 查看master日志与当前日志位置
```

- slave配置

```conf
server_id=178  ###从服务器server_id
log-bin=mysql-bin  ###日志文件同步方式
binlog_do_db=test   ###同步数据库
```

为了防止自己复制自己 这个server_id 会起标识作用 MySQL会忽略来源于id与本身id相同的事件

```sh
show slave status;
```

- 从服务器执行

```sh
change master to master_host='192.168.182.131',master_user='root',master_password='123',   master_log_file='mysql-bin.000002',master_log_pos=0;
```

```sh
start slave
```

### 复制文件

- mysql-bin.index MySQL依赖这个文件识别二进制日志
- mysql-relay-bin-index 中继日志的索引文件
- master.info 备库所保存的主库信息
- relay-log.info 日志坐标

### 复制过滤

![复制过滤器](/assets/屏幕截图%202021-12-24%20170256.png)

### 复制拓扑

基本原则：

- 每个备库只能有一个主库
- 每个备库都需要有唯一的server_id
- 备库可以作为主库

#### 一主多备

![一主多备](/assets/屏幕截图%202021-12-24%20171024.png)

- 简单

#### 主主复制

##### 主动-主动

![主动-主动复制](/assets/屏幕截图%202021-12-24%20171334.png)

- 若是对同一份数据 两边写入肯定会出现冲突
- 更多地 这种方式要求两个主库负责不同部分的数据写入
- 总体而言 坏处大于好处

##### 主动-被动

使用被动主库来完成热备、故障转移的功能

![主动-被动复制](/assets/屏幕截图%202021-12-24%20171732.png)

##### 加上备库

![拥有备库的主主复制](/assets/屏幕截图%202021-12-24%20172210.png)

#### 环形复制

- 失效风险大大提高

#### 分发库

- 在备库较多时降低主库压力

![单个分发库](/assets/屏幕截图%202021-12-24%20172632.png)
![多个分发库](/assets/屏幕截图%202021-12-24%20172649.png)

### 容量规划

备库的增加并不能线性增加读操作，同时增加了备库，也会加重主库的写负载

#### 延迟计算

停掉备库一小时的数据同步，看其能在多久的时间追赶上

#### 冗余容量规划

预备一些多余的处理能力 以备负载尖峰

### 复制治理

#### 监控

```sql
SHOW MASTER LOGS; -- 查看二进制记录及其位置
SHOW BINLOG EVENTS IN 'mysql-bin.000134' FROM 950567650; -- 查看指定日志指定偏移量后的内容
```

#### 延迟监控

```sql
SHOW SLAVE STATUS; -- Seconds_behind_master
```

另外一种方式是通过在主库每秒更新一个时间戳 在备库上使用当前时间减去这个时间戳来得到延迟了多久

#### 主从一致性检测

- pt-table-checksum

#### 重新同步

- pt-table-sync

#### 备库提升为主库

- 停止对主库写入
- 等备库追上主库
- 将备库设置为其他库的主库
- 开启写入

## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作

读写分离提高性能的原因：

- 缓解了锁的争用
- 从服务器只做读，资源利用率更高
- 增加冗余数据，提高可用性