---
tags: ['数据库', '数据类型', '存储模型', '类型系统', '计算语义']
---

# 数据库数据类型

## 一、为什么"数据类型"是数据库设计的第一性问题

在数据库系统中，**数据类型并不是语法细节，而是系统能力的边界定义**。

一个字段选择了什么类型，实际上同时决定了：

* **数据如何被存储**（定长 / 变长 / 外部存储）
* **数据如何被比较与排序**（字节比较 / 语义比较 / 排序规则）
* **数据如何参与计算**（精度、溢出、隐式转换）
* **数据是否、以及如何被索引**

> **结论**：
> 数据类型 ≠ “值的格式”
> 数据类型 = **存储模型 + 计算语义 + 比较规则 + 索引能力**

这也是为什么**数据类型选择错误，往往会在性能、正确性和系统演进中反复付出代价**。

---

## 二、数据类型的统一抽象模型（核心）

所有关系型数据库的数据类型，都可以映射到以下四个稳定维度：

### 1️⃣ 存储模型（Storage Model）

* 定长存储（Fixed-length）
* 变长存储（Variable-length）
* 外部存储 / 指针引用（Off-page storage）

> 存储模型决定了 **空间效率、IO 行为、UPDATE 成本**

---

### 2️⃣ 比较与排序语义（Comparison Semantics）

* 字节级比较
* 基于排序规则（collation）的语义比较
* 是否受时区、编码、区域规则影响

> 比较语义决定了 **ORDER BY、GROUP BY、JOIN 的行为正确性**

---

### 3️⃣ 计算语义（Computation Semantics）

* 是否精确
* 是否存在舍入误差
* 溢出与隐式类型转换规则

> 计算语义决定了 **数据是否“可信”**

---

### 4️⃣ 索引与查询能力（Indexability）

* 是否可建立索引
* 是否支持前缀索引
* 是否影响索引大小与选择性

> 索引能力决定了 **查询性能的上限**

---

## 三、数值类型：精度、范围与可信计算

### 3.1 数值类型的本质分类

从**计算语义**角度，数值类型只有两大类：

| 类型    | 本质          |
| ----- | ----------- |
| 精确数值  | 用于“不能错”的计算  |
| 非精确数值 | 用于“可以近似”的计算 |

---

### 3.2 精确数值类型（Exact）

**代表**：整数类、定点小数类

**特征**：

* 运算结果确定
* 不存在二进制舍入误差
* 适合金额、计数、版本号、序列

**工程哲学**：

> **凡是业务上“不能算错”的数据，必须使用精确类型**

---

### 3.3 非精确数值类型（Approximate）

**代表**：浮点数

**特征**：

* 计算速度快
* 存在精度误差
* 比较结果不稳定

**工程哲学**：

> 浮点数适合科学计算，不适合业务账目

---

### 3.4 数值范围与 UNSIGNED 的意义

* 存储位数决定值域
* UNSIGNED 并不是“优化”，而是**语义声明**

> 使用 UNSIGNED，等价于向系统声明：
> **该字段不应出现负值**

---

## 四、字符与二进制类型：存储、语义与索引

### 4.1 字符串类型的核心分歧

字符类型的核心差异不在“是否字符串”，而在：

* 是否定长
* 是否具备语义比较规则

---

### 4.2 定长 vs 变长

| 维度     | 定长   | 变长       |
| ------ | ---- | -------- |
| 存储     | 固定   | 按需       |
| UPDATE | 低成本  | 可能产生额外开销 |
| 空间效率   | 低    | 高        |
| 适用场景   | 长度稳定 | 长度不确定    |

> **本质权衡**：
> 空间效率 ↔ 更新成本 ↔ 访问局部性

---

### 4.3 二进制与非二进制字符串

* 二进制类型：逐字节比较
* 非二进制类型：基于排序规则比较

**影响**：

* 排序
* 索引
* JOIN 行为

---

### 4.4 大字段（LOB）的工程含义

大字段类型的本质是：

> **“牺牲索引能力，换取容量”**

工程原则：

* 它们不是“普通字段”
* 而是“附属数据”

---

## 五、时间与日期类型：时间语义而非格式

### 5.1 时间类型的核心问题

时间类型并不难，**难的是时间语义**：

* 是否与时区绑定
* 是否表示“事件发生时刻”
* 是否表示“业务时间”

---

### 5.2 两种时间哲学

| 哲学   | 含义      |
| ---- | ------- |
| 绝对时间 | 与时区相关   |
| 业务时间 | 与业务语义相关 |

> 时间类型选择，本质是**对时间意义的建模选择**

---

## 六、枚举与位类型：编码效率 vs 演进能力

### 6.1 枚举的本质

枚举并不是字符串优化，而是：

> **“用整数编码有限状态集合”**

**优点**：

* 存储紧凑
* 比较高效

**代价**：

* 架构刚性
* 演进成本高

---

### 6.2 位与集合类型

* 适合表示布尔组合
* 不适合表达复杂语义

> 当位含义超过 3～5 个，系统复杂度会急剧上升

---

## 七、序列与自增：并发系统中的顺序问题

### 7.1 序列生成的本质难题

生成序列并不难，难的是在以下约束下生成：

* 高并发
* 崩溃恢复
* 不阻塞业务

> **连续性、唯一性、性能，三者不可兼得**

---

### 7.2 AUTO_INCREMENT 的工程定位

AUTO_INCREMENT 是一种：

> **在单机数据库内，平衡并发性能与顺序性的工程妥协方案**

工程认知：

* 连续 ≠ 正确
* 间隙 ≠ Bug

---

### 7.3 不连续 ID 的本质原因

* 并发预分配
* 回滚不回收
* 批量插入优化

**关键结论**：

> ID 的语义是“唯一标识”，不是“业务顺序”

---

## 八、数据类型选型的方法论（决策层）

### 8.1 类型选择的四问法

1. 是否要求**计算绝对正确**
2. 是否参与**排序 / JOIN / 索引**
3. 是否需要**长期演进**
4. 是否是**业务核心字段**

---

### 8.2 决策示例

* 金额 → 精确数值
* 状态 → 枚举 or 独立字典表
* 时间点 → 先明确“时间语义”
* 主键 → 唯一性优先于连续性

## 总结：数据类型是数据库的“语言系统”

> **如果把数据库看成一种语言，那么数据类型就是它的语法与语义系统。**

* 它决定了系统能"说什么"
* 也决定了系统"不能说什么"

真正成熟的数据库设计，不是记住类型列表，而是**理解每一种类型背后的取舍与哲学**。

## 关联内容（自动生成）

- [/中间件/数据库/索引.md](/中间件/数据库/索引.md) 数据类型与索引性能密切相关，不同的数据类型对索引的大小、选择性和查询效率有直接影响
- [/中间件/数据库/数据库系统/数据库设计.md](/中间件/数据库/数据库系统/数据库设计.md) 数据类型选择是数据库设计的重要组成部分，直接影响数据库的性能和可维护性
- [/中间件/数据库/mysql/schema与数据类型优化.md](/中间件/数据库/mysql/schema与数据类型优化.md) MySQL中数据类型的具体优化策略，与本文探讨的数据类型选择原则相互补充
- [/DSL/SQL.md](/DSL/SQL.md) SQL语言中的数据类型定义，是数据库数据类型的具体实现和应用
- [/数据技术/数据建模.md](/数据技术/数据建模.md) 数据建模过程中需要考虑数据类型的选择，以确保物理模型与逻辑模型的一致性
- [/中间件/数据库/数据库系统/事务管理/事务.md](/中间件/数据库/数据库系统/事务管理/事务.md) 数据类型的选择会影响事务处理的性能和一致性，特别是在并发控制和锁机制方面
- [/编程语言/JAVA/语言基础.md](/编程语言/JAVA/语言基础.md) 编程语言中的数据类型与数据库数据类型存在映射关系，了解两者差异有助于ORM设计
- [/中间件/数据库/ElasticSearch.md](/中间件/数据库/ElasticSearch.md) ES中的数据类型与关系型数据库的数据类型在设计和应用上存在差异，但基本原理相通
- [/数据技术/检索技术.md](/数据技术/检索技术.md) 检索系统中的数据类型处理，特别是索引构建和查询优化与数据库数据类型密切相关
