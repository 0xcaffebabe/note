# 检索技术

合理地组织数据的存储可以提高检索效率。检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围

## 线性结构检索

[链表与数组](/算法与数据结构/基本数据结构.md#线性结构)就是线性结构检索的代表

## 线性结构检索

树与跳表是这种结构的代表

## [哈希检索](/算法与数据结构/查找.md#散列表)

## 状态检索

- 位图
- 布隆过滤器

## [倒排索引](/中间件/全文检索/全文检索.md#倒排索引：根据词找文章)

跳表法加速倒排索引：使用跳表存储文档列表，主要对搜索结果集合运算时进行加速

![跳表加速](/assets/2022112220336.webp)

哈希表法加速倒排索引：当两个集合要求交集时，如果一个集合特别大，另一个集合相对比较小，那我们就可以用哈希表来存储大集合。这样，我们就可以拿着小集合中的每一个元素去哈希表中对比

位图法加速倒排索引：

![2022112220367](/assets/2022112220367.webp)

升级版位图：Roaring Bitmap：为了解决传统位图的空间消耗问题：

![Roaring Bitmap](/assets/20221122204112.webp)

要确认一个元素是否在 Roaring Bitmap 中存在，通过两次查找就能确认了。第一步是以高 16 位在有序数组中二分查找，看对应的桶是否存在。如果存在，第二步就是将桶中的位图取出，拿着低 16 位在位图中查找，判断相应位置是否为 1

对联合查询加速：

![1. 对表达式进行变换减少运算次数](/assets/20221122204831.webp)

2. 使用多路归并，利用跳表的性质，快速跳过多个元素，加快多路归并的效率
3. 预先组合法：提前计算好某些查询的结果，需要时直接返回
4. 缓存

## 数据库检索

索引和数据分离：能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中，这样就能减少对磁盘的访问

- [B+树](/中间件/数据库/索引.md#B+ Tree原理)

## NoSQL检索

- [LSM树](/中间件/数据库/索引.md#LSM树)

## 大规模索引构建

### 索引创建

![20221123171130](/assets/20221123171130.webp)

![2022112317120](/assets/2022112317120.webp)

### 索引查询

对于能加载到内存中的文档列表，这没什么问题

但如果某些热词对应的文档列表过大，则需要利用磁盘索引数据结构，进行分层加载

### 索引更新

#### Double Buffer

为了避免读写竞争问题，可以在内存中同时保存两份一样的索引，一个是索引 A，一个是索引 B。我们会使用一个指针 p 指向索引 A，表示索引 A 是当前可访问的索引。那么用户在访问时就会通过指针 p 去访问索引 A。这个时候，如果我们要更新，只更新索引 B，当两份数据进行切换时，可以通过简单的原子操作修改引用即可

#### 全量索引结合增量索引

系统会周期性地处理全部的数据，生成一份完整的索引，也就是全量索引。这个索引不可以被实时修改，对于要更新的索引，在内存构建一份增量索引，当查询发生的时候，会同时查询全量索引和增量索引，将合并的结果作为总的结果输出

将增量索引合并到全量索引中的常见方法有 3 种：

1. 完全重建法：在增量索引写满内存空间之前，完全重建一次全量索引，然后将系统查询切换到新的全量索引上
2. 再合并法：对增量索引与全量索引进行归并
3. 滚动合并法：当内存中的增量索引增长到一定体量时，先合并到天级索引，天级索引量够了，再合并到月级索引，以此类推

![滚动合并](/assets/20221123173710.webp)
