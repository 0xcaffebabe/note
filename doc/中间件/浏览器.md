# 浏览器

## 架构

单进程 -> 多进程 -> SOA

![多进程](/assets/2022920193524.webp)

![SOA:解决多进程的资源浪费问题](/assets/2022920193552.webp)

![从输入 URL 到页面展示完整流程](/assets/202292020140.webp)

在进行渲染进程的准备上，默认每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点（根域名相同、协议相同）的话，那么新页面会复用父页面的渲染进程

### 渲染流程

DOM树 + CSS规则树 -> 渲染树 -> 布局(Layout) -> 绘制(Painting) -> 合成

即关键渲染路径`JavaScript/CSS --> Style --> Layout --> Paint --> Composite`

1. 构建DOM树：将下载的 HTML 经由解析器解析，最终输出树状结构的 DOM
2. 样式计算：计算出 DOM 节点中每个元素的具体样式
   1. 将CSS转为浏览器能够理解的结构，也就是 styleSheets
   2. 标准化样式表中的属性值
   3. 根据styleSheets 将样式应用到DOM上
3. 布局阶段：计算出 DOM 树中可见元素的几何位置
4. 分层：为实现注入3D变换、Z轴排序等效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树
   1. 拥有层叠上下文属性的元素会被提升为单独的一层
   2. 需要剪裁（clip）的地方也会被创建为图层
5. 图层绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
6. 栅格化：将图层划分为图块（tile），合成线程会按照视口附近的图块来优先生成位图
7. 合成与显示：有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到显存中，最后再将内存显示在屏幕上

![DOM与样式表生成布局树](/assets/2022922171631.webp)

![生成图层树](/assets/2022922174123.webp)

![绘制列表](/assets/2022922174737.webp)

#### 相关概念

- 重排：DOM元素的大小和位置（几何位置属性）发生变化的时候，会触发布局。在布局阶段中，计算元素在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为回流、布局或重排（Reflow）
- 重绘：当直接修改元素的样式属性，重绘省去了布局和分层阶段
- 直接合成：更改一个既不要布局也不要绘制的属性，比如CSS 的 transform 来实现动画效果，要事先定义好will-change:transform; ，才能避免layout 和paint

## 垃圾回收

### 栈内存回收

![20221013162435](/assets/20221013162435.jpg)

### 堆内存回收

跟JVM的[垃圾回收](/编程语言/JAVA/JVM/自动内存管理/垃圾回收.md#垃圾回收算法)理论有许多相通之处

V8 中也会把堆分为新生代和老生代两个区域，两个区域分别由副、主垃圾回收器进行回收

- 新生代中用 Scavenge 算法来处理，即标记复制算法
- 主垃圾回收器是采用标记清除算法

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，让垃圾回收阶段与正常JS执行交替执行

![20221013163714](/assets/20221013163714.webp)

## 代码编译与执行

![20221013164947](/assets/20221013164947.webp)

- 解释器 Ignition 会根据 AST 生成字节码，并解释执行字节码
- 在 Ignition 执行字节码的过程中，如果发现有热点代码，，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，即 [JIT](/编程语言/JAVA/JVM/字节码.md#字节码的执行)
