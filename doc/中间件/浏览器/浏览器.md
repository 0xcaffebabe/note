# 浏览器

## 架构

单进程 -> 多进程 -> SOA

![多进程](/assets/2022920193524.webp)

![SOA:解决多进程的资源浪费问题](/assets/2022920193552.webp)

![从输入 URL 到页面展示完整流程](/assets/202292020140.webp)

在进行渲染进程的准备上，默认每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点（根域名相同、协议相同）的话，那么新页面会复用父页面的渲染进程

### 渲染流程

DOM树 + CSS规则树 -> 渲染树 -> 布局(Layout) -> 绘制(Painting) -> 合成

即关键渲染路径`JavaScript/CSS --> Style --> Layout --> Paint --> Composite`

1. 构建DOM树：将下载的 HTML 经由解析器解析，最终输出树状结构的 DOM
2. 样式计算：计算出 DOM 节点中每个元素的具体样式
   1. 将CSS转为浏览器能够理解的结构，也就是 styleSheets
   2. 标准化样式表中的属性值
   3. 根据styleSheets 将样式应用到DOM上
3. 布局阶段：计算出 DOM 树中可见元素的几何位置
4. 分层：为实现注入3D变换、Z轴排序等效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树
   1. 拥有层叠上下文属性的元素会被提升为单独的一层
   2. 需要剪裁（clip）的地方也会被创建为图层
5. 图层绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
6. 栅格化：将图层划分为图块（tile），合成线程会按照视口附近的图块来优先生成位图
7. 合成与显示：有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到显存中，最后再将内存显示在屏幕上

![DOM与样式表生成布局树](/assets/2022922171631.webp)

![生成图层树](/assets/2022922174123.webp)

![绘制列表](/assets/2022922174737.webp)

#### 相关概念

- 重排：DOM元素的大小和位置（几何位置属性）发生变化的时候，会触发布局。在布局阶段中，计算元素在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为回流、布局或重排（Reflow）
- 重绘：当直接修改元素的样式属性，重绘省去了布局和分层阶段
- 直接合成：更改一个既不要布局也不要绘制的属性，比如CSS 的 transform 来实现动画效果，要事先定义好will-change:transform; ，才能避免layout 和paint

## 垃圾回收

### 栈内存回收

![20221013162435](/assets/20221013162435.jpg)

### 堆内存回收

跟JVM的[垃圾回收](/编程语言/JAVA/JVM/自动内存管理/垃圾回收.md#垃圾回收算法)理论有许多相通之处

V8 中也会把堆分为新生代和老生代两个区域，两个区域分别由副、主垃圾回收器进行回收

- 新生代中用 Scavenge 算法来处理，即标记复制算法
- 主垃圾回收器是采用标记清除算法

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，让垃圾回收阶段与正常JS执行交替执行

![20221013163714](/assets/20221013163714.webp)

## 代码编译与执行

![20221013164947](/assets/20221013164947.webp)

- 解释器 Ignition 会根据 AST 生成字节码，并解释执行字节码
- 在 Ignition 执行字节码的过程中，如果发现有热点代码，，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，即 [JIT](/编程语言/JAVA/JVM/字节码.md#字节码的执行)

## 页面循环系统

```js
while(running) {
   const task = getTaskFromQueue();
   task.run();
}
```

![20221014152719](/assets/20221014152719.webp)

### 宏任务微任务

宿主发起的任务称为宏观任务，时间粒度比较大，执行的时间间隔是不能精确控制的

- 渲染事件（如解析 DOM、计算布局、绘制）
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
- JavaScript 脚本执行事件
- 网络请求完成、文件读写完成事件

JavaScript 引擎发起的任务称为微观任务

- MutationObserver 监控
- 使用 Promise

有一个独立的线程执行事件循环不断消费宏观任务队列的任务，Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列

执行主线程宏任务-->执行所有的微任务,直到清空微任务的队列-->执行一个宏任务--->执行微任务(因为这时候可能又产生了新的微任务)--一个宏-->所有微，然后一直循环往复直到结束

为了实现对任务的优先级处理，就可以把一些优先级高的任务插入到微任务队列

为了规避某些任务执行过长导致整体阻塞的问题，JavaScript 可以通过回调功能也就是让任务滞后执行来强制规避阻塞

### setTimeout

```js
while(running) {
   const task = getTaskFromQueue();
   task.run();
   runDelayTask();
}
```

延迟任务的实现就是在宏任务执行完成之后，从延迟任务队列取任务进行执行，所以这就会导致如果宏任务里面的任务执行比较久，延迟任务也会相应的延迟

setTimeout 存在嵌套调用被嵌套调用 5 次以上的情况，系统会判断该函数方法被阻塞了，那么系统会设置后续的调用最短时间间隔为 4 毫秒

```js
function cb() { setTimeout(cb, 0); }
setTimeout(cb, 0);
```

为了优化后台页面的加载损耗以及降低耗电量，未激活的页面，setTimeout 执行最小间隔是 1000 毫秒

大部分浏览器都是用32位整数存储延迟值，所以当大于 2147483647 时就会溢出变成 0
