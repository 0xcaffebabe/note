---
tags: ['分布式系统', '操作系统', '隔离技术']
---

# 容器化

## 一、容器的第一性原理

### 1.1 容器是什么（本质定义）

**容器不是虚拟机，不是轻量级 OS，而是一组受约束的进程集合。**

> 容器 = 进程 + 受限视图 + 受控资源 + 安全策略

其成立依赖一个根本事实：

> **操作系统本身就是资源管理与隔离系统**。

Linux 内核早已具备：

* 资源分配能力（CPU / 内存 / IO）
* 访问边界控制能力（进程 / 文件 / 网络）

容器化只是将这些能力**组合、产品化、标准化**。

---

### 1.2 为什么容器不需要“虚拟硬件”

| 对比维度   | 虚拟机   | 容器    |
| ------ | ----- | ----- |
| 虚拟化层级  | 硬件层   | 操作系统层 |
| 是否包含内核 | 是     | 否     |
| 隔离对象   | OS 实例 | 进程视图  |
| 资源开销   | 高     | 低     |

**关键差异并不在“轻量”，而在“抽象层级”。**

* VM 复制了一套“机器”
* 容器复用了一套“操作系统”，只隔离“使用方式”

---

## 二、容器系统的统一抽象模型

### 2.1 容器的五大构成要素

```text
┌─────────────────────────────────┐
│            Container             │
│ ┌──────────────┐ ┌────────────┐ │
│ │ 视图隔离     │ │ 资源控制   │ │
│ │ Namespace    │ │ Cgroups    │ │
│ └──────────────┘ └────────────┘ │
│ ┌────────────────────────────┐ │
│ │ 文件系统视图（rootfs）     │ │
│ └────────────────────────────┘ │
│ ┌────────────────────────────┐ │
│ │ 进程模型（PID 1 / 信号）   │ │
│ └────────────────────────────┘ │
│ ┌────────────────────────────┐ │
│ │ 安全策略（Caps / UserNS）  │ │
│ └────────────────────────────┘ │
└─────────────────────────────────┘
```

容器并非单一技术，而是**多个内核子系统的协作结果**。

---

### 2.2 稳定知识与易变知识分层

| 层级    | 内容                 | 稳定性 |
| ----- | ------------------ | --- |
| 第一性原理 | 进程隔离、资源分配          | 极高  |
| 架构模式  | Namespace + Cgroup | 高   |
| 内核机制  | CFS、OOM、OverlayFS  | 中   |
| 实现工具  | Docker / CRI       | 低   |

本文聚焦前两层，第三层作为支撑，第四层仅作示例。

---

## 三、视图隔离：Namespace 的设计哲学

### 3.1 Namespace 的本质

> **Namespace 不是“安全机制”，而是“视图重映射机制”。**

它回答的问题是：

> “这个进程**能看到什么**？”

而不是：

> “这个进程**能做什么**？”

---

### 3.2 Namespace 的分类抽象

| Namespace | 隔离对象  | 设计目的   |
| --------- | ----- | ------ |
| PID       | 进程号空间 | 进程树独立  |
| Mount     | 文件系统  | 路径视图独立 |
| Network   | 网络栈   | 网络拓扑独立 |
| UTS       | 主机标识  | 系统身份独立 |
| IPC       | 进程通信  | 通信边界   |
| User      | 用户身份  | 权限映射   |

**它们共同完成：对“同一内核，不同世界”的构造。**

---

## 四、资源控制：Cgroups 的系统模型

### 4.1 Cgroups 的第一性原理

> **资源不是无限的，必须被公平、可控地分配。**

Cgroups 解决的问题是：

* 一个进程组
* 最多能用多少资源
* 超出时系统如何退化

---

### 4.2 Cgroups 的设计模式

| 子系统    | 控制维度      | 核心哲学    |
| ------ | --------- | ------- |
| CPU    | 时间片       | 公平 + 上限 |
| Memory | 页面        | 生存优先    |
| IO     | 带宽 / IOPS | 系统整体稳定  |

Cgroups **不追求性能最大化，而追求系统可预测性**。

---

### 4.3 v1 → v2 的演进逻辑

v2 的本质变化不是 API，而是：

> **从“子系统视角”转为“进程组视角”**

* v1：一个进程属于多个 group
* v2：一个进程属于一个 group

这使资源治理逻辑更加一致、可组合。

---

## 五、容器的进程模型

### 5.1 PID 1 的系统含义

在容器中，PID 1 并不是普通进程，而是：

* 信号接收者
* 子进程回收者
* 生命周期锚点

> **一个不正确的 PID 1，会导致整个容器的资源泄露。**

---

### 5.2 信号与退出的设计哲学

* SIGTERM：协作式退出
* SIGKILL：系统兜底

容器停止 = **对“进程树”的有序拆解**，而非简单 kill。

---

## 六、文件系统视图：rootfs 与分层

![2022122413485](/assets/2022122413485.webp)

### 6.1 rootfs 的本质

> rootfs 不是 OS，而是：
> **进程运行所需最小文件视图集合**。

容器镜像 ≠ 操作系统
容器镜像 = 运行时依赖快照

---

### 6.2 分层与 Copy-on-Write 的哲学

分层设计解决的不是功能问题，而是：

* 存储复用
* 构建效率
* 分发成本

这是**工程规模问题的系统性解法**。

---

## 七、网络：性能、隔离与复杂性的权衡

### 7.1 Network Namespace 的抽象

Network Namespace = 一套完整的网络协议栈视图。

容器网络的复杂性来自：

> **既要隔离，又要互通。**

---

### 7.2 网络方案的权衡模型

| 方案      | 优势  | 代价      | 适用  |
| ------- | --- | ------- | --- |
| veth    | 通用  | softirq | 默认  |
| macvlan | 高性能 | 无 NAT   | 高吞吐 |
| Overlay | 跨主机 | 封包      | 云环境 |
| BGP     | 原生  | 运维复杂    | 大规模 |

---

## 八、安全模型：边界而非绝对隔离

### 8.1 容器安全的核心事实

> **容器安全 ≠ VM 级安全**。

它依赖：

* 权限最小化
* 攻击面缩减
* 信任边界清晰

---

### 8.2 User Namespace 与 Rootless 的意义

这是容器安全演进中最关键的一步：

> **将“root”变成一种相对概念。**

---

## 九、编排系统的抽象价值

容器编排系统并不关心“怎么跑进程”，而关心：

* 系统如何自愈
* 资源如何整体调度
* 服务如何持续可用

Kubernetes 是：

> **分布式操作系统的控制平面雏形**。

---

## 十、容器化的长期工程哲学

### 10.1 三个不可违背的原则

1. **最小化原则**

   * 权限最小
   * 镜像最小
   * 能力最小

2. **可观测性优先**

   * 资源可见
   * 行为可追踪

3. **失败是常态**

   * OOM 会发生
   * 重启是设计的一部分

## 关联内容（自动生成）

- [/操作系统/虚拟化.md](/操作系统/虚拟化.md) 虚拟化与容器化是两种不同的资源隔离技术，文档详细介绍了虚拟化的基本概念、技术实现和与容器化的关系
- [/操作系统/linux/内核.md](/操作系统/linux/内核.md) Linux内核中的namespace和cgroup机制是容器化技术的基础，文档深入解析了这些内核机制的实现原理
- [/计算机网络/Linux虚拟化.md](/计算机网络/Linux虚拟化.md) Linux网络虚拟化技术与容器网络密切相关，特别是namespace、veth、bridge等技术在容器网络中的应用
- [/运维/Docker.md](/运维/Docker.md) Docker是容器化技术的典型实现，文档介绍了Docker的架构、使用方法以及与底层Linux内核机制的关系
- [/运维/K8s.md](/运维/K8s.md) Kubernetes是容器编排系统的代表，文档阐述了如何通过Kubernetes管理大规模容器化应用
- [/软件工程/架构/系统设计/云原生.md](/软件工程/架构/系统设计/云原生.md) 云原生架构与容器化技术密切相关，文档探讨了容器化如何改变应用的开发、部署和运维模式
- [/操作系统/安全.md](/操作系统/安全.md) 容器化环境下的安全模型与传统操作系统安全有相似之处，都涉及资源隔离与权限管理
- [/计算机网络/云计算.md](/计算机网络/云计算.md) 云计算环境大量使用容器化技术来实现资源的弹性分配和隔离，文档中的虚拟化技术与容器化有密切关系
