# 操作系统设计

## 设计问题的本质

### 目标

- 定义抽象概念：使用一些抽象概念来具象化操作系统
- 提供基本操作
- 确保隔离：进程隔离 故障隔离 用户隔离
- 管理硬件：驱动硬件来完成软件功能

### 操作系统设计的困难性

- 庞大
- 并发问题
- 安全性
- 通用性
- 可移植性

## 接口设计

- 从一个系统对外提供的接口开始设计，以此延伸到底层

### 设计原则

关于接口的设计原则，UNIX编程艺术提供了许多，诸如

- 简单：接口的简单性
- 完备：以最少的接口集合实现尽可能多的功能
- 效率：接口实现的执行效率

### 范型

选择操作系统对外提供的接口的表现形式

- 用户界面范型：接口对用户的表现形式 如 UI驱动
- 执行范型：应用程序代码的执行形式
  - 过程性范型
  - 事件驱动范型
- 数据范型：系统的结构对设备对外的表现形式 这种统一的形式并不代表一切操作都能用固定的几个系统调用来完成 还是需要特殊化处理
  - unix的一切皆文件
  - 而windows则是使用了句柄达到更通用的效果

### 系统调用接口

> 更多的代码意味着更多的 BUG
> 不要将牛逼的能力隐藏在抽象的接口后面

## 实现

### 系统结构

- 分层系统
- 外内核：能在用户进程实现的功能就不要放在内核里
- 基于微内核的CS系统：内核提供通信能力使各个插件（进程）能相互通信以完成功能
- 可扩展的系统：以可信的方式将更多的代码置入内核之中
- 内核线程

### 机制与策略

机制（如何做）与策略（做什么）分离有利于系统保持小巧和良好的结构

- [策略模式](/软件工程/设计模式/行为模式.md#策略模式)

### 正交性

不同概念之间没有交集，可以独立组合，达到更强的能力

### 命名

### 绑定的时机

### 静态与动态结构

### 自顶向下与自顶向上

### 同步通信与异步通信

### 实用技术

- 隐藏硬件
- 引用
- 可重用性
- 重入
- 检查可能的错误

## 性能

### 为什么慢

### 优化什么

### 空间时机权衡

### 缓存

### 线索

### 局部化原理

## 项目管理

