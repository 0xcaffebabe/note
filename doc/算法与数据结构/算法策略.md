---
tags: ['算法', '数据结构与算法']
---

# 算法策略

> **算法的本质：**
> 在**有限或可结构化的解空间**中，
> 在**约束条件**下，
> 以**可接受的计算成本**，
> **搜索或构造目标函数的最优解**。

---

## 一、算法的第一性原理

### 1. 解空间（Solution Space）

* 所有可能解的集合
* 可显式枚举 / 可隐式生成 / 可数学建模
* 决定算法是否可行、复杂度上限

### 2. 目标函数（Objective Function）

* 最大化 / 最小化 / 满足约束
* 决定"什么是好解"

### 3. 约束条件（Constraints）

* 显式约束（容量、数量、边界）
* 隐式约束（结构合法性、冲突规则）

---

## 二、算法范式的统一抽象模型

所有算法都可以抽象为：

[
f(x) = g({ v(f(s(x, c)), c) \mid c \in values(x) })
]

| 符号        | 含义                          |
| --------- | --------------------------- |
| x         | 当前问题状态                      |
| values(x) | 当前状态下的可选决策集合                |
| c         | 一次决策                        |
| s(x, c)   | 状态转移函数                      |
| f(x)      | 状态 x 的最优解                   |
| v         | 当前决策与子问题结果的组合               |
| g         | 优化算子（min / max / selection） |

**不同算法的差异，本质只在于：**

* values(x) 的规模
* 是否缓存 f(x)
* 是否允许回退
* 是否有启发式偏好

---

## 三、搜索型算法思想（完整性优先）

> 关注：**是否能穷尽解空间**

### 1. 枚举法（Exhaustive Search）

* 对所有解逐一尝试
* 解空间有限且规模可控

**本质：**

* 无剪枝
* 无信息复用
* 时间换正确性

---

### 2. 回溯法（Backtracking）

* 深度优先搜索 + 剪枝
* 遇到非法或无解路径即回退

**成立条件：**

* 解空间可构建为树
* 存在可判定的非法分支

**本质：**

* 枚举 + 剪枝
* DFS 搜索策略

---

### 3. 分支限界法（Branch and Bound）

* 广度优先或优先队列
* 使用上下界估计提前剪枝

**与回溯的核心差异：**

| 维度   | 回溯        | 分支限界             |
| ---- | --------- | ---------------- |
| 搜索顺序 | DFS       | BFS / Best-first |
| 目标   | 所有解 / 任一解 | 最优解              |
| 剪枝依据 | 可行性       | 上下界              |

---

## 四、结构型算法思想（问题可分解）

> 关注：**问题是否可拆解为同构子问题**

### 1. 递归（实现机制）

* 一种**问题描述方式**
* 不是算法思想本身

**递归必须具备：**

* 递推关系
* 基本情况

---

### 2. 分治法（Divide and Conquer）

* 将问题拆解为若干规模更小、结构相同的子问题
* 子问题相互独立
* 子解可合并

**成立条件：**

* 子问题独立
* 合并成本可控

**典型递归式：**
[
T(n) = aT(n/b) + f(n)
]

---

## 五、最优化算法思想（效率优先）

> 关注：**如何减少搜索成本**

### 1. 贪心算法（局部启发式）

* 每一步做当前最优选择
* 不回退

**成立条件（缺一不可）：**

* 贪心选择性质
* 最优子结构

**本质：**

* 将 values(x) 压缩为 1
* 放弃完整性换速度

---

### 2. 动态规划（全局状态最优）

> **动态规划不是递归优化，而是状态空间建模**

#### 三大核心要素

1. **最优子结构**
2. **无后效性**
3. **（优势而非必要）子问题重叠**

#### 两种实现方式

* 自顶向下：递归 + 备忘录
* 自底向上：状态表推进

**本质：**

* 用空间换时间
* 将指数级搜索压缩为多项式级状态遍历

---

## 六、数学建模型算法思想

### 1. 线性规划

* 决策变量
* 目标函数
* 线性约束

**本质：**

* 将问题转化为几何空间中的最优点搜索

---

### 2. 网络流

* 特殊结构的线性规划
* 利用图结构进行高效求解

---

## 七、算法范式对比总览（稳定认知表）

| 范式   | 是否穷尽 | 是否回退 | 是否缓存 | 搜索成本 |
| ---- | ---- | ---- | ---- | ---- |
| 枚举   | 是    | 否    | 否    | 极高   |
| 回溯   | 是    | 是    | 否    | 高    |
| 分支限界 | 否    | 是    | 否    | 中    |
| 贪心   | 否    | 否    | 否    | 低    |
| 分治   | 否    | 否    | 少量   | 中    |
| 动态规划 | 否    | 否    | 是    | 低    |

---

## 八、算法工程与设计哲学（稳定经验层）

### 1. 数据结构决定程序

* 数据结构 = 解空间的物理形态
* 错误结构 → 错误算法复杂度

---

### 2. 性能分析的层次

1. 问题定义
2. 算法与数据结构
3. 系统结构
4. 编译与代码
5. 系统软件
6. 硬件

---

### 3. 优化原则

* 先正确，后优化
* 先度量，再优化
* 不成熟的优化是灾难

---

### 4. 空间与时间的权衡

* 缓存
* 状态压缩
* 稀疏结构
* 计算换存储

---

## 九、算法设计的元技巧

* 明确真实需求
* 正确评估问题规模
* 选择合适的算法范式
* 接受不完美解（工程理性）

## 关联内容（自动生成）
- [/算法与数据结构/基本数据结构.md](/算法与数据结构/基本数据结构.md) 介绍了基础数据结构，与算法策略中提到的解空间和数据结构决定程序的哲学密切相关
- [/算法与数据结构/排序.md](/算法与数据结构/排序.md) 排序算法是算法策略的具体实现，体现了不同算法范式的应用
- [/算法与数据结构/查找.md](/算法与数据结构/查找.md) 查找算法是算法策略中搜索型算法思想的具体体现
- [/算法与数据结构/树.md](/算法与数据结构/树.md) 树结构是许多算法（如分治法、动态规划）的基础数据结构
- [/算法与数据结构/图.md](/算法与数据结构/图.md) 图算法是算法策略在特定数据结构上的应用，体现了搜索与优化思想
- [/中间件/数据库/redis/数据结构.md](/中间件/数据库/redis/数据结构.md) 介绍了Redis中数据结构的设计思想，与算法策略中数据结构决定程序的观点呼应
- [/软件工程/设计模式/行为模式.md](/软件工程/设计模式/行为模式.md) 算法策略中的策略模式思想，如模板方法模式体现了算法骨架的构建
- [/中间件/数据库/索引.md](/中间件/数据库/索引.md) 索引是数据结构与算法的结合体，体现了算法在实际系统中的应用
- [/数据技术/检索技术.md](/数据技术/检索技术.md) 检索技术是算法策略在数据处理领域的具体应用
- [/软件工程/架构/系统设计/分布式/分布式共识算法.md](/软件工程/架构/系统设计/分布式/分布式共识算法.md) 分布式算法是算法策略在分布式系统中的延伸