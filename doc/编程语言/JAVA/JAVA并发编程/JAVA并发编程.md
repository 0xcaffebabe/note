---
tags: ['并发编程', 'java', '线程', '多线程', '线程安全']
---

# Java 并发编程

## 一、并发编程的本质问题（第一性原理层）

并发编程并不是关于“多线程”，而是关于**在不确定时序下，对共享状态的控制问题**。

### 1. 并发的三个永恒问题

所有并发 Bug，本质上都可以归结为以下三类之一：

1. **可见性（Visibility）**
   一个线程对状态的修改，是否能被其他线程观察到。

2. **原子性（Atomicity）**
   一个操作是否不可被中断、不可被拆分。

3. **有序性（Ordering）**
   程序执行顺序在不同线程观察下是否一致。

> 这三者是跨语言、跨平台、跨时代的并发本质问题。

---

## 二、并发控制的核心思想（跨语言稳定层）

这一层不依赖 Java，也不依赖 JVM，而是并发系统设计的通用思想。

### 2.1 不共享是最高级的并发安全

并发问题的根源在于**共享**，因此：

> **不共享 = 天然线程安全**

#### 线程封闭（Thread Confinement）

* 对象只在单一线程内使用
* 不需要任何同步机制

常见形式：

* 栈封闭（方法内对象）
* 任务私有对象

> 封闭是一种“架构选择”，不是语法技巧。

---

### 2.2 只读共享：不变性（Immutability）

如果共享不可避免，下一优先级是：

> **共享但不可变**

不变对象的并发安全来自其数学属性，而非同步机制。

不变性的三个条件：

* 状态创建后不可修改
* 所有字段为 final
* 构造期间 this 不逸出

> 不变性是并发世界中最强的确定性来源。

---

### 2.3 受控共享：同步与协作

当对象既需要共享，又必须可变：

> 并发的核心任务 = **协调对状态的访问顺序**

这引出了同步、锁、条件等待等机制。

---

## 三、对象共享与发布模型（并发设计主线）

### 3.1 对象生命周期视角

并发安全问题，本质是**对象生命周期与线程生命周期不一致**。

关键问题：

* 对象何时创建？
* 何时对其他线程可见？
* 由谁负责修改？

---

### 3.2 发布与逸出

* **发布**：对象从私有域进入共享域
* **逸出**：对象在未准备好时被发布

构造期间逸出是最危险的并发错误之一。

---

### 3.3 安全发布（Safe Publication）

安全发布不是“是否加锁”，而是**建立可见性与有序性保证**。

通用安全发布策略：

* 静态初始化
* final 字段语义
* volatile / 原子引用
* 锁保护的发布

> 没有安全发布，线程安全无从谈起。

---

## 四、并发类的设计模式（架构层）

### 4.1 实例封闭（Instance Confinement）

将线程不安全对象封装在一个受控的并发边界内。

* 并发策略集中
* 对外暴露安全接口

这是最常见、也是最稳健的并发类设计方式。

---

### 4.2 线程安全委托（Delegation）

将并发安全责任交给更底层的线程安全组件。

前提：

* 不引入新的复合状态依赖

> 委托失败，往往源于“多个原子操作组合后不再原子”。

---

### 4.3 状态依赖操作

并发系统中最复杂的不是互斥，而是：

> **操作是否依赖于状态是否满足某个条件**

这类操作需要：

* 条件检查
* 等待
* 被唤醒后重新校验

---

## 五、等待、通知与协作机制

### 5.1 等待-通知的本质模型

等待不是“睡眠”，而是：

> **在条件未满足时，主动让出执行权，并等待条件变化的通知**

核心原则：

* 等待必须释放锁
* 被唤醒 ≠ 条件满足
* 条件检查必须在循环中

---

### 5.2 条件队列与显式条件

条件队列解决的是：

* 多条件等待
* 精准唤醒
* 可中断 / 可超时

它体现的是**状态机式并发设计思想**。

---

## 六、取消、关闭与线程生命周期管理

### 6.1 取消不是强制终止

并发系统中：

> **取消是一种协作协议，而非控制命令**

线程必须自行决定：

* 是否响应取消
* 如何清理资源

---

### 6.2 中断的语义

中断不是异常，而是：

> **一种跨线程的协作信号**

设计原则：

* 不知道中断策略，不要中断
* 阻塞方法要么响应中断，要么明确不可中断

---

### 6.3 基于任务的取消

Future、Executor 的意义在于：

* 将线程管理权从业务逻辑中剥离
* 提供统一的生命周期控制

---

## 七、性能与伸缩性的并发视角

### 7.1 并发的成本模型

并发不是免费的：

* 上下文切换
* 同步开销
* 阻塞等待

> 并发的目标不是“线程更多”，而是“等待更少”。

---

### 7.2 锁竞争的本质

竞争强度取决于：

* 请求频率
* 持锁时间

优化方向：

* 减少共享
* 缩短临界区
* 降低热点

---

## 八、JVM 层面的并发优化（实现细节层）

> 本章属于**了解即可**，不应作为设计依据。

* 偏向锁
* 轻量级锁
* 自旋与自适应自旋
* 锁消除与锁粗化

这些优化的前提是：

> **你的并发设计本身是合理的**

---

## 九、并发程序的测试哲学

### 9.1 并发测试的困难

并发 Bug 是：

* 时序相关的
* 不可复现的
* 概率性的

---

### 9.2 测试关注点

* 正确性（不变性、后验条件）
* 安全性（无越界、无破坏）
* 活跃性（无死锁、无饥饿）
* 性能特性（吞吐、延迟）

---

## 十、并发系统的工程哲学（长期稳定知识）

* 并发不是为了快，而是为了**隐藏等待**
* 不共享是最高级的线程安全
* 锁是成本，不是能力
* 中断是协议，不是异常
* 并发 Bug 本质是**时间维度的 Bug**

> 一个优秀的并发系统，应该让并发问题**难以出现，而不是容易修复**。

## 关联内容（自动生成）

- [/编程语言/JAVA/JAVA并发编程/基础概念.md](/编程语言/JAVA/JAVA并发编程/基础概念.md) 深入了解Java并发编程的基础概念，包括线程生命周期、并发问题等核心知识点
- [/编程语言/JAVA/JAVA并发编程/线程.md](/编程语言/JAVA/JAVA并发编程/线程.md) 详细探讨Java中线程的创建、管理和控制机制，与本文档中的线程生命周期管理内容密切相关
- [/编程语言/JAVA/JAVA并发编程/线程池.md](/编程语言/JAVA/JAVA并发编程/线程池.md) 线程池是实现高效并发的关键组件，提供了线程生命周期管理的高级抽象
- [/编程语言/JAVA/JAVA并发编程/并发工具类.md](/编程语言/JAVA/JAVA并发编程/并发工具类.md) Java并发包提供了丰富的同步工具类，是实现本文档所述并发控制思想的具体手段
- [/编程语言/JAVA/JAVA并发编程/并发集合.md](/编程语言/JAVA/JAVA并发编程/并发集合.md) 并发集合是线程安全的数据结构，体现了本文档中提到的实例封闭和线程安全委托设计模式
- [/编程语言/JAVA/JVM/JAVA内存模型.md](/编程语言/JAVA/JVM/JAVA内存模型.md) Java内存模型定义了多线程环境下的内存访问规则，是理解可见性、原子性和有序性问题的基础
- [/操作系统/进程与线程.md](/操作系统/进程与线程.md) 操作系统层面的进程与线程概念是理解Java并发编程模型的基础，有助于深入理解线程调度和同步机制
- [/软件工程/架构/系统设计/高并发.md](/软件工程/架构/系统设计/高并发.md) 高并发系统设计涉及大量并发编程原理的应用，是本文档理论知识的实际应用场景
- [/编程语言/并发模型.md](/编程语言/并发模型.md) 不同编程语言的并发模型比较，有助于理解Java并发编程模型的特点和优势
- [/计算机网络/IO模型.md](/计算机网络/IO模型.md) IO模型与并发编程密切相关，特别是在处理高并发网络请求时，需要结合IO模型选择合适的并发策略
