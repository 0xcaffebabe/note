# 日志

- 记录操作
- 监控系统
- 回溯故障

## 日志规范

文件命名：appName_logType_logName.log

日志文件的保存时间衡量因素：

1. 重要程度
2. 文件大小
3. 磁盘空间

### 日志级别

- DEBUG 对调试有帮助的信息
- INFO 未发生错误 但对其他错误排查有指导作用
- WARN 偏向于此处有出现错误的可能
- ERROR 发生了错误需要被关注 但没有影响系统运行
- FATAL 严重错误 程序中断

### 日志类别

- 系统日志：可读性要求没那么高，日志中会包含代码的信息，比如在某个类的某一行打印了一个日志
- 操作日志：要求可读性比较强，因为它主要是给用户看的

## 日志实现

### 使用类似 Canal 的中间件监听数据变化 写日志

### 日志文件

- 操作人记录 使用 [ThreadLocal](/编程语言/JAVA/JAVA并发编程/并发工具类.md#ThreadLocal) 实现

```java
LoginUtil.setCurrentUser("cxk")
```

- 区分系统日志与操作日志

配置不同的logger

```java
private final Logger businessLog = LoggerFactory.getLogger("businessLog");
```

- 日志文案

```java
template = "用户 %s 做了 %s";
log.error(String.format(template, "cxk", "打篮球"))
```

### AOP方法注解

```java
// bizNo 业务唯一ID 方便进行日志搜索
// 通过使用自定义函数配合SpEL来分离业务逻辑与日志记录
@LogRecord(content = "修改了订单的配送员：从“{queryOldUser{#request.deliveryOrderNo()}}”, 修改到“{deveryUser{#request.userId}}”",
        bizNo="#request.deliveryOrderNo")
public void modifyAddress(updateDeliveryRequest request){
    // 更新派送信息 电话，收件人、地址
    doUpdate(request);
}
```

![AOP日志设计](/assets/20221711756.png)

## 日志使用

### 预先判断日志级别

避免使用字符串的形式连接打印日志

```java
log.debug("user " + id + "create new order " + orderId) // bad

if (log.enableDebug){ // good
  log.debug(...)
}
log.debug('user {} create new order {}', id, orderId) // good
```

主要是防止无谓的字符串连接消耗系统资源

### 避免无效日志打印

对于debug log 等低级别的日志 一定要控制好输出量 避免磁盘空间被快速吞掉

### 区别对待错误日志

不能将所有错误一股脑归类为ERROR级别

ERROR级别就代表是需要人工介入处理的级别

### 日志记录的内容

1. 一定要输出异常堆栈
2. 输出对象实例时 要确保对象重写了 toString 方法

## 日志框架

![日志框架](/assets/屏幕截图%202020-09-19%20114841.png)
