---
tags: ['编程语言']
---

# Java 泛型

## 一、泛型的本质

### 1. 泛型要解决的根本问题

在没有泛型的时代，Java 集合只能以 `Object` 为通用载体：

```java
List list = new ArrayList();
list.add("hello");
Integer i = (Integer) list.get(0); // 运行时异常
```

问题的本质是：

> **类型信息丢失 + 类型检查延后**

错误只能在运行时暴露，而不是在编译期被发现。

---

### 2. 泛型的核心思想

**泛型的本质：类型参数化（Parameterized Type）**

泛型不是一种新功能，而是对类型系统的扩展：

* 让“类型”像“参数”一样参与抽象
* 把类型检查从运行时提前到编译时
* 在不牺牲复用性的前提下保证类型安全

---

### 3. 泛型带来的核心价值

泛型的价值可以归纳为三个维度：

| 维度   | 本质            |
| ---- | ------------- |
| 类型安全 | 将运行时错误提前到编译期  |
| 表达能力 | 明确数据结构中的类型意图  |
| 复用能力 | 让同一套代码服务于多种类型 |

---

## 二、Java 泛型的核心模型

Java 泛型可以抽象为两个基本要素：

```
泛型 = 类型参数化 + 类型约束
```

* **类型参数化**：让类或方法不再依赖具体类型
* **类型约束**：对参数化类型施加边界限制

---

### 泛型知识结构总览

```
泛型
│
├── 类型参数化
│   ├── 泛型类
│   ├── 泛型接口
│   └── 泛型方法
│
├── 类型约束
│   ├── 上界约束 extends
│   ├── 下界约束 super
│   └── 通配符 ?
│
├── 使用原则
│   └── PESC 原则
│
└── 实现机制
    └── 泛型擦除
```

---

## 三、类型参数化的三种形态

### 1. 泛型类

泛型类的本质：

> 把“类的类型信息”参数化

```java
class Box<T> {
    private T value;

    public Box(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

在这个结构中：

* `T` 不是某个具体类型
* 而是一个类型占位符

---

### 2. 泛型方法

泛型方法的本质：

> 把“方法的类型信息”参数化

```java
public static <T> T identity(T obj) {
    return obj;
}
```

这里：

* `<T>` 是方法的类型参数声明
* 后面的 `T` 是返回值类型

---

### 3. 泛型接口

与泛型类类似，接口也可以参数化：

```java
interface Converter<F, T> {
    T convert(F from);
}
```

---

### 小结

这三种形态本质一致：

| 形态   | 抽象层级     |
| ---- | -------- |
| 泛型类  | 对数据结构参数化 |
| 泛型接口 | 对行为参数化   |
| 泛型方法 | 对单个逻辑参数化 |

---

## 四、类型约束：对泛型的边界控制

单纯的类型参数化过于自由，因此需要约束。

---

### 1. 上界约束（extends）

```java
<T extends Comparable>
```

含义：

> T 必须是 Comparable 的子类

---

可以指定多个接口：

```java
<T extends Comparable & Serializable>
```

---

### 2. 通配符

通配符本质是：

> 对“泛型类型参数”的一种灵活表达

---

#### 上界通配符

```java
<? extends T>
```

语义：

> 接受 T 或 T 的子类型

---

#### 下界通配符

```java
<? super T>
```

语义：

> 接受 T 或 T 的父类型

---

#### 无界通配符

```java
<?>
```

语义：

> 不关心具体类型

---

## 五、PESC 原则：泛型使用的工程哲学

### 1. 原则本身

**Producer Extends Consumer Super**

* 生产者（读）用 extends
* 消费者（写）用 super

---

### 2. 原理本质

这个原则并不是一个“经验口诀”，而是类型系统约束的必然结果。

---

#### 上界通配符：协变视角（适合读）

```java
List<? extends Fruit> basket;
```

特点：

* 可以安全读取为 Fruit
* 不能安全写入

本质原因：

> 编译器无法确定具体子类型

---

#### 下界通配符：逆变视角（适合写）

```java
List<? super Apple> basket;
```

特点：

* 可以安全写入 Apple
* 读取时只能当作 Object

本质原因：

> 只能保证是 Apple 的父类，但不知道具体是哪一层

---

### 3. 工程意义

PESC 的真正含义是：

| 场景     | 选择            |
| ------ | ------------- |
| 主要用于读取 | `? extends T` |
| 主要用于写入 | `? super T`   |

---

### 4. API 设计中的体现

Java API 中的经典例子：

```java
public static <T> void copy(
    List<? super T> dest,
    List<? extends T> src
)
```

设计意图极为清晰：

* src：生产者 → extends
* dest：消费者 → super

---

## 六、泛型的实现机制：类型擦除

### 1. 核心事实

> JVM 并不真正理解泛型

在虚拟机层面：

* 只有普通类和方法
* 不存在真实的泛型类型

---

### 2. 泛型擦除的过程

编译阶段：

* 泛型参数被擦除为限定类型
* 必要时插入类型转换
* 自动生成桥方法

---

### 3. 为什么要擦除？

本质原因：

> 历史兼容性

* JVM 早于泛型诞生
* 为了兼容旧字节码
* 避免虚拟机层面的重大改造

---

### 4. 带来的代价

由于擦除：

* 运行时无法获取 T 的真实类型
* 反射操作受限
* 某些场景需要额外手段（TypeToken）

---

## 七、类型系统视角

泛型问题本质是一个类型系统问题。

---

### 1. 类型变化关系

设：

* A ≤ B 表示 A 是 B 的子类型
* f(·) 表示类型构造器

---

#### 协变（covariant）

```
A ≤ B  ⇒  f(A) ≤ f(B)
```

---

#### 逆变（contravariant）

```
A ≤ B  ⇒  f(B) ≤ f(A)
```

---

#### 不变（invariant）

```
f(A) 与 f(B) 无关
```

---

### 2. Java 中的选择

| 形态          | 类型关系 |
| ----------- | ---- |
| List<T>     | 不变   |
| ? extends T | 协变   |
| ? super T   | 逆变   |

---

### 3. 本质联系

* Java 默认选择“不变”
* 用通配符实现协变和逆变
* PESC 原则正是这一类型关系的工程化表达

---

## 八、对泛型的整体认知

我们可以把 Java 泛型总结为：

> 一套在“静态类型系统约束”与“历史兼容性”之间权衡的设计

---

### 三层模型

| 层次  | 含义                      |
| --- | ----------------------- |
| 语法层 | `<T>`、`extends`、`super` |
| 语义层 | 类型参数化与类型约束              |
| 实现层 | 类型擦除与桥方法                |

---

## 九、总结

### 1. 泛型的本质

* 不是语法糖
* 而是类型系统的扩展

---

### 2. 泛型的核心价值

* 类型安全
* 更好的抽象
* 更强的复用

---

### 3. 使用哲学

* 读：协变
* 写：逆变
* 读写混合：谨慎设计

## 关联内容（自动生成）

- [/编程语言/JAVA/高级/反射.md](/编程语言/JAVA/高级/反射.md) Java反射与泛型结合使用时，可以实现更强大的动态类型处理能力
- [/编程语言/JAVA/高级/注解.md](/编程语言/JAVA/高级/注解.md) 泛型与注解结合使用，可以在编译时进行更精确的类型检查和元数据处理
- [/编程语言/JAVA/高级/集合/集合.md](/编程语言/JAVA/高级/集合/集合.md) Java集合框架大量使用泛型，提供了类型安全的数据结构操作
- [/编程语言/JAVA/高级/Lambda表达式.md](/编程语言/JAVA/高级/Lambda表达式.md) Lambda表达式与泛型结合，增强了函数式编程的类型安全性和表达能力
- [/编程语言/编程范式/面向对象.md](/编程语言/编程范式/面向对象.md) 泛型是面向对象编程的重要特性，体现了参数化类型的抽象思想
- [/编程语言/C++.md](/编程语言/C++.md) C++模板与Java泛型在设计理念上有相似之处，但实现机制有所不同
- [/编程语言/编程范式/函数式编程.md](/编程语言/编程范式/函数式编程.md) 函数式编程中的高阶类型与泛型有密切关系，都涉及类型参数化
- [/软件工程/设计模式/创建型模式.md](/软件工程/设计模式/创建型模式.md) 创建型设计模式中经常使用泛型来提供类型安全的对象创建机制
