---
tags: ['编程语言', '编译原理', '执行与运行时', '计算模型', '类型系统']
---

# WebAssembly

## 一、WebAssembly 的本质定位

WebAssembly（Wasm）并不是一门编程语言，而是一种**面向多宿主环境的虚拟指令集架构（Virtual ISA, V-ISA）**。

* 对应物理世界中的 ISA（如 x86 / ARM），Wasm 作用于**虚拟执行体系**
* JVM 与 Wasm 同属 V-ISA，但设计目标不同：

  * JVM 面向对象与托管运行时
  * Wasm 面向**可验证、安全、可移植的底层执行模型**

**第一性原理**：

> Wasm 的核心目标不是"替代 JavaScript"，而是提供一种 *跨语言、跨平台、可沙箱化执行的最小通用计算抽象*。

---

## 二、整体系统分层模型（认知骨架）

```
┌────────────────────────────┐
│        应用 / 语言层        │  C / C++ / Rust / Go / …
├────────────────────────────┤
│        编译与 IR 层         │  LLVM IR → WASM Binary
├────────────────────────────┤
│     WebAssembly 指令集      │  Stack VM / Binary Format
├────────────────────────────┤
│   系统抽象层（WASI）        │  Capability-based API
├────────────────────────────┤
│        Wasm 运行时          │  Wasmtime / Wasmer / WAMR
├────────────────────────────┤
│        宿主环境             │  Browser / OS / Cloud / Edge
└────────────────────────────┘
```

该分层模型体现了 Wasm 的核心设计思想：**强边界、弱假设、最小抽象**。

---

## 三、Wasm 二进制模块的架构模型

Wasm 模块是一种**自描述、可验证、与平台无关的二进制单元**。其内部结构由一组 Section 组成，但 Section 的本质并非“文件格式”，而是**系统能力的声明集合**。

### 3.1 模块能力分类模型

| 能力维度 | 对应 Section             | 设计意图      |
| ---- | ---------------------- | --------- |
| 类型系统 | Type                   | 行为签名的前置声明 |
| 行为映射 | Function / Code        | 类型与实现的分离  |
| 状态模型 | Global / Memory / Data | 显式状态与线性内存 |
| 动态分发 | Table / Element        | 间接调用与多态   |
| 生命周期 | Start                  | 模块初始化钩子   |
| 边界接口 | Import / Export        | 能力与依赖显式化  |
| 元数据  | Custom                 | 调试与工具支持   |

### 3.2 魔数与版本

* 魔数：`0x00 0x61 0x73 0x6d`（"\0asm"）
* 版本号：MVP 为 `0x01`

**意义**：确保模块在加载前即可被快速识别与验证。

---

## 四、执行模型：栈式虚拟机与指令设计

Wasm 采用**栈式虚拟机模型**，其设计权衡包括：

* 指令紧凑，便于二进制压缩与网络传输
* 易于静态验证（无隐式寄存器依赖）
* 降低后端 JIT / AOT 的复杂度

### 4.1 数值与编码模型

* 固定宽度整数：`uintN`
* 变长整数：`varuintN / varintN`
* 统一使用 LEB128 编码

**设计哲学**：以编码复杂度换取传输与存储效率。

---

## 五、WAT：可读的等价表示

WebAssembly Text Format（WAT）是 Wasm 二进制的**语义等价文本表示**，主要用于：

* 人类阅读与调试
* 工具链中间表示

### 5.1 S-表达式与 Flat-WAT

* S-表达式：强调嵌套求值顺序（类似 Lisp）
* Flat-WAT：显式指令序列，贴近 VM 执行模型

### 5.2 工具链

* `wasm2wat`
* `wat2wasm`
* `wat-desugar`

---

## 六、运行时模型与内存体系

### 6.1 实例化语义

* 每个 Wasm 模块实例：

  * 拥有独立调用栈
  * 拥有私有线性内存（MVP 阶段仅 1 个）

### 6.2 线性内存模型

* 内存以 Page（64KB）为单位增长
* 在浏览器中通常映射为 `ArrayBuffer`

**核心思想**：

> 无指针共享、无隐式对象、无宿主内存污染。

---

## 七、WASI：系统调用的抽象层

WASI（WebAssembly System Interface）是 Wasm 在 Web 之外可运行的关键。

### 7.1 设计目标

* 与操作系统解耦
* 与具体平台无关
* 明确能力边界

### 7.2 Capability-based Security

* 模块默认无权限
* 权限通过 Import 显式授予
* 权限不可隐式扩散

**对比传统 OS**：

* fd / socket ≈ capability handle

---

## 八、纳米进程（Nanoprocess）模型

在 Wasm 语义下：

> **模块实例 = 最小隔离执行单元**

特征：

* 私有内存
* 私有栈
* 显式能力集
* 无全局共享状态

权限规则：

* 所有 capability 均来自调用者
* 不存在“越权系统调用”

该模型天然适配：

* Serverless
* Edge Computing
* 多租户环境

---

## 九、宿主环境与加载模型（以浏览器为例）

### 9.1 生命周期

1. fetch：获取二进制
2. compile：编译为平台代码
3. instantiate：绑定导入并初始化
4. call：执行导出函数

### 9.2 Web API

* `WebAssembly.Module`
* `WebAssembly.instantiate`
* Streaming API

---

## 十、运行时实现生态

| 运行时      | 特点        | 适用场景           |
| -------- | --------- | -------------- |
| Wasmtime | 标准友好、性能稳定 | 云 / Server     |
| Wasmer   | 多语言绑定     | 平台集成           |
| WAMR     | 轻量、C 实现   | IoT / Embedded |
| WasmEdge | 云原生导向     | Edge / AI      |

---

## 十一、编译体系与语言生态

* 多语言 → LLVM IR
* `llc` → WASM

**本质**：

> Wasm 是 LLVM 生态的可执行终点之一。

---

## 十二、能力边界与局限性

* DOM 操作需经宿主桥接
* 复杂数据类型需显式编解码

这是 Wasm **强隔离换取安全与可移植性** 的必然代价。

---

## 十三、应用定位与长期演进

### 当前稳定价值

* 浏览器中的计算密集任务
* 统一的跨语言执行格式

### 演进方向

* Component Model
* WASI Preview 2
* 更强的模块组合能力

---

## 总结

WebAssembly 是一种：

> **以安全、可验证、最小能力集为核心的通用执行抽象**。

它不是某一语言的替代品，而是未来多计算环境的**公共底座**。

---

## 关联内容（自动生成）

- [/编译原理/编译原理.md](/编译原理/编译原理.md) WebAssembly与编译原理密切相关，Wasm作为编译目标，连接了高级语言与底层执行模型，体现了编译器前端、中间表示和后端优化的完整流程
- [/编程语言/Rust.md](/编程语言/Rust.md) Rust是WebAssembly生态系统中最活跃的语言之一，Rust的内存安全特性与Wasm的安全执行模型相结合，为Wasm生态提供了强大的底层开发能力
- [/软件工程/架构/Web前端/Web前端.md](/软件工程/架构/Web前端/Web前端.md) WebAssembly与前端技术密切相关，是现代Web前端架构中的重要组成部分，用于提升计算密集型任务的性能
- [/操作系统/操作系统.md](/操作系统/操作系统.md) WebAssembly的虚拟指令集架构与操作系统的虚拟化和抽象概念有相似之处，Wasm的执行模型借鉴了操作系统的安全和隔离机制
