# 并发模型

- 并发与并行

并行架构：

- bit-level并行：从32位到64位
- 指令级并行：流水线技术、乱序执行
- 数据级并行：GPU的几百个核心并行对图像处理
- 任务级并行：多处理机系统

## 线程与锁

该模型是对底层硬件运行过程的形式化 适用面很广

没有为并行提供直接的支持

- 竞态条件
- 内存可见性
- 死锁

## 函数式编程

- 可变状态造成的风险

函数式代码可以随意改变其执行顺序 所以可以让相互独立的函数并行执行

## Actor

![Actor模型](/assets/屏幕截图%202021-11-30%20210829.png)

- 保留了可变状态 只是不共享（每个Actor只存在于属于自己的线程内）
- 单条不可变消息传输（使用mailbox）
- Actor之间通过消息交互
- 任其崩溃
- 天生分布式

### 操作

#### Create

父Actor创建管理子Actor，父Actor需要决定子Actor崩溃时采取的措施

![ASctor树](/assets/屏幕截图%202021-11-30%20220253.png)

#### Send

- 发送消息

#### Become

- 状态机

## 通信顺序进程

## 数据并行

- opencl

![屏幕截图 2020-12-31 160516](/assets/屏幕截图%202020-12-31%20160516.png)

## Lambda架构

