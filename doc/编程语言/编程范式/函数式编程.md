
# 函数式编程（Functional Programming）

> 函数式编程是一种**以数学函数为核心抽象**、以**不可变数据**和**无副作用计算**为基础的编程范式。
> 它将程序视为表达式之间的组合，而非一系列修改状态的命令。

---

## 一、命令式 vs 函数式：两种思维模型

* **命令式编程（Imperative Programming）**
  按照“程序是一系列改变状态的命令”来建模。
  核心是 **“怎么做”** —— 你一步步告诉计算机执行什么操作。

* **函数式编程（Functional Programming）**
  将程序描述为**表达式的组合**和**数据的变换**。
  核心是 **“是什么”** —— 定义数据之间的映射关系，而非操作过程。

> 换句话说，命令式编程像是“指挥演员演戏”，
> 函数式编程更像是“定义剧情规则，让演员自然演绎”。

---

## 二、核心思想：表达式与不可变性

函数式编程鼓励：

* 使用表达式（expression）而非语句（statement）；
* 数据不可变（immutable data）；
* 无副作用（pure function）；
* 函数为“一等公民”（First-class Function）。

它把底层细节（如内存管理、状态更新）交给运行时去优化，
开发者只需专注于描述**输入与输出的关系**。

这种思维带来的最大好处是：

> 控制权的上移 —— 从控制“怎么执行”，变成控制“怎么定义逻辑”。

---

## 三、函数式编程的三大核心操作

函数式编程往往围绕几种基础操作展开（以 List / Set / Map 为核心数据结构）：

### 1️⃣ filter（过滤）

保留满足条件的元素：

```js
[1, 2, 3, 4, 5].filter(x => x % 2 === 0)
// → [2, 4]
```

### 2️⃣ map（映射）

将集合中的每个元素“映射”为新的值：

```js
[1, 2, 3].map(x => x * 2)
// → [2, 4, 6]
```

### 3️⃣ reduce / fold（规约 / 折叠）

通过累加器把集合折叠为单个值：

```js
[1, 2, 3, 4].reduce((acc, x) => acc + x, 0)
// → 10
```

> filter / map / reduce 是函数式世界的“for 循环 + if + sum”三件套，
> 用声明式的方式表达数据转换。

---

## 四、函数式语言的权责转移

在函数式语言中，许多“命令式责任”被转移到语言运行时：

1. **底层迭代 → 高阶函数**

   * 用 `map`、`filter`、`reduce` 替代显式 for 循环。

2. **状态管理 → 闭包与不可变变量**

   * 不再维护共享变量，而是通过闭包捕获作用域。

3. **参数控制 → 柯里化（Currying）**

   * `process(x, y, z)` 变为 `process(x)(y)(z)`。
     每次调用返回一个新函数，就像“逐层工厂”。

4. **灵活复用 → 部分施用（Partial Application）**

   * 给函数固定一部分参数，得到一个“定制版函数”：
     `sum = add(5)` → `sum(3) = 8`。

---

## 五、从迭代到递归：让逻辑自洽

函数式编程不鼓励显式循环，而使用递归表达重复。

### 传统迭代：

```js
let sum = 0;
for (let i = 1; i <= 3; i++) sum += i;
```

### 函数式递归：

```js
function sum(n) {
  return n === 0 ? 0 : n + sum(n - 1);
}
```

### 尾递归优化（Tail Recursion）

尾递归允许编译器复用调用栈，避免堆栈溢出：

```js
function story() {
  // 尾递归：下一次调用不依赖当前栈
  return story(); 
}
```

与非尾递归的区别在于：

> 尾递归调用后没有额外逻辑 → 可直接返回结果。

---

## 六、函数式语言常见特性

### 1️⃣ 记忆（Memoization）

缓存函数结果以避免重复计算。
仅适用于**纯函数（Pure Function）**——即同输入、同输出、无副作用。

```js
function memoize(fn) {
  const cache = {};
  return (...args) => {
    const key = JSON.stringify(args);
    return cache[key] ?? (cache[key] = fn(...args));
  };
}
```

函数式语言通常能天然支持记忆化，如：

```lisp
(memoize (hash "homer"))
```

> 纯函数 + 不可变性 = 缓存安全。

---

### 2️⃣ 惰性求值（Lazy Evaluation）

表达式不会立即求值，而是**在需要时才计算**。
优点是节省资源、支持无限数据结构。

在 Java 中，可用 `Stream` 实现：

```java
Stream.of(1, 2, 3)
      .filter(x -> x > 1)
      .map(x -> x * 2);
```

直到 `.collect()` 执行前，上述操作都不会真正运行。

---

## 七、函数式的重用机制

在 OOP 中，**复用的单元是类或对象**。
在 FP 中，**复用的单元是函数**。

由于函数式语言的核心数据结构少（多为 List / Map），
重用往往通过“函数组合”完成。

例如：

```js
const pipeline = compose(
  filter(isValid),
  map(parse),
  reduce(sum)
);
```

> 这种组合模式比继承更轻量、更安全。

---

## 八、设计模式在函数式世界的变形

在函数式语言中，许多 OOP 设计模式变得不再必要，
因为语言特性本身已经提供了解决方案。

| 面向对象模式                | 在函数式中的替代                    |
| --------------------- | --------------------------- |
| 模板方法（Template Method） | 高阶函数（Higher-order Function） |
| 工厂方法（Factory）         | 部分施用 / 柯里化                  |
| 策略模式（Strategy）        | 函数作为参数传入                    |
| 观察者模式（Observer）       | 响应式流（Reactive Stream）       |

示例：

```groovy
class CustomerBlocks {
  def checkCredit, checkInventory, ship
  def process() {
    checkCredit()
    checkInventory()
    ship()
  }
}
```

在函数式中，这等价于：

```js
const process = compose(checkCredit, checkInventory, ship);
```

> OOP 通过“封装不确定因素”让代码易懂，
> FP 则通过“消除不确定因素”让代码易懂。

---

## 九、从函数式编程到函数式基础设施

函数式编程的哲学已渗透到现代架构中：

| 领域                            | 函数式思想体现      |
| ----------------------------- | ------------ |
| **不可变值（Immutable Value）**     | 函数式的基础假设     |
| **CQRS / Event Sourcing**     | 状态不可变、通过事件推导 |
| **函数式 Web 编程（WebFlux, Akka）** | 无共享状态的并发     |
| **日志数据库（如 Kafka）**            | 事件流即系统真相     |
| **Serverless 架构**             | 函数即服务（FaaS）  |

> 从“函数式编程”到“函数式基础设施”，
> 是软件工程抽象层次的一次跃迁。

---

## 🔚 十、总结

| 关键特性                            | 说明               |
| ------------------------------- | ---------------- |
| **纯函数（Pure Function）**          | 相同输入 → 相同输出，无副作用 |
| **不可变性（Immutability）**          | 数据不可修改，只能创建新版本   |
| **高阶函数（Higher-order Function）** | 函数可作为参数或返回值      |
| **组合（Composition）**             | 函数间可像积木一样拼接      |
| **惰性与记忆（Lazy + Memoization）**   | 高性能与确定性          |

> 函数式编程不只是“另一种写法”，
> 而是一种**从状态到变换**、从**控制到描述**的思想转变。
> 它让我们更接近“数学意义上的确定性程序”。


