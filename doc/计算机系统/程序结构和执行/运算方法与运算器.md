
---
tags: ['数值表示', '数值模型', '处理器架构', '数字逻辑电路', '体系结构']
---

# 运算方法与运算器

---

## 一、机器算术系统的本质

### 1.1 有限字长数值系统

计算机中的数不是数学实数，而是：

> **有限位模式（bit pattern）**

设字长为 n 位，则可表示状态数：

$$
2^n
$$

因此计算机数值空间本质为：

$$
\mathbb{Z}_{2^n}
$$

即：

**模 $2^n$ 整数环**

---

### 1.2 机器数的编码方式

编码的目标：

将数学整数映射为位模式。

#### 常见编码

| 编码 | 特点        | 运算特性   |
| -- | --------- | ------ |
| 原码 | 符号位 + 数值位 | 加减需分情况 |
| 反码 | 负数按位取反    | 存在双零   |
| 补码 | 模环表示      | 运算统一   |

---

### 1.3 补码的本质

补码定义：

$$
-x \equiv 2^n - x
$$

意义：

> 负数 = 模空间中的加法逆元

因此：

$$
X - Y = X + (-Y)
$$

计算机无需减法器。

---

### 1.4 机器算术统一原理

计算机整数运算本质：

$$
结果 = 真值 \bmod 2^n
$$

所有加减法统一为：

**模加法**

---

## 二、运算语义与位级行为

机器执行的是位操作，但对应数值意义。

---

### 2.1 移位运算的数值语义

#### 逻辑左移

位左移，低位补0：

$$
x \times 2
$$

（无符号）

---

#### 算术右移

最高位复制：

$$
\lfloor x / 2 \rfloor
$$

（保持符号）

---

### 2.2 进位与溢出

必须区分：

| 概念 | 含义     |
| -- | ------ |
| 进位 | 超出位宽   |
| 溢出 | 数值语义错误 |

---

#### 有符号溢出条件

同号相加结果异号。

---

#### 硬件检测

设：

* $C_{in}$：符号位进位
* $C_{out}$：最高位进位

则：

$$
Overflow = C_{in} \oplus C_{out}
$$

---

## 三、定点数基本运算

---

### 3.1 补码加法

$$
[X]_{补} + [Y]_{补}
= [X+Y]_{补} \bmod 2^n
$$

---

### 3.2 补码减法

$$
X - Y = X + (-Y)
$$

---

### 3.3 溢出检测实现（软件）

```c
int tadd_ok(int x, int y) {
    int sum = x + y;
    int neg_over = x < 0 && y < 0 && sum >= 0;
    int pos_over = x >= 0 && y >= 0 && sum < 0;
    return !(neg_over || pos_over);
}
```

---

## 四、乘法运算体系

乘法目标：

$$
P = X \times Y
$$

本质：

**部分积累加**

---

### 4.1 乘法算法分类

```
乘法算法
├ 串行乘法
│   ├ 原码乘法
│   ├ Booth乘法
│
├ 并行乘法
│   ├ 阵列乘法器
│   ├ Wallace tree
│
└ 高速乘法
```

---

### 4.2 原码一位乘法

核心思想：

逐位检查乘数：

* 位=1 → 加被乘数
* 位=0 → 不加
* 每轮移位

---

#### 符号处理

符号位独立：

$$
Sign = Sign_X \oplus Sign_Y
$$

---

#### 运算流程

```
部分积清零
重复 n 次：
    若乘数最低位=1 → 加被乘数
    右移
处理符号
```

---

### 4.3 补码一位乘法（Booth）

动机：

减少加法次数。

---

#### 核心思想

检测位对：

| 当前位     | 前一位 | 操作 |
| ------- | --- | -- |
| 01      | +X  |    |
| 10      | -X  |    |
| 00 / 11 | 不变  |    |

---

#### 每轮操作

1. 加 / 减
2. 算术右移

---

## 五、除法运算体系

目标：

$$
Q = X / Y
$$

本质：

**试商 + 修正**

---

### 5.1 算法分类

```
除法算法
├ 恢复除法
├ 不恢复除法
├ SRT除法
```

---

### 5.2 恢复除法

流程：

```
左移
减除数
若负 → 恢复 + 商0
否则 → 商1
```

---

### 5.3 不恢复除法

若上次为负：

→ 加除数

否则：

→ 减除数

避免恢复步骤。

---

## 六、运算器（ALU）体系结构

运算器 = 数据通路 + 控制通路

---

### 6.1 数据通路

```
寄存器组
加法器 / ALU
移位器
部分积寄存器
乘数寄存器
计数器
```

---

### 6.2 控制通路

控制：

* 何时加
* 何时移位
* 循环次数

实现：

有限状态机。

---

### 6.3 乘法器典型结构

```
        ┌─────────┐
X ─────→│ 被乘数寄存器 │
        └─────────┘
               ↓
        ┌─────────┐
        │   ALU   │
        └─────────┘
               ↓
        ┌─────────┐
        │ 部分积寄存器 │
        └─────────┘
               ↓
        移位器
```

---

## 七、微操作与执行过程

机器执行的不是算法，而是：

**微操作序列**

例：

```
A ← 0
repeat n:
    if Q0=1 → A ← A + X
    (A,Q) 算术右移
```

---

## 八、性能与实现权衡

| 设计维度  | 影响   |
| ----- | ---- |
| 位宽    | 延迟   |
| 并行度   | 面积   |
| 流水线   | 吞吐   |
| 算法复杂度 | 控制逻辑 |

---

## 九、运算器体系演进

```
串行加法器
→ 并行加法器
→ 乘法阵列
→ 流水线ALU
→ SIMD
→ 向量处理器
```

---

## 十、统一认知模型（核心）

计算机算术的本质链：

```
数值编码
→ 模运算语义
→ 位级操作
→ 运算算法
→ 微操作序列
→ 数据通路
→ 控制逻辑
→ 运算器
→ 处理器执行
```

---

## 十一、核心原理总结（最重要）

1. 机器数是模空间元素
2. 补码是加法逆元编码
3. 运算 = 模运算
4. 移位 = 乘除2
5. 乘法 = 部分积累加
6. 除法 = 试商修正
7. 运算器 = 数据流 + 控制流

---

## 十二、知识结构树

```
机器算术系统
├ 数值表示
│   ├ 原码
│   ├ 反码
│   └ 补码
│
├ 运算语义
│   ├ 模运算
│   ├ 移位语义
│   └ 溢出
│
├ 运算算法
│   ├ 加减
│   ├ 乘法
│   └ 除法
│
├ 运算器结构
│   ├ 数据通路
│   └ 控制通路
│
└ 工程实现
    ├ 微操作
    ├ 时序
    └ 性能
```

## 关联内容（自动生成）

- [/计算机系统/数字逻辑电路.md](/计算机系统/数字逻辑电路.md) 数字逻辑电路是运算方法与运算器的硬件基础，运算器由逻辑门、组合逻辑电路构成
- [/计算机系统/程序结构和执行/数据的表示.md](/计算机系统/程序结构和执行/数据的表示.md) 数据表示与运算方法密切相关，数值的编码方式直接影响运算实现
- [/计算机系统/程序结构和执行/处理器体系架构.md](/计算机系统/程序结构和执行/处理器体系架构.md) 处理器体系架构包含运算器的具体实现，是运算方法的物理载体
- [/计算机系统/程序结构和执行/指令系统.md](/计算机系统/程序结构和执行/指令系统.md) 指令系统定义了算术逻辑运算指令，与运算方法和运算器设计直接相关
- [/计算机系统/计算机系统.md](/计算机系统/计算机系统.md) 计算机系统概述了运算器作为状态变换功能单元的作用，与本文档内容相互补充
