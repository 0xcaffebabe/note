---
tags: ['微服务']
---
# 集成

## 理想的集成技术

- 避免破坏性修改
  - 一个服务的修改会导致服务的消费方也发生变化
- 保证API的技术无关性
  - 也就说，API不管使用什么技术，应该都能实现，保证通信方式的技术无关性是非常重要的，这样各个服务才有可能使用不同的技术实现
- 使服务易于消费方使用
- 隐藏内部实现细节
  - 如果消费方与服务的实现细节绑定在一起，会增加两者间的耦合

## 通信

### 交互方式

- 一对一与一对多
- 同步与异步

模式   | 一对一          | 一对多
---- | ------------ | -------------
同步模式 | 请求/响应        | 无
异步模式 | 异步请求/响应 单向通知 | 发布/订阅 发布/异步响应

#### 同步还是异步

同步通信，发起一个远程调用后，会阻塞自己并等待整个操作的完成

异步通信，则不需要等待操作结束就可以访问

使用哪种方式，要取决于哪种风格的通信解决的问题

### API定义

如何定义API取决于进程间通信机制。

随着应用演进，API也会随着演进。

- 次要且向后兼容的演进：增加可选属性、添加新操作等
- 主要且不向后兼容的演进：此时可以引入版本号

### 消息格式

- 基于文本消息格式：xml、json。好处在于可读性高、自描述。缺点在于消息过度冗长。
- 二进制消息格式：protocol buffers、avro。编译器根据定义的IDL生成序列化与反序列代码。好处性能高。

## 跨服务业务流程

有两种方式：编排与协同

编排是有一个控制中心，指导其他服务应该做些什么，具体怎么做，则交给具体服务

```
事件发生：
    控制中心调用服务A
    控制中心调用服务B
```

使用这种方式的缺点是会让控制中心承担太多的职责，并会导致少量的“上帝服务（上帝视角）”

若使用协同，则是可以客户触发一个事件，监听到这个事件的具体服务去做一些事情

```
事件发生：
    服务A接收到事件，做一些事
    服务B接收到事件，做一些事
```

这个方式的优点是能显著地消除耦合，但是缺点是无法看到清晰的业务流程，所以这种方式需要一定的监控手段来保证业务的正确性

### [断路器模式](/软件工程/微服务/服务治理/服务容错.md#断路器模式)

服务保护自己的方式：

- 网络超时：对某个服务的超时不能无限
- 限制客户端的请求数量
- 断路器模式

## 同步的编排方式

![屏幕截图 2021-01-19 105517](/assets/屏幕截图%202021-01-19%20105517.png)

### [远程过程调用](/计算机网络/rpc.md)

## 异步的协作方式

同步消息会降低可用性，为消除同步交互，可：

- 使用消息代理来进行异步交互
- 复制数据来避免与其他服务同步交互

异步协作的两种架构：

- 消息代理：需要一些中间件来实现异步协作，尽量让中间件保持简单
  - 耦合低
  - 更为灵活
  - **额外的复杂性**
- 无代理架构：直接向服务发送消息
  - 性能较高
  - 复杂性较低
  - **耦合过紧**

![屏幕截图 2021-01-19 142008](/assets/屏幕截图%202021-01-19%20142008.png)
![屏幕截图 2021-01-19 142721](/assets/屏幕截图%202021-01-19%20142721.png)

可实现的交互方式：

- 请求/响应模型
- 单向通知
- 发布订阅
- 发布/响应

### API规范

![屏幕截图 2021-01-19 142500](/assets/屏幕截图%202021-01-19%20142500.png)

异步操作：

- 请求/异步响应API
- 单向通知API

记录事件发布API

### 技术选择

- MQ
- 基于HTTP的发布订阅模式

### 异步架构复杂性

采用异步架构，要考虑的事情就更多了

- 并发与消息顺序
  - 在kafka中，使用了分片来解决顺序
- 重复消息
  - 应用程序需要自己进行幂等处理
- 事务性消息
  - 消息队列表与分布式事务

## 按引用访问

在进行事件通知时，传递的数据应该是指向资源的一个引用，这样当其他服务处理这个事件时，就可以根据这个引用得到最新的数据，而避免数据不一致的情况

## 服务即状态机

服务拥有在限界上下文中的所有逻辑，这样可以在唯一一个地方处理逻辑

## 响应式扩展

把多个调用的结果组装起来，并在此上做操作（类似于stream）

## 微服务中代码复用的危险

不同的服务复用同一块代码，一个服务修改的代码很可能影响另一个服务

## 版本管理

- 尽可能推迟修改

**宽进严出原则：对自己发送的东西要严格，对接收的东西可以宽容一点**

- 及早发现破坏性修改

- 使用语义化的版本管理
  - 通过版本号来告知消费方功能增加或是否向后兼容
- 多版本接口共存
- 多版本服务共存

## 用户界面

- 数字化
  - 未来的需求很难预测，提供细粒度的API
- 不同场景的约束
- API的组合
  - 使用网关来缓解客户端与服务之间的过多交互
- 服务直接提供UI片段

## [BFF](/软件工程/架构/系统设计/网关.md)

## 服务查询模式

### API组合模式

> 让拥有数据的服务的客户端调用服务，并组件服务返回的查询结果

![屏幕截图 2021-01-26 150338](/assets/屏幕截图%202021-01-26%20150338.png)

问题：

1. 选择谁为组合器
  - 客户端
  - 网关
  - 实现为独立的服务
2. 如何在组合器编写聚合逻辑

这种方式好处是简单直观。弊端：

- 带来了额外的开销
- 可用性有降低的风险
- 查询缺乏数据一致性

### CQRS模式

维护一个或者多个视图数据库，进而实现查询。

![屏幕截图 2021-01-26 154520](/assets/屏幕截图%202021-01-26%20154520.png)

好处与弊端：

- 高效实现多个服务的多种类型查询
- 支持[事件溯源](/软件工程/微服务/业务逻辑.md#事件溯源)技术
- 隔离了问题：领域模型不必同时处理命令和查询

- **架构更加复杂**
- **数据有一定的延迟**

#### CQRS视图设计

- 选择合适的数据库
  - SQL or NoSQL
- 数据访问模块
  - 并发处理
  - 幂等处理
- 更新视图
  - 归档
  - 快照
