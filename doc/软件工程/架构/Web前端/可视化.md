# 可视化

> 将数据组织成易于为人所理解和认知的结构，然后用图形的方式形象地呈现出来的理论、方法和技术

Web 开发的前端主要还是关注内容和样式，图形的渲染和绘制是由浏览器底层来完成的，而可视化前端则可能要深入底层渲染层，去真正地控制图形的绘制和细节的呈现

## 图形基础

### 通用图形系统

数据经过 CPU 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 GPU 中进行处理。在 GPU 中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓存中，最后渲染到屏幕上

```mermaid
stateDiagram-v2
  输入设备 --> CPU
  CPU --> GPU
  存储器 --> CPU
  存储器 --> GPU
  GPU --> 帧缓存
  帧缓存 --> 输出设备
```

- 光栅：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列
- 帧缓存：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息

### HTML+CSS

可以实现一些简单的柱状图、饼图，但据与图形的对应关系不直观，同时由于浏览器对HTML以及CSS的渲染机制，会导致渲染开销比较大

### SVG

声明式绘图系统，只不过是将 HTML 标签替换成 SVG 标签，运用了一些 SVG 支持的特殊属性，HTML+CSS有的缺点它也有，但SVG 则弥补了HTML+CSS不规则图形绘制方面的不足，让不规则图形的绘制变得更简单了

创建SVG 元素要使用 document.createElementNS 方法：

```js
document.createElementNS('http://www.w3.org/2000/svg', 'circle')
```

```html
<!-- 画个黑边的黄圈 -->
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="orange" />
</svg>
```

同时由于是html标签，添加事件相比canvas更方便，可以直接使用dom操作，同时SVG绘制的是矢量图形，这点也比canvas更有优势


### Canvas

指令式绘图系统，能够直接操作绘图上下文，比HTML和SVG快,简单易操作和高效的渲染能力是它的优势，但是它的缺点是不能方便地控制它内部的图形元素

```html
<canvas width="512" height="512"></canvas>
```
```css
canvas {
  width: 256px;
  height: 256px;
}
```
```js
// 获取上下文
const canvas = document.querySelector('canvas');
const context = canvas.getContext('2d');

// 绘制一个正方形
const rectSize = [100, 100];
context.fillStyle = 'black';
context.beginPath();
context.rect(0.5 * canvas.width, 0.5 * canvas.height, ...rectSize);
context.fill();
```

#### WebGL

在要绘制的图形数量非常多、对较大图像的细节做像素处理、绘制3D物体，相比Canvas2D有较大的性能优势

WebGL 绘制一个图形的过程，一般需要用到两段着色器，一段叫顶点着色器（Vertex Shader）负责处理图形的顶点信息，另一段叫片元着色器（Fragment Shader）负责处理图形的像素信息，WebGL 可以并行地对整个三角形的所有像素点同时运行片元着色器

```js

const canvas = document.getElementById('canvas-gl');
const gl = canvas.getContext('webgl');

// 顶点着色器
const vertex = `
  attribute vec2 position;

  void main() {
    gl_PointSize = 1.0;
    gl_Position = vec4(position, 1.0, 1.0);
  }
`;

// 片元着色器
const fragment = `
  precision mediump float;

  void main()
  {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }    
`;

// 将着色器代码分别创建成 shader 对象
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vertex);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fragment);
gl.compileShader(fragmentShader);

// 一些配置
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// 定义三角形的三个顶点
const points = new Float32Array([
  -1, -1,
  0, 1,
  1, -1,
]);

// 定义好的数据写入 WebGL 的缓冲区
const bufferId = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);


const vPosition = gl.getAttribLocation(program, 'position'); //获取顶点着色器中的position变量的地址
gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0); //给变量设置长度和类型
gl.enableVertexAttribArray(vPosition); //激活这个变量

// 清除画布然后绘画
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.TRIANGLES, 0, points.length / 2);
```

## 数学

### 向量和坐标系

- HTML 采用的是窗口坐标系，以参考对象（最接近图形元素的 position 非 static 的元素），左上角为坐标原点，x 轴向右，y 轴向下，坐标值对应像素值
- SVG 采用的是视区盒子（viewBox）坐标系，以 svg 根元素左上角为坐标原点，x 轴向右，y 轴向下
- Canvas 采用的坐标，默认以画布左上角为坐标原点，右下角坐标值为 Canvas 的画布宽高值
- WebGL 的坐标系，是一个三维坐标系。它默认以画布正中间为坐标原点，x 轴朝右，y 轴朝上，z 轴朝外

坐标系变换：在canvas中可以通过transfrom改变原点来变换坐标系，不仅可以简化顶点的计算、同时也能优化计算量

可以用二维向量来表示一个平面上的点和线段：

- 点：(x,y)
- 线段：(0,0) ~ (x,y)

向量运算：

- 相加：v1(x1,y1) + v2(x2,y2) = 在平面上得到一个新的点（x1 + x2, y1 + y2），一条新的线段[(0, 0), (x1 + x2, y1 + y2)]，以及一段折线：[(0, 0), (x1, y1) , (x1 + x2, y1 + y2)]

个向量包含有长度和方向信息：

- 长度可以用向量的 x、y 的平方和的平方根来表示
- 方向可以用与 x 轴的夹角来表示

如果我们希望以点 (x0, y0) 为起点，沿着某个方向画一段长度为 length 的线段：

$$v_1^→ = length * v^→ (cos(与x轴夹角),sin(与x轴夹角))$$

### 向量乘法

点乘：几何含义是 a 向量乘以 b 向量在 a 向量上的投影分量。物理含义相当于 a 力作用于物体，产生 b 位移所做的功

![20221230141737](/assets/20221230141737.webp)

叉乘：几何意义就是向量 a、b 组成的平行四边形的面积，物理意义就是 a 和 b 的力矩

![20221230142132](/assets/20221230142132.webp)

### 描述曲线

#### 参数方程

通过公式描述出曲线的各个点，最后再连接各个点

- 圆

$$
x = x_0 + rcos(θ)\\
y = y_0 + rsin(θ)\\
$$

```js

const TAU_SEGMENTS = 60;
const TAU = Math.PI * 2;
function arc(x0, y0, radius, startAng = 0, endAng = Math.PI * 2) {
  const ang = Math.min(TAU, endAng - startAng);
  const ret = ang === TAU ? [] : [[x0, y0]];
  const segments = Math.round(TAU_SEGMENTS * ang / TAU);
  for(let i = 0; i <= segments; i++) {
    const x = x0 + radius * Math.cos(startAng + ang * i / segments);
    const y = y0 + radius * Math.sin(startAng + ang * i / segments);
    ret.push([x, y]);
  }
  return ret;
}

// 圆心为[100,100]半径为100的圆
const points = arc(100, 100, 100);

for(let i = 1; i < points.length; i++) {
  context.beginPath();
	context.moveTo(points[i-1][0], points[i-1][1]);
	context.lineTo(points[i][0], points[i][1]);
	context.stroke();
	context.closePath();  
}

```

- 圆锥曲线

圆是特殊的椭圆

$$
椭圆\\
x = x_0 + rcos(θ)\\
y = y_0 + rsin(θ)\\
抛物线\\
x = x_0 + 2pt^2\\
y = y_0 + 2pt^2
$$

```js
const LINE_SEGMENTS = 60;
function parabola(x0, y0, p, min, max) {
  const ret = [];
  for(let i = 0; i <= LINE_SEGMENTS; i++) {
    const s = i / 60;
    const t = min * (1 - s) + max * s;
    const x = x0 + 2 * p * t ** 2;
    const y = y0 + 2 * p * t;
    ret.push([x, y]);
  }
  return ret;
}
```

- 贝塞尔曲线

通过起点、终点和少量控制点，就能定义参数方程来生成复杂的平滑曲线，所以它通常被用来构建数据信息之间连接线

![二阶贝塞尔曲线](/assets/20221230145456.webp)

$$B_t = {(1 - t)}^3 + 3{(1-t)}^2tP_1 + 3{(1-t)}^2p_2 + t^3P_3$$

p0 p1 p2 p3 是向量，t是参数

![三阶贝塞尔曲线](/assets/202212301531.gif)

控制点越多，曲线能够模拟出更多不同的形状，也能更精确地控制细节

### 多边形描述处理

WebGL 填充多边形的第一步，就是将多边形分割成多个三角形，叫做三角剖分，针对 3D 模型，WebGL 在绘制的时候，也需要使用三角剖分，而 3D 的三角剖分又被称为网格化，3D 渲染的时候，我们一般使用的模型数据都是已经经过三角剖分以后的顶点数据

![20221230153141](/assets/20221230153141.webp)

一些库：

- Earcut
- Tess2.js
- cdt2d

判断鼠标是否在多边形内：

先简化为判断三角形内

当点 u 在三角形 a、b、c 内时，因为 u1到 a、u2到 b、u3到 c 的小角旋转方向是相同的（这里都为顺时针），所以 u1 X a、u2 X b、u3 X c 要么同正，要么同负。当点 v 在三角形外时，v1到 a 方向是顺时针，v2到 b 方向是逆时针，v3到 c 方向又是顺时针，所以它们叉乘的结果符号并不相同

加上

判定点恰好在三角形某条边上的情况

判断多边形，要先对多边形做三角剖分，判断该点是否在其中一个三角形内部

### 仿射变换

- 仿射变换前是直线段的，仿射变换后依然是直线段
- 对两条直线段 a 和 b 应用同样的仿射变换，变换前后线段长度比例保持不变

向量的平移、旋转、缩放：

$$
平移\\
x = x_0 + x_1\\
y = y_0 + y_1\\
旋转\\
x = x_0cosθ - y_0sinθ\\
y = x_0cosθ + y_0sinθ\\
缩放\\
x = s_xx_0\\
Y = s_yy_0\\
$$

旋转和缩放都可以写成矩阵与向量相乘的形式。这种能写成矩阵与向量相乘形式的变换，就叫做线性变换：

- 线性变换不改变坐标原点（因为如果 x0、y0等于零，那么 x、y 肯定等于 0）
- 线性变换可以叠加，多个线性变换的叠加结果就是将线性变换的矩阵依次相乘，再与原始向量相乘

通用的线性变换公式，一个原始向量 P0经过 M1、M2、…Mn 次的线性变换之后得到最终的坐标 P：

$$P = M_1 * M_2  * ... M_n * P_0$$

仿射变换的一般表达式，线性变换 + 平移：

$$P = M * P_0 + P_1$$

## 视觉

### [颜色表示](/音视频开发/音视频开发.md#色彩格式)

- RGB和RGBA：在对比两个 RGB 颜色的时候，只能通过对比它们在 RGB 立方体中的相对距离，来判断它们的颜色差异
- HSL和HSV：可以均匀地修改每组颜色的亮度和饱和度，但这样修改之后，有的颜色看起来和其他的颜色差距明显，有的颜色还是没那么明显
- CIE Lab 和 CIE Lch：用 L 表示亮度，a 和 b 表示颜色对立度，Lch是将坐标从立方体的直角坐标系变换为圆柱体的极坐标系
- Cubehelix 色盘：原理就是在 RGB 的立方中构建一段螺旋线，让色相随着亮度增加螺旋变换

![Cubehelix色盘的原理](/assets/202313173249.webp)

当希望连续变化的数据能够呈现连续的颜色变换时，就很难用预先指定的有限的颜色来表达，就需要使用其他的方式，结合数据变量来动态生成颜色值

### 图案生成

1. 重复图案：使用 CSS 的 background-image 属性,利用 backgroud-repeat
2. 分形

$$
Z_{n+1} = {Z(_n)}^2+C
$$

3. 随机：使用随机数生成器来生成颜色

### 滤镜

1. 灰度化：将图片的每个像素点的 R、G、B 通道的值进行加权平均转换

$$
V = aR + bG + cB\\
R' = G' = B' = V\\
(a + b + c) = 1
$$

2. 像素矩阵

一个 4*5 颜色矩阵，让它的第一行决定红色通道，第二行决定绿色通道，第三行决定蓝色通道，第四行决定 Alpha 通道：

如果要改变一个像素的颜色效果，只需要将该矩阵与像素的颜色向量相乘：

![2023141822](/assets/2023141822.webp)

3. 高斯模糊

按照高斯分布的权重，对当前像素点及其周围像素点的颜色按照高斯分布的权重加权平均

![20231418539](/assets/20231418539.webp)

二维高斯公式

$$
G(x,y) = {\frac{1}{2πσ^2}e}^{-(x^2+y^2)/2σ^2}
$$

![20231418550](/assets/20231418550.webp)

4. 边缘模糊：在遍历像素点的时候，同时计算当前像素点到图片中心点的距离，然后根据距离设置透明度
5. 叠加：通过对两张图片进行像素叠加

### 极坐标绘图

有些曲线只能用极坐标来表示，但最终渲染的时候，还是需要转换成图形系统默认支持的直角坐标才可以进行绘制

```js
// 直角坐标影射为极坐标
function toPolar(x, y) {
  const r = Math.hypot(x, y);
  const θ= Math.atan2(y, x);
  return [r, θ];
}

// 极坐标映射为直角坐标
function fromPolar(r, θ) {
  const x = r * cos(θ);
  const y = r * sin(θ);
  return [x, y];
}
```

将极坐标系延 z 轴扩展，可以得到圆柱坐标系

![20231516315](/assets/20231516315.webp)

直角坐标系转圆柱坐标系：

$$
ρ = \sqrt{x^2+y^2}\\
φ = arctan(\frac{y}{x})\\
z=z
$$

圆角坐标系转直角坐标系：

$$
x = ρ cos(φ)\\
y = ρ sin(φ)\\
z=z
$$

### 程序化纹理生成

```c
// 离散随机二维噪点
float random (vec2 st) {
    return fract(sin(dot(st.xy,
        vec2(12.9898,78.233)))*
        43758.5453123);
}
```

如果对离散的随机点进行插值，可以让每个点之间的值连续过渡。因此，我们用 smoothstep 或者用平滑的三次样条来插值，就可以形成一条连续平滑的随机曲线：

1. 一维噪声函数

![202315174745](/assets/202315174745.webp)

![202315174851](/assets/202315174851.webp)

2. 二维噪声函数：对平面画布上方形区域的四个顶点，分别从 x、y 方向进行两次插值

![202315175020](/assets/202315175020.webp)

梯度噪声：梯度不均匀最直观的表现就是，二维噪声图像有明显的“块状”特点，不够平滑，梯度噪声是对随机的二维向量来插值，而不是一维的随机数

Simplex Noise：是对三角网格进行插值
