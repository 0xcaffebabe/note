# 可视化

> 将数据组织成易于为人所理解和认知的结构，然后用图形的方式形象地呈现出来的理论、方法和技术

Web 开发的前端主要还是关注内容和样式，图形的渲染和绘制是由浏览器底层来完成的，而可视化前端则可能要深入底层渲染层，去真正地控制图形的绘制和细节的呈现

## 图形基础

### HTML+CSS

可以实现一些简单的柱状图、饼图，但据与图形的对应关系不直观，同时由于浏览器对HTML以及CSS的渲染机制，会导致渲染开销比较大

### SVG

声明式绘图系统，只不过是将 HTML 标签替换成 SVG 标签，运用了一些 SVG 支持的特殊属性，HTML+CSS有的缺点它也有，但SVG 则弥补了HTML+CSS不规则图形绘制方面的不足，让不规则图形的绘制变得更简单了

创建SVG 元素要使用 document.createElementNS 方法：

```js
document.createElementNS('http://www.w3.org/2000/svg', 'circle')
```

```html
<!-- 画个黑边的黄圈 -->
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="orange" />
</svg>
```

同时由于是html标签，添加事件相比canvas更方便，可以直接使用dom操作，同时SVG绘制的是矢量图形，这点也比canvas更有优势


### Canvas

指令式绘图系统，能够直接操作绘图上下文，比HTML和SVG快,简单易操作和高效的渲染能力是它的优势，但是它的缺点是不能方便地控制它内部的图形元素

```html
<canvas width="512" height="512"></canvas>
```
```css
canvas {
  width: 256px;
  height: 256px;
}
```
```js
// 获取上下文
const canvas = document.querySelector('canvas');
const context = canvas.getContext('2d');

// 绘制一个正方形
const rectSize = [100, 100];
context.fillStyle = 'black';
context.beginPath();
context.rect(0.5 * canvas.width, 0.5 * canvas.height, ...rectSize);
context.fill();
```

#### WebGL

在要绘制的图形数量非常多、对较大图像的细节做像素处理、绘制3D物体，相比Canvas2D有较大的性能优势
