# 可观测性

![监控的三种维度方式](/assets/20201125142726.png)
![监控的三种维度方式](/assets/批注%202020-06-21%20084850.png)
![各维度技术栈](/assets/批注%202020-04-13%20160526.png)

- 日志：记录离散事件，通过这些记录事后分析出程序的行为
- 追踪：单体的调用栈追踪或者服务调用之间的分布式追踪
- 度量：度量是指对系统中某一类信息的统计聚合

日志收集：与具体技术栈无关 ELK EFK

度量：Prometheus

链路追踪：Zipkin...

## 日志

![20201125143743](/assets/20201125143743.jpg)

### 日志中有用的信息

- 时间
- 标识
  - 系统标识
  - 用户标识
  - 事件标识...
- 来源
- 日志级别

### 输出

输出的日志应该是什么样的：

- 避免敏感信息
- 避免引用到慢操作信息
- 避免输出的信息有误导性

- 记录TraceID 没有TraceID就要自动生成来对请求进行标记
- 记录系统运行时的关键事件

### 收集&缓冲

- Logstash
- Beats

为了缓解收集大量日志的压力 可以在收集器之前假设Kafka或者Redis作为缓冲层 面对突发流量

### 加工&聚合

- 将非结构化数据转为结构化数据

### 存储&查询

ES是这方面唯一的选择

日志有如下性质：

1. 写入后基本无需修改
2. 分为冷热数据 更早的日志价值更低
3. 日志可离线查询与实时查询

## 链路追踪

目标：排查故障 分析性能数据 监控服务间的行为

- trace与span

![2020112514590](/assets/2020112514590.png)

链路追踪的挑战：

1. 异构技术
2. 对性能敏感
3. 对应用透明
4. 自动扩缩容
5. 持续的监控

### 数据收集

- 基于日志信息的追踪：将Trace、Span等信息直接输出到应用日志中，然后随着所有节点的日志归集过程汇聚到一起，再从全局日志信息中反推出完整的调用链拓扑关系
- 基于服务的追踪：通过代码注入的方式可以得到方法调用栈等信息 并且需要通过独立的网络调用上报信息 需要消耗更多的资源
- 基于sidecar代理的方式：这种方式对应用透明 但它只能实现服务调用层面的追踪

### 追踪规范化

OpenTracing -> OpenCensus -> OpenTelemetry

## 聚合度量

### 指标收集

指标数据类型

- 计数度量器（Counter）：对有相同量纲、可加减数值的合计量
- 瞬态度量器（Gauge）：表示某个指标在某个时点的数值
- 吞吐率度量器（Meter）：单位时间内某个事件的发生次数
- 直方图度量器（Histogram）
- 采样点分位图度量器（Quantile Summary）

指标采集方式

- push
- pull

指标传输协议：

- OpenMetrics

健康检查API模式：

![屏幕截图 2021-01-29 094428](/assets/屏幕截图%202021-01-29%20094428.png)

### Prometheus

![架构](/assets/批注%202020-04-22%20150857.png)

### 存储查询

如果使用传统的关系型数据库存储度量数据 那每天监控数据的产生量将会非常的大

大部分度量数据都可以使用专门的时序数据库来进行存储

由于度量数据多写少读、几乎不删改、数据只顺序追加这些特点，时序数据库就可以使用某些策略来进行优化：

1. 日志结构的合并树
2. 对数据进行采样进行节省空间 比如几周前的数据就只保留一天 几年前的就保留一周
3. 轮替数据存储 类似于环形缓冲区 输入可以无限 存储有限

### 监控预警

- Grafana
- Alter Manager
