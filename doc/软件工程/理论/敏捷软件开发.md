# 敏捷软件开发

>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。

应对模糊需求、快速变化需求的最佳方法

## 敏捷联盟

- 个体交互 胜过 过程和工具

项目的关键因素是人 但是一个好过程并不能帮助项目成功

- 可以工作的软件 胜过 面面俱到的文档

过多的文档比过少的文档更糟

- 客户合作 胜过 合同谈判

成功的项目需要有序频繁的客户反馈

- 响应变化 胜过 遵循计划

对于下两周 做好详细的计划

为下三个月做好粗略的计划

三个月以后的事 就做极为粗糙的计划

## 原则

- 尽早交付
- 欢迎需求变更
- 交付间隔越短越好
- 客户与开发团队一起工作
- 重视人的因素
- 使用可以工作的软件衡量工作进度
- 提倡恒定的开发速度
- 简单就好
- 自组织的团队
- 不断反省 调整自身

## 方法

- 极限编程
- scrum
- kanban

## 极限编程

### 实践原则

- 客户作为团队成员
- 用户故事
- 短交付周期
  - 迭代
  - 发布
- 验收测试
- 结对编程
  - 减少缺陷率
  - 促进知识传播
- 测试驱动开发
- 集体所有权
- 持续集成
- 可持续的开发速度
- 开放的工作空间
- 计划游戏
- 简单设计
- 重构
- 隐喻

## 测试

单元测试

- 验证操作的正确性
- 站在调用者的角度
- 促使解耦

验收测试

针对每个特性编写测试脚本

## 敏捷设计

拙劣设计的症状

- 僵化性
  -  设计难以改变
- 脆弱性
  - 设计容易被破坏
- 牢固性
  - 设计难以重用
- 粘滞性
  - 难以做正确的事
- 不必要的复杂性
  - 过分设计
- 不必要的复制
- 晦涩性
  - 表达令人混乱

敏捷设计致力于保持系统设计在任何时间都尽可能简单 干净 富有表现力

## 设计模式

- SOLID原则

### COMMAND 模式

```java
interface Command{
  do();
  undo();
}
```

### ACTIVE OBJECT 模式

```java
while(commandListNotEmpty){
  getCommandAndExecute();
}
```

### MONSTATE 模式

通过封装来使整个系统的某个对象以单一的形式展示

- 无需对外暴露其本身性质

### NULL OBJECT 模式

使用一个空对象来代替空指针

## Scrum模型

- 迭代式增量软件开发过程

### Sprint

- 迭代周期

### 角色

- 产品负责人
  - 负责建立与维护产品特性
  - 有决策权
  - 了解工作流程及技术水平
- 教练
  - 确保更快交付
  - 服务于团队 确保团队朝着目标冲刺
- 团队
  - 稳定的 团员自组织 平等

### 活动

- 冲刺规划会议
  - 确立目标、任务
- 每日站会 10分钟搞定！！！
  - 昨天做了什么 今天准备做什么 遇到了什么困难
- 冲刺复审会议
  - 演示功能 产品负责人验收功能
- 冲刺回顾会议

### 工件

- 产品待办列表
  - 唯一的需求来源
- 冲刺待办列表
  - 当前迭代周期的目标计划
- 产品增量
  - 当前迭代周期迭代完成的需求总和

## kanban

渐进增量式过程改进方法学

- 可视化工作流
- 限制进行中的工作

物理看板（信息辐射强）

![批注 2020-05-05 135610](/assets/批注%202020-05-05%20135610.png)

**使用**

列非固定的，随时间空间变化而变化
可以根据此看到工作状态与潜在问题

记事贴写什么？

- 工作描述·
- 电子系统唯一标识
- 完成期限
- 负责人
- 工作类型

保证工作项的粒度粗细差别不大

降低前置时间（任务从开始到结束的时间）是一个追求目标

需要限制每列中的卡片

