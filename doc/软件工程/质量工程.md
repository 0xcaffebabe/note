# 质量工程

符合需求即质量

预防产生质量 检验不能产生质量

质量是相对的，不能脱离具体的人谈软件质量

## 为什么要

- 快速变化的世界
- 愈发复杂的软件
- 团队扩大 成员流动快

## 做什么

- 高质量架构 小步快跑 全链路持续交付
- 全方面质量管理 故障管理
- 质量规范 流程
- 知识沉淀与传承

## 质量思维

### 高可用性

- 在SLA预设下考虑系统的建设

### 架构师立场

架构师决定着架构的基因

#### 质量经济学

- 要与不要 是个问题
  - 新增功能可以带来收益吗
- 成本与收益

#### 质量满意度

- 客户与老板的满意

#### 适用的架构

### 正负反馈

反馈环中的因果循环，有的破坏是不可逆的（方向问题）

小步试错，积极调整 建立小正循环，推动正反馈

项目新增输入导致熵增，需要加以控制，控制住熵的增长，为控制系统性偏差，要建立起反馈的可能性，通过细微的、及时的反馈来达到控制的目的

架构师需要基于当前的信息做出决策，并将决策得到的结果作为前一步的信息继续做出决策，每次的调整都是为了修正熵回到正常状态

### 止损

- 理清现状
- 盘点数据
- 价值分析

#### 派别

- 保守治疗
- 刮骨疗伤

#### 断臂求生

#### 告别

## 度量体系

- 用数据证明质量的进步

```mermaid
stateDiagram-v2
  度量诉求 --> 度量场景
  度量场景 --> 指标体系
  指标体系 --> 研发质量
  指标体系 --> 人员成长
  研发质量 --> 项目管理
  项目管理 --> 人员成长
```

### 需求管理

```mermaid
stateDiagram-v2
  需求数量 --> 需求到人
  需求数量 --> 需求完成周期
  需求完成周期 --> 对事评估
  需求到人 --> 人员需求周期
  人员需求周期 --> 对人评估
  需求到人 --> 需求大盘
  需求大盘 --> 需求完成情况
  需求完成情况 --> 综合评估
```

#### 需求的全生命周期

```mermaid
stateDiagram-v2
  需求规划 --> 优先级管理
  需求执行 --> 进度管理
  需求跟进 --> 转化管理

  需求规划 --> 需求执行
  需求执行 --> 需求跟进

  优先级管理 --> 资源利用率
  优先级管理 --> 业务支撑结果

  进度管理 --> 延期管理
  进度管理 --> 提前完成

  转化管理 --> 价值复盘
  转化管理 --> 试错方向的调整
```

#### 需求复盘

合理性：

- 设计合理性
- 资源消耗合理性
- 优先级合理性

完成度：

- 整体完成度
- 完成周期、延期情况
- 需求是否偏差

价值：

- 带来的效果
- 实际产生的价值
- 投入产出比

#### 问题治理

需求质量：设立准入门槛

实现质量：专项治理

流程问题：改进流程

人的问题：定向培养

### 缺陷管理

```mermaid
stateDiagram-v2
  state 缺陷管理 {
    改进开发过程 --> 提高产品质量
    提高产品质量 --> 改进开发过程
  }
  缺陷度量 --> 缺陷分布
  缺陷度量 --> 缺陷密度
  缺陷度量 --> 缺陷趋势
  缺陷度量 --> 漏测率
  缺陷度量 --> 缺陷管理
```

缺陷分布：各类缺陷数目

缺陷密度：已知缺陷数量/产品规模 千行代码缺陷率

```mermaid
stateDiagram-v2
  state if_state <<choice>>
  [*] --> 当前版本密度≤上一版本密度
  当前版本密度≤上一版本密度 --> if_state
  if_state --> 增加测试投入，加强研发管控: 是
  if_state --> 质量在进步 : 否
```

缺陷趋势：各种状态缺陷的数量

漏测率：非QA测试缺陷数/QA发现的缺陷数

#### 缺陷状态

```mermaid
stateDiagram-v2
  激活 --> 不修
  激活 --> 设计如此
  激活 --> 分配
  分配 --> 修复
  修复 --> 重开
  重开 --> 分配
  分配 --> 稍后
  稍后 --> 修复
  修复 --> 关闭
```

### 代码跟踪

人：提交人、评审人

量：提交量、注释量

质量：复杂度、不合规范数、单测覆盖率

### 发布跟踪

#### 发布度量

发布次数、发布成功率、回滚次数、灰度接入率、灰度回滚次数、紧急发布次数、非发布变更次数

可以反馈出因研发质量不足而导致的异常流程数

#### 准入度量

接入率、卡点阻塞数、跳过数

限制风险因素发布到生产

## 持续交付

- 尽早发现问题解决问题

单测是第一道防线

快速（自动化）、迭代（版本控制）、持续（[DevOps](/软件工程/DevOps.md)）

构建自动化、测试自动化、流程编排、持续继承、部署自动化

### 版本控制

需求任务关联、版本开发规范、语义化版本

开发代码版本：多人多版本

持续交付版本：存于仓库的唯一版本

线上版本

二方版本：提供给其他依赖方的版本

多版本开发：

```mermaid
stateDiagram-v2
  Git多版本控制 --> 提交日志
  Git多版本控制 --> 多分支开发
  多分支开发 --> 主干开发
  多分支开发 --> 分支开发
  分支开发 --> 按发布创建分支
  分支开发 --> 按功能特性创建分支
  变更 --> 按发布创建分支
```

### 需求周期

```mermaid
stateDiagram-v2
  新建 --> 评审
  评审 --> 开发
  state 持续交付关注部分 {
    开发 --> 测试
    测试 --> 待发布
    待发布 --> 灰度
    灰度 --> 上线
  }
  上线 --> 验收
```

为了缩短交付周期，可以使用流水线，一个需求完了之后就可以丢到交付流水线

交付过程的单一迭代时间、交付的质量、流程的科学性及需求本身的质量都会影响需求能不能快速进入开发状态

### 交付质量

```mermaid
stateDiagram-v2
  过程稳定 --> 交付质量流程
  交付质量流程 --> 交付卡点
  交付卡点 --> 过程稳定
```

#### 质量红线

偏离：

- 实现偏离
- 验收不重复

故障：

- 代码问题
- 数据问题
- 配置问题
- 环境问题

### 开发模式

#### 主干开发模式

基于主干开发，基于分支发布，使用功能开关来保证功能切换

#### gitlab flow开发模式

新分支基于主干，不同环境不同分支，发布合并到主干

#### 分支开发模式

基于分支开发，分支合并主干，feature基于分支

#### 持续交付开发模式

```mermaid
stateDiagram-v2
  state MASTER {
    [*] --> master_commit0
    master_commit0 --> master_commit1
    master_commit1 --> master_commit2
    master_commit2 --> [*]
  }
  master_commit0 --> pre_commit0
  master_commit1 --> pre_commit1
  state PRE-PRODUCTION {
    [*] --> pre_commit0
    pre_commit0 --> pre_commit1
    pre_commit1 --> [*]
  }
  pre_commit0 --> pro_commit0
  state PRODUCTION {
    [*] --> pro_commit0
    pro_commit0 --> [*]
  }
```

```mermaid
stateDiagram-v2
  state MASTER {
    [*] --> master_commit0
    master_commit0 --> master_commit1
    master_commit1 --> master_commit2
    master_commit2 --> master_commit3
    master_commit3 --> master_commit4
    master_commit4 --> [*]
  }
  master_commit0 --> 2_3_commit0
  master_commit2 --> 2_3_commit1: fix xxx
  state 2-3-STABLE {
    [*] --> 2_3_commit0
    2_3_commit0 --> 2_3_commit1
    2_3_commit1 --> [*]
  }
  master_commit3 --> 2_4_commit0
  state 2-4-STABLE {
    [*] --> 2_4_commit0
    2_4_commit0 --> [*]
  }
```

### 变更发布

自动触发部署：测试环境、内部环境

手动触发：正式环境、完成流程化审批

发布人员：

需求方 -> 开发方 -> 执行人 -> 验收方

度量：

发布跟踪里的发布度量

## 灰度发布

- 验证性灰度

```mermaid
stateDiagram-v2
  灰度策略 --> 用户群体
  用户群体 --> 灰度系统
  灰度系统 --> 功能验证
  功能验证 --> 阶段移动
  功能验证 --> 回滚
  阶段移动 --> 用户群体
```

- 探索性灰度

```mermaid
stateDiagram-v2
  灰度策略 --> 用户群体
  用户群体 --> 差异化安装
  差异化安装 --> 对比验证效果
  对比验证效果 --> 出现问题
  出现问题 --> 回滚
  对比验证效果 --> 确认功能
  确认功能 --> 调整策略
  调整策略 --> 灰度策略
```

### 用户标识管理

- [用户群体](/软件工程/安全生产.md#用户群体)
- 用户数量
  - 针对特定群体特定数量的用户
  - 无差别灰度 比较简单

### 灰度策略

灰度的持续时间要保证采集到足够的数据

灰度覆盖的范围要确定能覆盖变更的情况

灰度的异常是否要修复，修复要马上回滚

```mermaid
stateDiagram-v2
  灰度目标 --> 用户群体
  用户群体 --> Cookie设定特定标识
  Cookie设定特定标识 --> 请求路由
  请求路由 --> 版本A
  请求路由 --> 版本B
  版本A --> 数据对比
  版本B --> 数据对比
  数据对比 --> 预期判定

  预期判定 --> 流量调整
  state 流量灰度 {
    流量调整 --> 流量验证: 验证结果
  }
  流量验证 --> 回滚: 严重偏离/异常
  流量验证 --> 全量发布: 灰度完成

  预期判定 --> 人群验证
  state 人群灰度 {
    人群验证 --> 人群调整: 扩大人群验证
  }
  人群验证 --> 回滚: 严重偏离/异常
  人群调整 --> 用户群体
  人群调整 --> 全量发布
```

- 商业策略
- 功能体验
- 新版发布
- 定向发布
- AB测试
- 高危试错

### 场景

- 应用灰度
- 链路灰度
- 前端灰度

### [灰度度量](/软件工程/安全生产.md#灰度度量)

### 发布执行

灰度平台：

### 流量分级

- 小流量验证 避免大规模损失
  - 灰度平台自动拆分批次
- 细粒度灰度支持
  - 影响最小化
  - 与业务集合
  - 账户指向灰度 方便验证
  - 开关灰度 瞬时切换 快速回滚

### 回滚策略

灰度的过程中每个阶段都有可能导致异常发生 首先要执行回滚，然后再排查原因

针对高位预警，需要进行场景化梳理，在日志里埋点，进行定向监控后预警

#### 异常分级

- 一级：导致故障的重点异常 出现较多需要回滚
- 二级：导致系统不太健康或者出现奇怪行为的异常 大规模出现时需要回滚
- 三级：不会进行恶化的异常 持续关注 无需回滚

### 总结与复盘

全面梳理灰度用户使用情况信息

针对整个过程进行分析、总结、完善

整个灰度是否达到了降低风险、减少bug带来的影响

针对发布的过程，思考灰度流程是否有优化的空间

结果是否符合预期，复盘偏离的原因，如何避免偏离

灰度发布后续计划，什么人做什么事

灰度过程后沉淀下的经验，帮助其他的项目以及后续的发布

## 质量管理体系

```mermaid
stateDiagram-v2
  工程效率 --> 质量控制
  质量控制 --> 工程规范
  工程规范 --> 工程效率
```

### 质量控制

- 执行：过程管理
- 人：人员培训
- 规范：规范优化

### 质量升级

代码质量 -> 服务质量

功能测试 -> 快速恢复

线下质量 -> 线上质量

模块质量 -> 链路质量

### 质量具化

定义质量场景，做好质量控制：

- 场景主体
- 场景任务
- 场景环境
- 创建变化

### 研发流程与灰度发布

```mermaid
stateDiagram-v2
  需求实现 --> 变更
  问题修复 --> 变更
  变更 --> 准入
  准入 --> 发布
  发布 --> 灰度
  灰度 --> 生产
```

### 安全生产体系

### 全链路质量体系

- 全链路压测
