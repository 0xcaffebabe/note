---
tags: ['软件工程', '软件设计']
---

# 软件设计

- 战术编程：赶紧完成需求 能跑就行
- 战略编程：预先做好良好的设计

## 复杂性

越复杂的系统，就越难理解和修改它

复杂性是一点一点积累起来的

### 症状

- 变更放大：似简单的变更需要在许多不同地方进行代码修改
- 认知负荷：开发人员需要多少知识才能完成一项任务
- 未知的未知：不知道修改哪些代码才能完成需求

### 原因

- 依赖：难以管理的依赖性增加复杂性
- 模糊：意义不明的实体也会增加复杂性

### 降低

在进行模块开发时，要不留出简单的接口，要不留出简单的实现

前者方便了用户，后者方便了开发者自己

像配置参数就是可以避免处理重要问题从而将其留给用户的一个例子

## 模块

通过分离接口与实现，接口是实现的抽象，越抽象的接口代表的模块越深，通过更高层级的抽象来隐藏复杂性

### 信息隐藏

每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其对外提供的接口中

在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序

如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口

### 通用模块

- 为当前设计还是为未来设计

更通用的模块会隐藏更多的信息

通用接口往往更简单，使用的方法更少

## 层

### 直通方法

一种不执行任何操作的方法，只是将其参数传递给另一个方法

```java
public class TextDocument ... {
    private TextArea textArea;
    private TextDocumentListener listener;
    ...
    public Character getLastTypedCharacter() {
        return textArea.getLastTypedCharacter();
    }
    public int getCursorOffset() {
        return textArea.getCursorOffset();
    }
    public void insertString(String textToInsert, int offset) {
        textArea.insertString(textToInsert, offset);
    }
}
```

直通方法使类变浅

### 接口复制

直通方法导致了许多接口复制，但在一些情况下，接口复制也有其存在的意义，如方法的动态委派、装饰器模式等

### 接口与实现

接口与实现通常不同，如果两者相似，则表明该类很浅

一连串接口之间通常需要传递变量，如果这些变量在被调用接口用不到，就会增加复杂性，为了解决这个问题，可以通过引入上下文对象来屏蔽这些用不到变量

通过能在统一的地方中获取到这个上下文对象，来减少复杂性

## 分开还是合并

- 给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？
- 选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口

如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开

- 两者是否信息共享
- 合并两者是否简化接口
- 合并是否消除重复代码
- 分离通用代码与专用代码

长方法并不总是坏的，以方法长度作为方法需要拆分的依据太过极端

## 组件间交互

- CQS command query speration 命令查询分离
- SOC separation of concerns  关注点分离

## 框架设计趋势

- 约定优于配置
