# 服务限流

>当系统资源不够，不足以应对大量请求，即系统资源与访问量出现矛盾的时候，我们为了保证有限的资源能够正常服务，因此对系统按照预设的规则进行流量限制或功能限制的一种方法

限流原因

- 流量大
- 保护服务

## 计数器算法

系统维护一个计数器，来一个请求就加1，请求处理完成就减1，当计数器大于指定的阈值，就拒绝新的请求。

基于这个简单的方法，可以再延伸出一些高级功能，比如阈值可以不是固定值，是动态调整的。另外，还可以有多组计数器分别管理不同的服务，以保证互不影响等。

- 滑动窗口计数

滑动窗口原理是在每次有访问进来时，先判断前 N 个单位时间内的总访问量是否超过了设置的阈值，并对当前时间片上的请求数 +1

![202001271051](/assets/202001271051.jpg)

## 队列

就是基于FIFO队列，所有请求都进入队列，后端程序从队列中取出待处理的请求依次处理。
基于队列的方法，也可以延伸出更多的玩法来，比如可以设置多个队列以配置不同的优先级

## 令牌桶算法

设置一个令牌桶，另外有一个脚本以持续恒定的速度往令牌桶里面放令牌，后端处理程序每处理一个请求就必须从桶里拿出一个令牌，如果令牌拿完了，那就不能处理请求了。我们可以控制脚本放令牌的速度来达到控制后端处理的速度，以实现动态流控

使用guava实现

```java
@RestController
public class Controller {

    /**
     * 一个每秒创建一个token的桶
     */
    RateLimiter limiter = RateLimiter.create(1);

    @RequestMapping("index")
    public String index(){
        // 500ms内无法获取令牌，返回错误，否则成功
        if (limiter.tryAcquire(500, TimeUnit.MILLISECONDS)){
            return "success";
        }else {
            return "error";
        }

    }
}
```

## 漏桶算法

漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率

![202001271537](/assets/202001271537.png)

**令牌桶与漏桶**

主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它适合于具有突发特性的流量。