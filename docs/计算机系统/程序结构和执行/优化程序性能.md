编写高效程序需要注意的：

- 合适的算法与数据结构
- 编写出能让编译器转换为高效机器代码的源代码

# 优化编译器的能力和局限性

- 编译器优化级别与安全的优化

_函数内联_

**内存读写带来的开销** **函数调用带来的开销**

# 表示程序性能

每元素周期数(CPE)

_循环展开_ _编译器可以自动进行_

# 消除循环的低效率

- 代码移动

```c
void f1(int a[]){

    int i = length(a);
    int j;
    for(j=0;j<i;j++){
        // DO SOMETHING
    }
}

void f2(int a[]){

    int j;
    for(j=0;j< length(a);j++){
        // DO SOMETHING
    }
}
```

# 减少过程调用

# 消除不必要的内存引用

```c
void sum1(int a[],int n,int *ret){
    int i=0;
    for(;i<n;i++){
        *ret += a[i];
    }
}

void sum2(int a[],int n,int *ret){
    int i=0;
    int tmp=0;
    for(;i<n;i++){
        tmp += a[i];
    }
    *ret = tmp;
}
```

# _理解现代处理器_

## 整体操作

- 分支预测

_寄存器重命名_

## 功能单元的性能

## 处理器操作的抽象模型

# 提高并行性

## 多个累积变量

```c
void sum1(int a[],int n,int *ret){
    int i=0;
    int limit = n/2;
    int tmp1=0;
    int tmp2=0;

    for(;i<limit;i++){
        tmp1 += a[i];
    }

    for(i=limit;i<n;i++){

        tmp2+=a[i];
    }

    *ret= tmp1 + tmp2;
}
```

## 重新结合变换

```c
tmp = (tmp + a[i]) +a[i+1] // 1
tmp = tmp + (a[i] +a[i+1]) // 2
```

# 限制因素

## 寄存器溢出

如果寄存器不够用，将会使用内存存放临时变量，造成性能下降

## 分支预测和预测错误处罚

- 不必过分关心
- 编写适合用条件传送码实现的代码

# 理解内存性能

- 加载性能
- 存储性能

# 应用：性能提高技术

- 高级设计：算法与数据结构
- 基本编码原则

  - 消除连续的函数调用
  - 消除不必要的内存引用

- 低级优化

  - 展开循环
  - 多个累积变量与重新结合
  - 使得编译采用条件数据传送

# 确认和消除性能瓶颈

