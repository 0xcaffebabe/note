{"name":"Tomcat","id":"中间件-web中间件-Tomcat","content":"# Tomcat\n\n## 目录结构\n\n目录及文件|说明\n-|-\nbin|用于存放Tomeat的启动、停止等批处理脚本和Shelll脚本\nbin/startup.bat|用于在Vindows下启动Tomeat\nbin/startup.sh|用于在Linux下启动Tomcat\nbin/shutdown.bat|用于在Windows下停止Tomcat\nbin/shutdown.sh|用于在Linux下停止Tomcat\nconf|用于存放Tomeat的相关配置文件\nconf/Catalina|用于存储针对每个虚拟机的Context配置\nconf/context.xml|用于定义所有Wcb应用均需要加载的Context配置，如果Web应用指定了自己的context..xml,那么该文件的配置将被覆盖\nconf/catalina.properties|Tomcat环境变量配置\nconf/catalina.policy|当Tomeat在安全模式下运行时，此文件为默认的安全策略配置\nconf/logging.properties|Tomcat日志配置文件，可通过该文件修改Tomcat日志级别以及日志路径等\nconf/server.xml|Tomcat服务器核心配置文件，用于配置Tomcat的链接器、监听端口、处理请求的虚拟主机等。可以说，Tomcat主要根据该文件的配置信息创建服务器实例\nconf/tomcat-users.xml|用于定义Tomcat默认用户及角色映射信息，Tomcat的Manager模块即用该文件中定义的用户进行安全认证\nconf/web.xml|Tomcat中所有应用默认的部署描述文件，主要定义了基础Servlet和MME映射。如果应用中不包含web.xml,那么Tomcat将使用此文件初始化部署描述，反之，Tomcat会在启动时将默认部署描述与自定义配置进行合并\nlib|Tomcat服务器依赖库目录，包含Tomeat服务器运行环境依赖Jar包\nlogs|Tomcat默认的日志存放路径\nwebapps|Tomcat默认的Web应用部署目录\nwork|web应用JSP代码生成和编译临时目录\n\n## 部署方式\n\n- 直接将项目放到webapps目录下\n- 配置conf/server.xml文件\n\n  ```\n  在<Host>标签体中配置\n                    <Context docBase=\"D:\\hello\" path=\"/hehe\" />\n                     docBase:项目存放的路径\n                     path：虚拟目录\n  ```\n\n- 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写\n\n  ```\n  <Context docBase=\"D:\\hello\" />\n  ```\n\n  - 虚拟目录：xml文件的名称\n\n**JAVA WEB项目目录结构**\n\n- 项目的根目录\n  - WEB-INF目录：\n    - web.xml：web项目的核心配置文件\n    - classes目录：放置字节码文件的目录\n    - lib目录：放置依赖的jar包\n\n## 架构\n\n```mermaid\nclassDiagram\n    class Server {\n        +start()\n        +stop()\n    }\n    class Service {\n        +start()\n        +stop()\n    }\n    class Connector {\n        +start()\n        +stop()\n    }\n    class Container {\n        +start()\n        +stop()\n    }\n    Server *--> Service\n    Service *--> Connector\n    Service *--> Container\n\n```\n\n- Connector负责连接的建立以及数据返回\n- Container(Engine)负责请求的具体处理\n- Service 负责维护Conenctor与Container之间的映射关系\n\n### Connector\n\n连接器需要完成 3 个的功能：网络通信、应用层协议解析、Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化分别由 Endpoint、Processor 和 Adapter 完成\n\n```mermaid\nclassDiagram\n    class Connector {\n        +start()\n        +stop()\n    }\n    class ProtocolHandler {\n        +handle()\n    }\n    class AbstractEndpoint {\n        +bind()\n        +release()\n    }\n    class Processor {\n        +process()\n    }\n    Connector *--> ProtocolHandler\n    ProtocolHandler *--> AbstractEndpoint\n    ProtocolHandler ..> Processor\n\n```\n\n```mermaid\nsequenceDiagram\n  外部 ->> Endpoint: 请求\n  note left of Endpoint: TCP/IP\n  Endpoint ->> Processor: Socket\n  note left of Processor: HTTP/AJP\n  Processor ->> Adapter: Tomcat Request\n  Adapter ->> Container: Servlet Request\n```\n\n### Container\n\n```mermaid\nstateDiagram\n    direction LR\n    连接器 --> Engine\n    Engine --> Host1\n    Host1 --> Context1\n    Context1 --> Wrapper1\n    Context1 --> Wrapper2\n    Host1 --> Context2\n    Engine --> Host2\n\n```\n\n- Engine：Container的具体实现\n- Host：以域名为主的一个虚拟主机\n- Wrapper：代表Servlet实例\n- Context：代表一个独立的web应用\n- PipeLine：各个组件之间传递消息的管道\n\n所有的容器组件都实现了 Container 接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。\n\nTomcat 通过 Mapper 组件保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，当一个请求到来时，Mapper 组件通过解析请求 URL 里的域名和路径，就能定位到一个 Servlet。\n\n一个请求流经 Engine -> Host -> Context -> Wrapper，每个节点都会对请求做一些处理\n\n### LifeCycle\n\n容器相关的组件都实现了 LifeCycle 接口，父组件以此管理子组件的启动与停止\n\n### Executor\n\n在 Endpoint 与 Processor 之间有个线程池来处理请求，共享线程池由Service维护\n\n### Bootstrap和Catalina\n\nBootstrap 是用来初始化类加载器的\n\n通过 Bootstrap 启动 Cataina， Catalina启动Server 实现了Bootstrap 与 Server进行解耦\n\n### 启动流程\n\n```mermaid\nsequenceDiagram\n  用户 ->> Bootstrap: start\n  Bootstrap ->> Bootstrap: init\n  Bootstrap ->> Bootstrap: load\n  Bootstrap ->> Cataina: load\n  Cataina ->> Cataina: 创建Server\n  Cataina ->> Server: init\n  Server ->> Service: init\n  Service ->> Engine: init\n  Engine ->> Host: init\n  Host ->> Context: init\n  Service ->> Executor: init\n  Service ->> Connector: init\n  Connector ->> ProtocolHandler: init\n\n  Bootstrap ->> Bootstrap: start\n  Bootstrap ->> Cataina: start\n  Cataina ->> Server: start\n  Server ->> Service: start\n  Service ->> Engine: start\n  Engine ->> Host: start\n  Host ->> Context: start\n  Service ->> Executor: start\n  Service ->> Connector: start\n  Connector ->> ProtocolHandler: start\n```\n\n### 请求处理\n\n```mermaid\nsequenceDiagram\n    participant Endpoint\n    participant Processor\n    participant CoyoteAdapter\n    participant Mapper\n    participant Engine\n    participant Host\n    participant Context\n    participant Wrapper\n    participant FilterChain\n    participant Servlet\n\n    Endpoint->>Processor: Request\n    Processor->>CoyoteAdapter: Process request\n    CoyoteAdapter->>Mapper: Map request\n    Mapper->>Engine: Send to engine\n    Engine->>Host: Identify host\n    Host->>Context: Identify context\n    Context->>Wrapper: Identify wrapper\n    Wrapper->>Wrapper: Build Filters\n    Wrapper->>FilterChain: Apply filters\n    FilterChain->>Servlet: Forward to servlet\n```\n\n### 类加载器\n\n```mermaid\nstateDiagram-v2\n  BootstrapClassLoader --> ExtensionClassLoader\n  ExtensionClassLoader --> SystemClassLoader\n  SystemClassLoader --> CommonClassLoader\n  CommonClassLoader --> CatalinaClassLoader\n  CommonClassLoader --> SharedClassLoader\n  SharedClassLoader --> WebApp1ClassLoader\n  SharedClassLoader --> WebApp2ClassLoader\n```\n\n- SharedClassLoader：专门来加载 Web 应用之间共享的类\n- CatalinaClassLoader：专门来加载 Tomcat 自身的类\n- CommonClassLoader：用来共享 Tomcat 和各 Web 应用之间的类\n\n通过每个app使用自己的类加载器来达到：\n\n- 隔离：不同的app依赖类库不会相互影响\n- 灵活：重新部署时的问题\n\n对于Web 应用类加载器，它的加载顺序：\n\n- 从缓存加载\n- 如果缓存没有 从JVM的Bootstrap类加载器加载 （防止JAVA SE核心类被覆盖）\n- 如果还是没有 从当前类加载器加载 （如果开启委托 则会遵循JVM双亲委托模型）\n- 还没有 再从父类加载器加载\n\n线程上下文加载器：这个类加载器保存在线程私有数据里，只要是同一个线程，一旦设置了线程上下文加载器，在线程后续执行过程中就能把这个类加载器取出来用\n\n### 热加载与热部署\n\n周期性检测资源文件变化，热加载主要完成了下面这些任务：\n\n1. 停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了\n2. 停止和销毁 Context 容器关联的 Listener 和 Filter\n3. 停止和销毁 Context 下的 Pipeline 和各种 Valve\n4. 停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源\n5. 启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源\n\n当监听到webapps 目录变化，Host 会创新创建相对应的 Context 并启动\n\n### Context的命名与请求路径映射\n\n基础文件名称|Name|Path|Version|部署文件名称\n-|-|-|-|-\nfoo|/foo|/foo||foo.xml、foo.war、foo\nfoo#bar|/foo/bar|/foo/bar||foo#bar.xml、foo#bar.war、foo#bar\nfoo##2|/foo##2|/foo|2|foo##2.xml、foo#+2.war、foo#2\nfoo#bar##2|/foo/bar##2|/foo/bar|2|foo#bar##2.xml、foo#bar##2.war、foo#bar##2\nROOT||||ROOT.xml、ROOT.war、ROOT\nROOT##2|##2||2|ROOT##2.xml、ROOT##2.war、ROOT##2\n\n### Catalina 自带的 Servlet\n\n- DefaultServlet：处理静态资源 处理目录请求\n  - 可配参数：<https://tomcat.apache.org/tomcat-7.0-doc/default-servlet.html>\n- JspServlet:编译jsp文件 处理jsp请求\n\n## Coyote\n\n- 请求连接器的实现\n\n支持的传输协议：\n\n- HTTP1.1\n- HTTP2.0\n- AJP1.3\n\n支持的IO方案：\n\n- NIO\n- NIO2\n- APR\n\nHTTP 配置：\n\n```xml\n<!-- server.xml -->\n<Connector executor=\"tomcatThreadPool\"\n               port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n\n<!-- 使用NIO方式处理HTTP1.1 -->\n<Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n               maxThreads=\"150\" SSLEnabled=\"true\">\n<!-- \n  maxThreads:指定Connector创建请求处理线程的最大数\n  maxSpareThreads：允许空闲线程的最大数\n  minSpareThreads\n  tcpNoDelay：禁止TCP通过批量发送数据来提高网络利用率\n  maxKeepAliveRequest: 最大keepalive的连接数\n  socketBuffer\n  enableLookups：是否开启request.getRemoteHost() DNS查询\n -->\n```\n\n### 概念\n\n- Endpoint 通信端点 负责Socekt接收处理\n- Porcessor 负责创建请求和响应 将请求转发到Catalina\n- ProtocolHandler 封装Endpoint Processor\n- UpgradeProtocol 处理HTTP协议的升级协议\n\n### AJP\n\n```xml\n<!-- server.xml -->\n<Connector protocol=\"AJP/1.3\"\n               address=\"::1\"\n               port=\"8009\"\n               redirectPort=\"8443\" />\n```\n\n>AJP（Apache JServ Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本。WEB服务器通过 TCP连接 和 SERVLET容器连接\n\n包结构：\n\n```\n字节位置 0     1      2 3           4-(n+3)\n内容     0x12 0x34 数据长度(n)       数据\n```\n\n有效载荷的前一个字节代表类型\n\n序号|\t类型|\t描述\n-|-|-\n2|Forward Request|使用接下来的数据开始请求处理周期\n7|Shutdown|Web服务器请求Servlet容器关闭自己\n8|Ping|Web服务器请求Servlet容器采取控制（安全登录阶段）\n10|CPing|Web服务器请求Servlet容器通过一个CPong快速响应\n空|Data|主体数据及其大小\n3|Send Body Chunk|Servlet?容器向Web服务器发送一个主体数据块\n4|Send Headers|Servlet?容器向Web服务器发送响应头信息\n5|End Response|用于标记响应结束\n6|Get Body Chunk|如果请求数据未传输完，用于得到更多的请求数据\n9|CPong Reply|CPingi请求应答\n\n```mermaid\nsequenceDiagram\n    title 请求处理\n    participant Web服务器 as Web服务器\n    participant Server程序 as Servlet容器\n    Web服务器->>Server程序: Forward Request\n    Server程序->>Web服务器: Data\n    Web服务器->>Server程序: Get Body Chunk\n    Server程序->>Web服务器: Data\n    Web服务器->>Server程序: Send Headers\n    Server程序->>Web服务器: Send Body Chunk\n    Web服务器->>Server程序: End Response\n```\n\n## Jasper\n\n使用单独的类加载器\n\n### 编译方式\n\n\n```mermaid\nsequenceDiagram\n  title 运行时编译\n  用户 ->> JspServlet: service()\n  JspServlet ->> JspServlet: 获取JSP文件路径\n  JspServlet ->> JspServlet: 判断当前请求是否为预编译请求\n  JspServlet ->> JspServlet: 执行请求serviceJspFile()\n  alt 找不到对应JspServletWrapper\n    JspServlet ->> JspServletWrapper: 执行请求\n    JspServletWrapper ->> JspComplicationContext: 开发环境或第一次调用，执行编译\n    JspServletWrapper ->> JspServletWrapper: 重新加载并实例化JSP的Servlet类\n    JspServletWrapper ->> JspServletWrapper: 更新上次使用时间\n    JspServletWrapper ->> JspServletWrapper: 调用JSP Servlet执行请求\n  end\n\n```\n\n编译结果：\n\n- 首选存放在 context-param 的scratchdir\n- 否则是 $CATALINA_BASE/work/Engine名称/Host名称/Context名称\n- 再否则在系统临时文件目录下\n\n预编译：\n\njspc\n\n### 编译原理\n\n```java\n// 继承该类\nclass index_jsp extends HttpJspBase\n```\n\n```java\nprivate static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();\nprivate static Map<String, Long> _jspx_dependants; // 依赖的外部资源\nprivate static final Set<String> _jspx_imports_packages = new HashSet(); // 导入的包\nprivate static final Set<String> _jspx_imports_classes; // 导入的类\n```\n\n`_jspService` 处理请求：\n\n- 定义了out pageContext session application config page 等局部变量\n- 对于静态内容调用out.write\n- 处理jsp标签\n\n```mermaid\nsequenceDiagram\n  title JSP编译流程\n  外部 ->> JspComplicationContext: 编译\n  JspComplicationContext ->> Compiler: 是否过期\n  Compiler ->> JspComplicationContext: 没过期直接返回\n  opt 编译过程\n    JspComplicationContext ->> Compiler: 删除生成的文件\n    Compiler ->> ParserController: 解析JSP页面\n    Compiler ->> Generator: 生成Java源码\n    Compiler ->> Compiler: 生成Class文件\n  end\n```\n\n## Session机制\n\n主要由每个 Context 容器内的一个 Manager 对象来管理 Session，默认为 StandardManager。通过 Request 获取 Session 会执行创建 Session，Session 存放在个 ConcurrentHashMap 中。\n\nStandardContext 会有个定时扫描的线程去清理过期的 Session，Session 创建事件的监听则是通过 StandardContext 将 HttpSessionListener 类型的 Listener 取出，然后依次调用它们的 sessionCreated 方法。\n\n## 配置管理\n\n### JVM配置\n\n```bat\n:: JVM启动参数\nset \"JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%\"\n```\n\n系统属性：略\n\n### 服务器配置\n\ncatalina.properties: 容器启动阶段的配置\n\nserver.xml: 服务器核心配置\n\n- Server\n- Service\n- Executor 线程池配置 默认其他组件会创建自己的线程池\n\n  ```xml\n  <Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\"\n          maxThreads=\"150\" minSpareThreads=\"4\"/>\n  ```\n- Connector 默认配置了两个 HTTP 和 AJP\n  ```xml\n  <Connector port=\"8080\" -- 监听端口\n  executor=\"sharedThreadPool\" -- 线程池\n  enableLookups=\"false\" -- 调用request.getRemoteHost 是否调用DNS解析获取主机名\n  redirectPort=\"8443\" -- SSL 转发端口\n  acceptCount=\"100\"  -- 控制 socket 排队连接的最大数\n  connectionTimeout=\"2000o\" -- Connector 接收连接处理的超时时间\n  URIEncoding=\"UTF-8\" -- 解码URI的编码\n  compression=\"on\" -- 开启压缩\n  compressionMinSize=\"2048\" -- 最小压缩尺寸\n  noCompressionUserAgents=\"gozilla,traviata\" -- 符合表达式的UA头不压缩\n  compressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\" />\n  ```\n- Engine 可以指定虚拟主机\n- Host\n  - name 域名\n  - appBase 存放应用的目录\n  - unpackWARs 是否解压war包\n  - autoDeploy 定期检测 自动部署\n  - Alias 可以配置新的域名\n- Context\n  - docBase 具体应用的目录\n  - path Context路径\n- CookieProcessor 指定cookie处理器\n- Loader 用于管理 web 应用的类加载器\n  - delegate 属性可以打破双亲委派模型\n  - reloadable 属性会监控资源变化后重新加载应用\n  - loaderClass 指定类加载器的具体实现\n- Manger 会话管理器\n  - Standard和Presistent\n- Resources 资源共享\n  ```xml\n  <Context docBase=\"myApp\" path=\" /myApp\">\n    <Resources>\n      <PreResources\n      className='org.apache.catalina.webresources.FileResourceSet'\n      base=\" /Users/liuguangrui/Documents/sample/app.jsp\"\n      webAppMount=\" /app/app.jsp\"/>\n    </Resources>\n  </Context>\n  ```\n- JarScanner\n- content.xml\n\n### Web 应用配置\n\n- context-param: ServerContext.getInitParameter() 可以获取到的参数\n- session-config 会话配置\n  - 三种追踪模式 COOKIE URL SSL\n- servlet 声明servlet及其映射\n- listener\n- filter\n- mime-mapping 映射文件类型与对应的content-type\n- welcome-file-list\n- error-page\n- locale-encoding-mapping-list 本地化与响应编码的关系\n- 安全配置\n- jndi配置\n\n### 内置的 Filter\n\n- CorsFilter：解决跨域问题\n- CsrfPreventionFilter：防止CSRF攻击\n- ExpiresFilter：控制缓存过期与否\n- FailedRequestFilter：解析参数失败就返回错误\n- RemoteAddrFilter：只放行符合特定表达式的IP地址\n- RemoteHostFilter：只放行符合特定表达式的主机\n- RemoteIpFilter：前方有负载均衡器的情况下 将getRemoteAddr()替换为 X-Forwarded-For 中的IP\n- RequestDumperFilter：以日志形式输出请求和响应对象 主要用于调试\n- SetCharacterEncodingFilter：设置请求编码\n\n### Tomcat 管理\n\n`/host-manager/html`\n\n## 集群\n\n```mermaid\nstateDiagram-v2\n  LB --> WebServer1\n  WebServer1 --> Tomcat1\n  WebServer1 --> Tomcat2\n  Tomcat1 --> Tomcat2\n  Tomcat2 --> Tomcat1\n  LB --> WebServer2\n  WebServer2 --> Tomcat3\n  WebServer2 --> Tomcat4\n  Tomcat3 --> Tomcat4\n  Tomcat4 --> Tomcat3\n```\n\nTomcat 集群实现的原理就是在节点之间同步 Session\n\nTomcat 本身就不适合配置集群 一种通用的解决方案是 接入层为 Nginx\n\nNginx 对后端的Tomcat进行负载均衡 \n\nTomcat上的Web应用最好是设计成无状态的 如果仍然需要保持会话 最好使用一台独立的服务器来存储会话 比如 Redis \n\n而不要使用Tomcat的会话同步功能\n\n## 安全\n\n安装部署：下载安全 移除自带的几个Web应用\n\nserver.xml: \n\n- 删除不必要的连接器\n- 删除UserDatabase\n- 修改关键配置：8005管理端口\n- 避免恶意web应用的自动启动：autoDeploy\n- 允许有限的客户端访问\n- 避免将异常堆栈打印到客户端\n- listing会导致目录泄漏以及DoS攻击\n\n应用安全\n\n传输安全(SSL)\n\nJAVA安全策略\n\n## 优化\n\n### JVM 优化\n\n### Tomcat 配置优化\n\nserver.xml:\n\n- 链接器maxConnections 属性：超过该属性的连接会被阻塞\n- tcpNoDelay：禁止TCP缓存并发送\n- maxKeepAliveRequest\n- socketBuffer\n- enableLookups\n\n网络传输优化：\n\n- 静态文件压缩\n- 高性能链接器(NIO NIO2)\n- 禁用自动部署\n\nJSP页面配置(web.xml):\n\n- development 设置为false 不自动检测JSP页面变动\n- ...\n\n继承 web 服务器：\n\n- 动静分离\n- 负载均衡\n\n### 应用优化\n\n- 减少通信次数\n- 减少通信数据流\n- 推迟会话创建\n- 不在会话存储大对象\n- 合理定义对象作用域\n- 使用连接池提高性能\n- 使用缓存提高性能\n- 最小化日志\n\n## 附加功能\n\n- 嵌入式启动\n- websocket","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2023-10-19T15:35:05+08:00","author":"MY","message":"✏Tomcat","hash":"d0c570fe41ce11dd895b7de3fc90bc05047e8491"},{"date":"2023-10-18T20:10:05+08:00","author":"MY","message":"✏Tomcat","hash":"976ed78fc2ecad1a3ae601ab5b8bc9fea2090873"},{"date":"2023-10-17T20:01:54+08:00","author":"MY","message":"✏Tomcat & Jetty","hash":"a1888d99bb9408cfa0867568c0b1ec77ddff3f93"},{"date":"2023-10-16T20:09:01+08:00","author":"MY","message":"✏Tomcat & Jetty","hash":"ccebf659a71e6ed6e2441dd30f2da6ceedd0bdde"},{"date":"2020-09-05T10:16:46+08:00","author":"MY","message":"✏更新 Tomcat","hash":"0aaf598d264fa93b79fa114a3d6d90cc9a25e6c7"},{"date":"2020-09-04T13:51:02+08:00","author":"MY","message":"✏更新 Tomcat","hash":"2fe498934f6a6107a17b46306232a05573673ac1"},{"date":"2020-09-03T16:28:52+08:00","author":"MY","message":"✏更新 Tomcat","hash":"2e3f605008d1ba4f57181d89167e41a81bed067e"},{"date":"2020-08-27T16:04:52+08:00","author":"MY","message":"✏更新 Tomcat","hash":"fa8f3a35065c819f4b552d6635fadeb45d0fd2e4"},{"date":"2020-08-26T16:08:38+08:00","author":"MY","message":"✏更新 Tomcat","hash":"be7361f49270a0003e3abea023913e059642a5d9"},{"date":"2019-11-24T16:48:59+08:00","author":"MY","message":"新增垃圾回收器&tomcat优化&内部类相关","hash":"ab4330355fdb99577b1ba8fcca8020efef13761d"}],"createTime":"2019-08-08T17:07:47+08:00"}