{"name":"ShardingJDBC","id":"中间件-数据库-ShardingJDBC","content":"# ShardingJDBC\n\n> 一个客户端数据库分片库\n\n## 原理\n\n![202032419222](/assets/202032419222.png)\n\n## 简单使用\n\n```xml\n<dependency>\n    <groupId>io.shardingjdbc</groupId>\n    <artifactId>sharding-jdbc-core</artifactId>\n    <version>2.0.3</version>\n</dependency>\n```\n```yml\n#shardingjdbc配置\nsharding:\n  jdbc:\n    data-sources:\n      ###配置第一个从数据库\n      ds_slave_0:\n        password: 123\n        jdbc-url: jdbc:mysql://192.168.182.132:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=true\n        driver-class-name: com.mysql.jdbc.Driver\n        username: root\n\n      ###主数据库配置\n      ds_master:\n        password: 123\n        jdbc-url: jdbc:mysql://192.168.182.131:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=true\n        driver-class-name: com.mysql.jdbc.Driver\n        username: root\n    ###配置读写分离\n    master-slave-rule:\n      ###配置从库选择策略，提供轮询与随机，这里选择用轮询\n      load-balance-algorithm-type: round_robin\n      ####指定从数据库\n      slave-data-source-names: ds_slave_0\n      name: ds_ms\n      ####指定主数据库\n      master-data-source-name: ds_master\n```\n```java\n@Configuration\n@EnableConfigurationProperties(ShardingMasterSlaveConfig.class)\n@Log4j2\n// 读取ds_master主数据源和读写分离配置\n@ConditionalOnProperty({ \"sharding.jdbc.data-sources.ds_master.jdbc-url\",\n        \"sharding.jdbc.master-slave-rule.master-data-source-name\" })\npublic class ShardingDataSourceConfig {\n\n    @Autowired\n    private ShardingMasterSlaveConfig shardingMasterSlaveConfig;\n\n    @Bean\n    public DataSource masterSlaveDataSource() throws SQLException {\n        final Map<String, DataSource> dataSourceMap = Maps.newHashMap();\n        dataSourceMap.putAll(shardingMasterSlaveConfig.getDataSources());\n        final Map<String, Object> newHashMap = Maps.newHashMap();\n        // 创建 MasterSlave数据源\n        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,\n                shardingMasterSlaveConfig.getMasterSlaveRule(), newHashMap);\n        log.info(\"masterSlaveDataSource config complete\");\n        return dataSource;\n    }\n\n}\n@Data\n@ConfigurationProperties(prefix = \"sharding.jdbc\")\npublic class ShardingMasterSlaveConfig {\n\n    // 存放本地多个数据源\n    private Map<String, HikariDataSource> dataSources = new HashMap<>();\n\n    private MasterSlaveRuleConfiguration masterSlaveRule;\n}\n```\n\n### 分表\n\n```java\n    private DataSource buildDataSource() {\n        // 1.设置分库映射\n        Map<String, DataSource> dataSourceMap = new HashMap<>(2);\n        dataSourceMap.put(\"ds_0\", createDataSource(\"ds_0\"));\n        // dataSourceMap.put(\"ds_1\", createDataSource(\"ds_1\"));\n        // 设置默认db为ds_0，也就是为那些没有配置分库分表策略的指定的默认库\n        // 如果只有一个库，也就是不需要分库的话，map里只放一个映射就行了，只有一个库时不需要指定默认库，\n        // 但2个及以上时必须指定默认库，否则那些没有配置策略的表将无法操作数据\n        DataSourceRule rule = new DataSourceRule(dataSourceMap, \"ds_0\");\n        // 2.设置分表映射，将t_order_0和t_order_1两个实际的表映射到t_order逻辑表\n        TableRule orderTableRule = TableRule.builder(\"t_order\").actualTables(Arrays.asList(\"t_order_0\", \"t_order_1\"))\n                .dataSourceRule(rule).build();\n        // 3.具体的分库分表策略\n        ShardingRule shardingRule = ShardingRule.builder().dataSourceRule(rule)\n                .tableRules(Arrays.asList(orderTableRule))\n                // 根据userid分片字段\n                .tableShardingStrategy(new TableShardingStrategy(\"user_id\", new TableShardingAlgorithm())).build();\n        // 创建数据源\n        DataSource dataSource = ShardingDataSourceFactory.createDataSource(shardingRule);\n        return dataSource;\n    }\n\n    private DataSource createDataSource(String dataSourceName) {\n        // 使用druid连接数据库\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(className);\n        druidDataSource.setUrl(String.format(url, dataSourceName));\n        druidDataSource.setUsername(username);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    }\n```\n```java\npublic class TableShardingAlgorithm implements SingleKeyTableShardingAlgorithm<Long> {\n\n    // sql 中关键字 匹配符为 =的时候，表的路由函数\n    @Override\n    public String doEqualSharding(Collection<String> availableTargetNames, ShardingValue<Long> shardingValue) {\n        for (String tableName : availableTargetNames) {\n            if (tableName.endsWith(shardingValue.getValue() % 2 + \"\")) {\n                return tableName;\n            }\n        }\n        throw new IllegalArgumentException();\n    }\n    ...\n}\n```\n\n## spring boot快速整合\n\n```xml\n<dependency>\n    <groupId>io.shardingsphere</groupId>\n    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>\n    <version>3.0.0.M3</version>\n</dependency>\n```\n```yml\nsharding:\n  jdbc:\n    ####ds1\n    datasource:\n      names: ds0\n      ds0:\n        password: 123\n        type: com.alibaba.druid.pool.DruidDataSource\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        url: jdbc:mysql://192.168.182.131:3306/ds_0\n        username: root\n    config:\n      sharding:\n        tables:\n          t_order:\n            table-strategy:\n              inline:\n                #### 根据userid 进行分片\n                sharding-column: user_id\n                algorithm-expression: ds_0.t_order_$->{user_id % 2}\n            actual-data-nodes: ds0.t_order_$->{0..1}\n        props:\n          sql:\n            ### 开启分片日志\n            show: true\n```","metadata":"","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2023-01-16T14:42:20+08:00","author":"cjiping","message":"📦数据库","hash":"28000b081b4f987f0343c41be793307aedb6addf"},{"date":"2020-03-24T19:26:25+08:00","author":"MY","message":"更新 sharding jdbc 基本使用","hash":"b657be39b4da2744be632238d0b135cbc393bdfb"},{"date":"2020-03-24T09:12:37+08:00","author":"MY","message":"增加 sharding jdbc","hash":"b5a395a984af571f4418f4f36c7f3a12d65474c4"}],"createTime":"2020-03-24T09:12:37+08:00"}