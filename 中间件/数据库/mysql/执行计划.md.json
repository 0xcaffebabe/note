{"name":"执行计划","id":"中间件-数据库-mysql-执行计划","content":"# 执行计划\n\n​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。\n\n​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。\n\n​\t   官网地址： https://dev.mysql.com/doc/refman/5.5/en/explain-output.html \n\n### 1、执行计划中包含的信息\n\n|    Column     |                    Meaning                     |\n| :-----------: | :--------------------------------------------: |\n|      id       |           SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符             |\n|  select_type  |               SELECT 查询的类型                |\n|     table     |          查询的是哪个表          |\n|  partitions   |            匹配的分区             |\n|     type      |                 join 类型 通常来说, 不同的 type 类型的性能关系: ALL < index < range ~ index_merge < ref < eq_ref < const < system                  |\n| possible_keys |         此次查询中可能选用的索引         |\n|      key      |           此次查询中确切使用到的索引            |\n|    key_len    |          示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到          |\n|      ref      |       The columns compared to the index        |\n|     rows      |       估算 SQL 要查找到结果集需要扫描读取的数据行数，这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好         |\n|   filtered    | 根据条件过滤了百分之多少的数据 |\n|     extra     |             很多额外的信息会在这个字段展示             |\n\n**id**\n\nselect查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序\n\nid号分为三种情况：\n\n​\t\t1、如果id相同，那么执行顺序从上到下\n\n```sql\nexplain select * from emp e join dept d on e.deptno = d.deptno join salgrade sg on e.sal between sg.losal and sg.hisal;\n```\n\n​\t\t2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行\n\n```sql\nexplain select * from emp e where e.deptno in (select d.deptno from dept d where d.dname = 'SALES');\n```\n\n​\t\t3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行\n\n```sql\nexplain select * from emp e join dept d on e.deptno = d.deptno join salgrade sg on e.sal between sg.losal and sg.hisal where e.deptno in (select d.deptno from dept d where d.dname = 'SALES');\n```\n\n**select_type**\n\n主要用来分辨查询的类型，是普通查询还是联合查询还是子查询\n\n| `select_type` Value  |                                 Meaning                                 |\n| :------------------: | :---------------------------------------------------------------------: |\n|        SIMPLE        |                   表示此查询不包含 UNION 查询或子查询                   |\n|       PRIMARY        |                        表示此查询是最外层的查询                         |\n|        UNION         |                  表示此查询是 UNION 的第二或随后的查询                  |\n|   DEPENDENT UNION    |           UNION 中的第二个或后面的查询语句, 取决于外面的查询            |\n|     UNION RESULT     |                              UNION 的结果                               |\n|       SUBQUERY       |                         子查询中的第一个 SELECT                         |\n|  DEPENDENT SUBQUERY  | 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果 |\n|       DERIVED        |   派生表，当在SELECT语句的FROM子句中使用独立子查询时，将其称为派生表    |\n| UNCACHEABLE SUBQUERY |    无法缓存其结果的子查询，必须针对外部查询的每一行重新执行该子查询     |\n|  UNCACHEABLE UNION   |              UNION 中属于不可缓存子查询的第二个或后续选择               |\n\n```sql\n--sample:简单的查询，不包含子查询和union\nexplain select * from emp;\n\n--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary\nexplain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ;\n\n--union:若第二个select出现在union之后，则被标记为union\nexplain select * from emp where deptno = 10 union select * from emp where sal >2000;\n\n--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响\nexplain select * from emp e where e.empno  in ( select empno from emp where deptno = 10 union select empno from emp where sal >2000)\n\n--union result:从union表获取结果的select\nexplain select * from emp where deptno = 10 union select * from emp where sal >2000;\n\n--subquery:在select或者where列表中包含子查询\nexplain select * from emp where sal > (select avg(sal) from emp) ;\n\n--dependent subquery:subquery的子查询要受到外部表查询的影响\nexplain select * from emp e where e.deptno in (select distinct deptno from dept);\n\n--DERIVED: from子句中出现的子查询，也叫做派生类，\nexplain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ;\n\n--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存\n explain select * from emp where empno = (select empno from emp where deptno=@@sort_buffer_size);\n \n--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证\n```\n\n**table**\n\n对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集\n\t\t1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名\n\n​\t\t2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表\n\n​\t\t3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id\n\n**type**\n\ntype显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：\n\nsystem > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL \n\n一般情况下，得保证查询至少达到range级别，最好能达到ref\n\n```sql\n--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。\nexplain select * from emp;\n\n--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序\nexplain  select empno from emp;\n\n--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, <>, >, >=, <, <=, IS NULL, BETWEEN, LIKE, or IN() \nexplain select * from emp where empno between 7000 and 7500;\n\n--index_subquery：利用索引来关联子查询，不再扫描全表\nexplain select * from emp where emp.job in (select job from t_job);\n\n--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引\n explain select * from emp e where e.deptno in (select distinct deptno from dept);\n \n--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来\n\n--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式\nexplain select * from emp e where  e.mgr is null or e.mgr=7369;\n\n--ref：使用了非唯一性索引进行数据的查找\n create index idx_3 on emp(deptno);\n explain select * from emp e,dept d where e.deptno =d.deptno;\n\n--eq_ref ：使用唯一性索引进行数据查找\nexplain select * from emp,emp2 where emp.empno = emp2.empno;\n\n--const：这个表至多有一个匹配行，\nexplain select * from emp where empno = 7369;\n \n--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现\n```\n\n **possible_keys** \n\n​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用\n\n```sql\nexplain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;\n```\n\n**key**\n\n​\t\t实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。\n\n```sql\nexplain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;\n```\n\n**key_len**\n\n表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。\n\n```sql\nexplain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;\n```\n\n**ref**\n\n显示索引的哪一列被使用了，如果可能的话，是一个常数\n\n```sql\nexplain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;\n```\n\n**rows**\n\n根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好\n\n```sql\nexplain select * from emp;\n```\n\n**extra**\n\n包含额外的信息。\n\n```sql\n--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置 \nexplain select * from emp order by sal;\n\n--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除\nexplain select ename,count(*) from emp where deptno = 10 group by ename;\n\n--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找\nexplain select deptno,count(*) from emp group by deptno limit 10;\n\n--using where:使用where进行条件过滤\nexplain select * from t_user where id = 1;\n\n--using join buffer:使用连接缓存，情况没有模拟出来\n\n--impossible where：where语句的结果总是false\nexplain select * from emp where empno = 7469;\n```\n\n","metadata":"","hasMoreCommit":false,"totalCommits":2,"commitList":[{"date":"2024-12-11T19:59:57+08:00","author":"MY","message":"📦MySQL","hash":"5c96cf53bb2f2ca8359f5fab16cf12f5ef224bbc"},{"date":"2020-07-30T11:14:22+08:00","author":"MY","message":"✏更新 MYSQL 调优","hash":"6b403f8f505ebe389e127fa87e7d4a5d8fdb172d"}],"createTime":"2020-07-30T11:14:22+08:00"}