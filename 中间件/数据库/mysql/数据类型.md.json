{"name":"数据类型","id":"中间件-数据库-mysql-数据类型","content":"# 数据类型\n\n## 数据值类别\n\n数值：\n\n- 精确值：整数 带小数点的数\n- 位域值： `b'1000'` 代表8\n\n字符串值：\n\n```sql\n'cxk' -- 推荐使用单引号\n```\n\n二进制串比较是逐字节比较\n\n非二进制串根据排序规则比较\n\n日期时间值: \n\n```sql\n'2020-08-25'\n'11:47:00'\n'2020-08-25 11:47:00'\n\nSELECT '2020-08-25 11:47:00' + INTERVAL 2 DAY;\n```\n\n空间值：(10 20)\n\n布尔值：0会被当成假 非0非NULL会被当成真\n\nNULL值：`\\N` 会被当成NULL\n\n### 整型\n\nTINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好\n\n整数类型可以附带UNSIGNED属性，这可以使它的正数表示范围提高一倍。\n\n同时，在定义数据类型时的INT(11) 这里的11指的是在交互终端下显示的字符个数，INT(1)和INT(20)在存储和计算上都是相同的\n\n### 浮点数\n\nFLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型，DECIMAL 的计算比浮点类型需要更高的代价\n\n### 字符串\n\n一种是定长的(char)，一种是变长的(varchar)。\n\n变长类型使用额外的1个或两个字节来存储长度，能够节省空间，因为只需要存储必要的内容，但当变长类型发生UPDATE操作后，需要执行额外的操作\n\n存储和检索时，VARCHAR 末尾的空格会保留下来，而会 CHAR 末尾的空格会被删除。\n\n填充和删除空格的行为在所有存储引擎上都一样，这是在MySQL服务器层处理的。\n\n另外两种类型是BLOB和TEXT，都是为了存储很大的数据而设计出来的。当这些数据很大时，一些存储引擎会将这些数据存储在外部，通过指针来引用，这两种类型不能将全部的数据用以建索引，除非不得以，否则不要使用这两种类型。\n\n### 枚举\n\nMySQL底层将枚举转换为整数来进行处理，所以枚举的性能相较于字符串快，但缺点是一旦是枚举列表发生变化，就必须通过ALTER TABLE来进行添加。\n\n### 时间和日期\n\n- DATE\n- TIME\n- YEAR\n- DATETIME\n\n能够保存从 1000 年到 9999 年的日期和时间，精度为秒，时区无关\n\n- TIMESTAMP\n\n和 UNIX 时间戳相同，应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高\n\n### 位数据类型\n\n谨慎使用BIT类型。SET类型类似于枚举。\n\n## 序列\n\n使用 AUTO_INCREMENT 来生成序列\n\n自增值的行为如下：\n\n- 如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段\n- 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值\n\n### 通用\n\n- 每个表只能有一个列具有 AUTO_INCREMENT\n- 列必须建立索引\n- 列为 NOT NULL\n- 使用`LAST_INSERT_ID()`获取最后一个序号\n- 插入0或NULL都会生成自增ID\n- 某些存储引擎可以复用被删除的序列\n\n### 存放位置\n\n- MyISAM 引擎的自增值保存在数据文件中\n- InnoDB 引擎的自增值在5.7之前存放在内存中，数据库每次启动都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值，8.0之后将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值\n\n### 存储引擎特有\n\nMyISAM:\n\n- 不会复用被删除的序列\n- 默认从1开始\n- 使用`ALTER TABLE tb AUTO_INCREMENT = 10` 语句更改当前序列的值\n\nInnoDB:\n\n- CREATE TABLE 时可以指定起始值\n- 事务被回 序列不会回滚\n\n### 需要考虑的问题\n\n- AUTO_INCREMENT 只能生成正整数序列 使用 UNSINGED 可以获得双倍的空间\n- TRUNCATE TABLE 会重置序列\n\n批量插入批量申请自增 id：\n\n- 语句执行过程中，第一次申请自增 id，会分配 1 个\n- 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个\n- 2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个\n- 依此类推，同一个语句去申请自增 id，这样可能就会导致申请的 ID 并不会全部用完，ID会不连续\n\n### 不使用 AUTO_INCREMENT 生成序列\n\n```sql\nUPDATE seq SET n = LAST_INSERT_ID(n+1); -- 调用有参方法 下次无参调用就会返回n+1\nINSERT INTO tb(..) VALUES(LAST_INSERT_ID()...)\n```\n\n```sql\nSTART TRANSACTION;\nUPDATE seq  SET n = n+1;\nCOMMIT;\n```\n\n### 自增锁\n\nMySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放\n\nMySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode：\n\n- 设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁\n- 设置为 1 时：普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放\n- 设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁\n\n### MySQL 的 ID 及上限\n\n- AUTO_INCREMENT id，取决于数据类型\n- InnoDB 系统自增 row_id：InnoDB 表没有指定主键时，InnoDB 创建一个不可见的，长度为 6 个字节的自增 ID，当这个 ID 发生溢出，新写入的行就会覆盖原有的行\n- Xid：第一条执行语句的query_id；而query_Id是在每次执行语句时都会自增，这个 ID 的上限是 8 字节\n- trx_id：MVCC 所用来隔离不同事务，标志不同事务的ID，由于 trx_id 不会清零，超出上限之后会产生脏读\n- thread_id：系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量，上限是4个字节\n\n## 表达式\n\n```sql\nSELECT (SELECT ...),.. FROM ...; -- 标量子查询提供单个值必须使用括号\n```\n\n### 运算符\n\n算术：\n\n- `+ - * / %`\n- DIV `a DIV b` 整除\n\n逻辑：\n\n- AND OR XOR NOT\n\n位运算：\n\n`& | ^ << >>`\n\n比较运算符：\n\n![屏幕截图 2020-08-26 101539](/assets/屏幕截图%202020-08-26%20101539.png)\n\n### 类型转换\n\nMySQL 会尽量将值转换成表达式所需要的类型\n\n## 选择\n\n- 具体对应的数据类型\n- 考虑值是否在数据类型所对应的区间","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2023-04-24T16:00:54+08:00","author":"MY","message":"✏MySQL","hash":"a729660d492b45ce9b73695c5d51fb89adae6056"},{"date":"2021-03-02T18:20:39+08:00","author":"cjiping","message":"✏更新 MySQL 优化","hash":"1966127b63a695eadb4f5042ee7cba5981012756"},{"date":"2020-08-26T11:27:57+08:00","author":"MY","message":"✏更新 MySQL","hash":"753797505768d25387cf9d484d9d7d2a3d718a03"},{"date":"2020-08-25T13:38:03+08:00","author":"MY","message":"✏更新 mysql","hash":"b3d04831de7705ad9eafd187b455a57eb3e82c0d"}],"createTime":"2020-08-25T13:38:03+08:00"}