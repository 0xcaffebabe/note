# 查询优化

## 查询慢的原因

网络 CPU IO 上下文切换 系统调用 生成统计信息 锁等待

## 优化数据访问

查询性能低下的主要原因是访问的数据太多 需要避免检索、传输大量数据

## 执行过程优化

- 查询缓存

### 查询优化处理

- 计算的依据

每个表或者索引的页面个数
索引的基数
索引和数据行的长度
索引的分布情况

很多情况下mysql会选择错误的执行计划

- 优化策略
  - 静态优化 直接对解析树进行分析，并完成优化
  - 动态优化 动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关

- 优化类型
  - 重新定义关联表的顺序
  - 将外连接转化成内连接，内连接的效率要高于外连接
  - 使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式
  - 优化count(),min(),max()
  - 预估并转化为常数表达式，当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理
  - 索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引
  - 子查询优化
  - 等值传播

- 排序优化

- 优化特定类型查询
  - count 查询
    - 只有没有任何where条件的count(*)才是比较快的
    - 不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值
    - 实际操作的时候可以考虑使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统
  - 关联查询
    - 确保on或者using子句中的列上有索引
    - 确保任何的groupby和order by中的表达式只涉及到一个表中的列
  - 子查询优化
    - 使用关联查询替代
  - limit 分页优化
    - 优化此类查询的最简单的办法就是尽可能地使用覆盖索引，而不是查询所有的列
  - 优化union查询
    - 除非确实需要服务器消除重复的行，否则一定要使用union all
  - 使用用户自定义变量