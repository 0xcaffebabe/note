{"name":"API","id":"中间件-数据库-redis-API","content":"# API\n\n## 通用\n\n- keys * : 查看所有的键(生产环境应禁用，原因：正则表达式可能会占用大量资源)\n- dbsize 返回当前数据库中建的总数\n- type key ： 获取键对应的value的类型\n- del key：删除指定的key(可以是多个)\n- exists key：判断指定的key是否存在\n- expire key time：指定key的生存时间，单位：秒\n- ttl key 查看键的剩余过期时间\n\n## 字符串类型\n\n命令|时间复杂度\n-|-\nset key value|O(1)\nget key|O(1)\ndel key key ...|O(k),k是键的个数\nmset key value key value ...|O(k),k是键的个数\nmget key key ...|O(k),k是键的个数\nincr key|O(1)\ndecr key|O(1)\nincrby key increment|O(1)\ndecrby key decrement|O(1)\nincrbyfloat key increment|O(1)\nappend key value|O(1)\nstrlen key|O(1)\nsetrange key offset value|O(1)\ngetrange key start end|O(n),n是字符串长度，由于获取字符串非常快，所以如果字符串不是很长，可以视同为O(1)\n\n```sh\nset key value [ex seconds] [px milliseconds] [nx|xx] # 设置值\n# ex 以秒为单位的过期时间\n# px 毫秒单位的过期时间\n# nx：set if not exists\n# xx set if exists\nget key # 获取值\n\nmset name cxk age 18 # 批量设置值\nmget name age # 批量获取值\n\nincr a # 自增1\nincrby a 15 # 自增指定值\ndecrby a 15 # 自减指定值\nincrbyfloat a 10.5 # 自增浮点数\n\nappend name jntm # 字符串追加值\nstrlen name # 获取字符串长度\nset name 蔡徐坤\nstrlen name # redis将中文序列化为byte数组 中文的长度取决于终端的编码集\ngetset name world # 设置新值并返回旧值\nsetrange name 2 kd # 从指定位置设置字符串\ngetrange name 0 -1 # 获取指定范围的字符串\n```\n\n```mermaid\nsequenceDiagram\n  title 一次mget命令执行模型\n  Client ->> Redis: 命令1,命令2,..命令n\n  Redis ->> Redis: 执行n次\n  Redis ->> Client: 返回结果\n```\n\n- 在redis中 自增操作都是原子的 不用担心被别的客户端修改\n\n### bitmap\n\n这个数据类型适合用来处理海量数据\n\n```sh\nsetbit map 5 1 # 将偏移量为5的bit设置为1 在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞\ngetbit map 5 # 获取偏移量为5的值\nbitcount map 0 -1 # 获取指定范围内1的个数\nbitop and|or|not|xor ret map map1 # bitmap 集合运算\nbitpos map 1 # bitmap 第一个值为1的bit的偏移量\n```\n\n例子：\n\n统计某个时间窗口内的登录天数\n\n```sh\nsetbit cxk 1 1 # 第一天登录\nsetbit cxk 364 1 # 第364天登录\nbitcount cxk 0 10 # 0 - 10天这个时间窗口登录了几天\n```\n\n统计某个时间窗口活跃用户数\n\n```sh\nsetbit 200618 1 1 # 18号1号用户登录\nsetbit 200619 1 1 # 19号1号用户登录\nsetbit 200619 7 1 # 19号7号用户登录\nbitop or ret 200618 200619 # 使用或运算合并bit\nbitcount ret 0 0 # 统计有多少位1\n```\n\n### HyperLogLog\n\n通过HyperLogLog可以利用极小的内存空间完成大量元素的独立总数的统计\n\n用小空间来估算如此巨大的数据，其中一定存在误差率（类似于布隆过滤器）\n\n使用这个来估算数据 可以容忍一定的误差率\n\n```sh\npfadd users user1 user2 user3 user4 # 添加元素\npfcount users # 统计个数\n```\n\n## 哈希类型\n\n命令|时间复杂度\n-|-\nhset key field value|O(1)\nhget key field|O(1)\nhdel key field field ...|O(k),k是field个数\nhlen key|O(1)\nhgetall key|O(n),n是field总数\nhmget field field ...|O(k),k是field的个数\nhmset field value field value ...|O(k),k是field的个数\nhexists key field|O(1)\nhkeys key|O(n),n是field总数\nhvals key|O(n),n是field总数\nhsetnx key field value|O(1)\nhincrby key field increment|O(1)\nhincrbyfloat key field increment|0(1)\nhstrlen key field|O(1)\n\n```sh\nhset user:1 name cxk age 18 # 设置field\nhsetnx user:1 name cxk # set if not exists\nhget user:1 name # 获取field\nhdel user:1 name age # 删除field\nhlen user:1 # 计算field个数\nhmget user:1 name age # 批量获取field\nhexists user:1 name # 判断field是否存在\nhkeys user:1 # 获取所有field名称\nhvals user:1 # 获取所有field value\nhgetall user:1 # 获取全部kv对\nhincrby user:1 age 1 # 对指定field自增\nhincrbyfloat user:1 age 1.5 # 浮点数自增\n```\n\n内部编码：\n\n- ziplist 压缩列表 这种类型使用更加紧凑的结构实现多个元素的连续存储 **节省内存**\n- hashtable 读写效率比ziplist高\n\n使用场景：\n\n- 哈希类型是稀疏的，而关系型数据库是完全结构化的，哈希类型每个键可以有不同的field，而关系型数据库一旦添加新的列，所有行都要为其设置值\n- 关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发困难\n\n## 列表类型\n\n命令|时间复杂度\n-|-\nrpush key value value ...|O(k),k是元素个数\nlpush key value value ...|O(k),k是元素个数\nlinsert key before/after pivot value|O(n),n是pivot距离列表头或尾的距离\nlrange key start end|O(s+n),s是start偏移量，n是start到end的范围\nlindex key index|O(n),n是索引的偏移量\nllen key|O(1)\nlpop key|O(1)\nrpop key|O(1)\nlrem count value|O(n),n是列表长度\nltrim key start end|O(n),n是要裁剪的元素总数\nlset key index value|O(n),n是索引的偏移量\nblpop brpop|O(1)\n\n- 将元素加入列表左边：`lpush key value`\n- 将元素加入列表右边：`rpush key value`\n- 元素插入：`linsert key before|after pivot value`\n- 范围获取：`lrange key start end`\n- 获取指定下标：`lindex key i`\n- 获取列表长度:`llen key`\n- 删除列表最左边的元素，并将元素返回:`lpop key`\n- 删除列表最右边的元素，并将元素返回:`rpop key`\n- 删除指定元素\n  - 从左到右 最多删除一个：`lrem list 1 java`\n  - 从右到左 最多删除一个：`lrem list -1 java`\n  - 删除全部：`lrem list 0 java`\n- 索引范围内的元素：`ltrim list 0 1`\n- 修改指定下标的元素：`lset list 0 java`\n- 阻塞操作\n  - 3秒内获取不到就返回:`brpop list 3`\n\n内部编码：\n\n- ziplist\n- linkedlist\n- quicklist 结合了ziplist和linkedlist两者的优势\n\n使用场景：\n\n- 消息队列 户端使用lrpush从列表左侧插入元素 多个消费者客户端使用brpop命令阻塞式的“抢”\n\n```mermaid\nstateDiagram-v2\n  生产者 --> Redis: lpush\n  消费者1 --> Redis: brpop\n  消费者2 --> Redis: brpop\n  消费者3 --> Redis: brpop\n```\n\n\n- 分页列表 使用lrange实现\n\n其他：\n\n- lpush+lpop=Stack\n- lpush+rpop=Queue\n- lpsh+ltrim=Capped Collection\n- lpush+brpop=Message Queue\n\n## 集合类型\n\n命令|时间复杂度\n-|-\nsadd key element element...|O(k),k是元素个数\nsrem key element element ...|O(k),k是元素个数\nscard key|0(1)\nsismember key element|O(1)\nsrandmember key count|O(counnt)\nspop key|O(1)\nsmembers key|O(n),n是元素总数\nsinter key key... 或 sinterstore|O(m*k),k是多个集合中元素最少的个数，m是键个数\nsuinon key key... 或 suionstore|O(k),k是多个集合元素个数和\nsdiff key key... 或 sdiffstore|O(k),k是多个集合元素个数和\n\n```sh\nsadd set a b c # 添加元素\nsrem set b # 删除元素\nscard set # 计算元素个数(维护一个变量得到)\nsismember set c # 判断元素是否在集合内\nsrandmember set 2 # 随机从集合返回指定个数元素\n# 正数：取出一个去重的结果集（不能超过已有集）\n# 负数：取出一个带重复的结果集，一定满足你要的数量\n# 如果：0，不返回\nspop set 1 # 随机弹出元素\nsmembers set # 获取所有元素\n\nsinter s1 s2 # 求交集\nsunion s1 s2 # 求并集\nsdiff s1 s2 # 求差集\nsinterstore s3 s1 s2 # 交集结果存储到s3\n# ...\n```\n\n内部编码：\n\n- intset 占用内存小\n- hashtable\n\n例子：用户标签\n\n```sh\nsadd user1 food movie sport music\nsadd user2 food music network\nsinter user1 user2 # 计算用户共同感兴趣的标签\n```\n\n例子：抽奖\n\n```sh\nsadd k 1 2 3 4 5 6 7 8 9 # 9个用户\nSRANDMEMBER k 3 # 抽取三个不重复用户\nSRANDMEMBER k -3 # 抽取三个可能会重复的用户\n```\n\n- sadd=Tagging（标签）\n- spop/srandmember=Random item（生成随机数，比如抽奖）\n- sadd+sinter=Social Graph（社交需求）\n\n## 有序集合类型\n\n命令|时间复杂度\n-|-\nzadd key score member...|O(k×log(n)),k是添加成员的个数，n是当前有序集合成员个数\nzcard key|O(1)\nzscore key member|O(1)\nzrank key member、zrevrank key member|O(log(n)) n是当前有序集合成员个数\nzrem key member...|O(k*1og(n)),k是删除成员的个数，n是当前有序集合成员个数\nzincrby key increment member|O(log(n)),n是当前有序集合成员个数\nzrange key start end 、zrevrange key start end|O(log(n)+k),k是要获取的成员个数，n是当前有序集合成员个数\nzcount|O(log(n)),n是当前有序集合成员个数\nzremrangebyrank key start end|O(log(n)+),k是要删除的成员个数，n是当前有序集合成员个数\nzremrangebyscore key min max|O(log(n)+),k是要删除的成员个数，n是当前有序集合成员个数\nzinterstore destination numkeys key key ...|`O(n*k)+O(m*log(m))`,n是成员数最小的有序集合成员个数，k是有序集合的个数，m是结果集中成员个数\nzunionstore destination numkeys key key ...|O(n)+O(m*log(m)),n是成员数最小的有序集合成员个数，k是有序集合的个数，m是结果集中成员个数\n\n```sh\nhelp @sorted_set\n```\n\n![批注 2020-06-19 113509](/assets/批注%202020-06-19%20113509.png)\n\n物理内存左小右大\n\n```sh\nzadd users 251 tom # 添加成员 分数251\nzcard users # 计算成员个数\nzscore users tom # 获取某个成员分数\nzrank users tom # 计算某个成员排名\nzrem users tom # 删除成员\nzincrby users 8 jerry # 增加某个成员的分数\nzrange users 0 10 # 正序返回指定排名范围的成员\nzrevrange users 0 10 # 倒序返回指定排名范围的成员\nzrangebyscore users 0 255 # 正序返回指定分数范围的成员\nzrevrangebyscore users 0 255 # 正序返回指定分数范围的成员\nzcount users 0 255 # 计算指定分数范围的成员个数\nzremrangebyrank users 0 1 # 删除指定排名范围内的成员\nzremrangebyscore users 0 10 # 删除指定分数范围内的成员\n\nzinterstore user:ranking:1_inter_2 2 user:ranking:1 user:ranking:2 weights 1 0.5 aggregate max # 并集\n```\n\n内部数据结构：\n\n- ziplist\n- skiplist\n\n例子：点赞\n\n```sh\nzadd video 0 cxk # cxk发布了一个视频 0赞\nzincrby video 1 cxk # 有人给cxk视频点了一个赞\nzrem video cxk # 清空cxk的视频点赞\nzrevrange video 0 9 # 获取点赞排行榜\n```\n\n## Streams\n\n- XADD：插入消息，保证有序，可以自动生成全局唯一 ID\n- XREAD：用于读取消息，可以按 ID 读取数据\n- XREADGROUP：按消费组形式读取消息\n- XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成\n\n## 键管理\n\n单键管理：\n\n```sh\nrename name newname # 键重命名\nrandomkey # 随机返回数据库里的一个键\nexpire name 10 # 设置键10秒后过期\nexpireat name timestamp # 设置键在指定时间戳后过期\n# 对于字符串 set 会清除其过期时间\n# Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能\npersist name # 去除键的过期时间\n```\n\n键迁移：\n\n- move 同一redis内\n- dump restre 通过RDB文件的方式\n- migrate 自动通过网络传输数据\n\n遍历键：\n\n```sh\nkeys * # 获取所有键 如果Redis包含了大量的键，执行keys命令很可能会造成Redis阻塞\nscan 0 # 渐进式遍历 该命令返回两个部分：1. 下一个游标 2. 遍历结果\n# 如果要继续遍历 下一次scan后面接的就是返回的游标\n```\n\n数据库管理：\n\n```sh\nselect 2 # 切换到2号数据库\nflushdb # 清空数据库 如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能\nflushall\n```\n\nRedis3.0后已经逐渐弱化多数据库这个功能\n","metadata":"","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2024-11-20T14:24:23+08:00","author":"MY","message":"📦Redis","hash":"b64df2e87e14f86576fb82cc7b57e6b452aba69c"},{"date":"2023-11-17T16:08:50+08:00","author":"MY","message":"✏Redis","hash":"d29fc4e4c292a10d3dde9449cbc5c04bca349d25"},{"date":"2020-11-05T16:53:44+08:00","author":"MY","message":"📦重构 Redis","hash":"436d256214f45aea37f8659d4758b82fe1709560"}],"createTime":"2020-11-05T16:53:44+08:00"}