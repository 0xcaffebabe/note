{"name":"Redis","id":"中间件-数据库-redis-Redis","content":"# redis\n\n> redis是一款高性能的NOSQL系列的非关系型数据库\n\n## 应用场景\n\n- 缓存\n- 实时性要求高的数据\n- 消息队列\n- 热点数据\n- 计数器\n- 数据过期处理（可以精确到毫秒）\n- 分布式集群架构中的session分离\n- 分布式锁\n\n### redis不可以做什么\n\n不适合冷数据 大量的数据\n\n### 作为缓存\n\n缓存数据不重要，且不是全量数据\n\n- 缓存中的过期时间不会随着访问而延长，只有发生写，才会重置过期时间，缓存过期的判定有两种：一是访问时判断是否会过期，二是周期性轮训，判断是否过期\n- 缓存所占的内存空间是有限的，随着时间推进，内存满了，就要逐步淘汰掉冷数据\n\n## 简单使用\n\n可执行文件|作用\n-|-\nredis-server|启动Redis\nredis-cli|Redis命令行客户端\nredis-benchmark|Redis基准测试工具\nredis-check-aof|Redis AOF持久化文件检测和修复工具\nredis-check-dump|Redis RDB持久化文件检测和修复工具\nredis-sentinel|启动Redis Sentinel\n\n```sh\nredis-server # 默认配置启动\nredis-server --port 6379 # 指定配置\n\nredis-cli -h 主机名 -p 连接端口\nredis-cli get key # 直接执行get命令\nredis-cli shutdown # 关闭redis server\n```\n\n## 慢查询分析\n\n```mermaid\n---\ntitle: 一条客户端命令的生命周期\n---\nsequenceDiagram\n    客户端 ->> Redis: 发送命令\n    Redis ->> Redis: 命令排队\n    Redis ->> Redis: 执行命令\n    Redis ->> 客户端 : 返回结果\n```\n\n慢查询阈值设置：\n\n- slowlog-log-slower-than：超过xx微秒则记录为慢查询\n- slowlog-max-len\n\n```sh\nconfig set slowlog-log-slower-than 2 # 设置阈值\nslowlog get [n] # 获取慢查询日志 n 指定条数\nslowlog len # 获取慢查询日志列表长度\nslowlog reset # 清空慢查询日志\n```\n\n慢查询日志结构：\n\n1. id\n2. time\n3. duration\n4. command\n    - 参数..\n5. ip:port\n\n最佳实践：\n\n- 线上建议调大慢查询列表\n- 根据qps来配置slowlog-log-slower-than\n- 及时转储slowlog\n\n## redis shell\n\n- redos-cli\n\n```sh\nredis-cli -r 3 ping # 重复执行3次ping命令\nredis-cli -r 3 -i 1 ping # 每隔1秒发一次ping 重复3此\necho \"world\" | redis-cli -x set hello # 从stdin读入 作为redis的最后一个参数\nredis-cli --scan # scan命令\nredis-cli --rdb ./bak.rdb # 生成rdb文件\necho -en '*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nhello\\r\\n$5\\r\\nworld\\r\\n*2\\r\\n$4\\r\\nincr\\r\\n$7\\r\\ncounter\\r\\n' | redis-cli --pipe # 直接发送命令给redis执行\nredis-cli --bigkeys  # 分析内存占用比较大的键值对\nredis-cli --latency # 查看客户端到目标redis的网络延时\nredis-cli --latency-history -i 10 # 每隔10秒查看一次网络延时\nredis-cli --latency-dist # 以统计图表的方式输出\nredis-cli --stat # 获取redis的统计信息\nredis-cli --raw get name # 返回数据不进行格式化(\\xexxx)\n```\n\n- redis-server\n\n```sh\nredis-server --test-memory 1024 # 测试是否有足够的内存\n```\n\n- redis-benchmark\n\n```sh\nredis-benchmark -c 100 -n 20000 # 100个客户 共请求20000次\nredis-benchmark -c 100 -n 20000  -q # 只显示 requests per second\nredis-benchmark -c 100 -n 20000 -r 10000 # -r选项会在key、counter键上加一个12位的后缀，-r10000代表只对后四位做随机处理\nredis-benchmark -c 100 -n 20000 -P 10 # 每隔请求的pipline数据量\nredis-benchmark -c 100 -n 20000 -q -k 1 # k为1代表启用客户端连接keepalive\nredis-benchmark -t get,set -q # 只对指定的命令测试\nredis-benchmark -t get,set -q --csv # 按照csv文件格式输出\n```\n\n## Pipeline\n\nPipeline（流水线）机制能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端\n\n- redis-cli 的--pipeline选项\n- 各种语言客户端的pipeline\n\n客户端和服务端的网络延时越大，Pipeline的效果越明显\n\n如果pipeline传递的数据过大 也会增加客户端的等待时间及网络阻塞\n\nvs. 原生批量命令：\n\n- 原生批量命令是原子的，Pipeline是非原子的\n- 原生批量命令是一个命令对应多个key，Pipeline支持多个命令\n- 原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现\n\n## 分布式\n\n通用集群方案：\n\n- 主备集群\n  - 全量数据同步\n- 分片集群\n\n## 线程模型\n\nredis 采用 IO 多路复用机制如 epoll 同时监听多个 socket，使用 Reactor 模型将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理\n\n```c\n// 事件处理\nint aeProcessEvents(aeEventLoop *eventLoop, int flags)\n{\n    int processed = 0, numevents;\n \n    /* 若没有事件处理，则立刻返回*/\n    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;\n    /*如果有IO事件发生，或者紧急的时间事件发生，则开始处理*/\n    if (eventLoop->maxfd != -1 || ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {\n       …\n    }\n    /* 检查是否有时间事件，若有，则调用processTimeEvents函数处理 */\n    if (flags & AE_TIME_EVENTS)\n        processed += processTimeEvents(eventLoop);\n    /* 返回已经处理的文件或时间*/\n    return processed; \n}\n```\n\n- IO事件：建立、读写连接\n- 时间事件：在主线程中执行的定时任务\n\n```mermaid\ngraph TD\n    A[bind/listen] --> B[epoll_wait]\n    B --> FD\n    B --> FD1\n    B --> FD2\n    FD --> D[AcceptEvent]\n    FD1 --> D[AcceptEvent]\n    FD2 --> D[AcceptEvent]\n    FD --> E[ReadEvent]\n    FD1 --> E[ReadEvent]\n    FD2 --> E[ReadEvent]\n    FD --> F[WriteEvent]\n    FD1 --> F[WriteEvent]\n    FD2 --> F[WriteEvent]\n    D --> 队列\n    E --> 队列\n    F --> 队列\n    队列 --> 事件分派器\n    事件分派器 --> accept\n    事件分派器 --> get\n    事件分派器 --> put\n    事件分派器 --> return\n```\n\nRedis 单线程模型指的是只有一条线程来处理命令，单线程对每个命令的执行时间是有要求的 某个命令执行过长 就会造成其他命令的阻塞\n\nRedis 的以下操作会产生阻塞\n\n- 网络IO\n- 键值对增删改查\n- 数据库操作\n- 生成RDB快照\n- 记录AOF日志\n- AOF日志重写\n- RDB传输\n- 加载RDB\n- 哈希槽扩散\n- 数据迁移\n\n如果阻塞点不在关键路径上，就可以异步执行。Redis 主线程启动后，会创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行：\n\n```c\nstatic unsigned int bio_job_to_worker[] = {\n    [BIO_CLOSE_FILE] = 0,\n    [BIO_AOF_FSYNC] = 1,\n    [BIO_CLOSE_AOF] = 1,\n    [BIO_LAZY_FREE] = 2,\n};\n// 内部通过 bioCreateXXJob后，由线程执行bioProcessBackgroundJobs方法执行具体的内容\n```\n\n6.0 之后，Redis 引入了 IO 多线程，Redis 会在初始化过程中，根据用户设置的 IO 线程数量，创建对应数量的 IO 线程，这样 Redis 在进入事件循环流程前，都会将待读写客户端以分配给 IO 线程，由 IO 线程负责读写\n\n```c\nvoid *IOThreadMain(void *myid) {\n    ...\n    while(1) {\n        ...\n        while((ln = listNext(&li))) {\n            client *c = listNodeValue(ln);\n            if (io_threads_op == IO_THREADS_OP_WRITE) {\n                writeToClient(c,0);\n            } else if (io_threads_op == IO_THREADS_OP_READ) {\n                readQueryFromClient(c->conn);\n            } else {\n                serverPanic(\"io_threads_op value is unknown\");\n            }\n        }\n        ...\n    }\n}\n```\n\n### 发现阻塞\n\n- 当Redis阻塞时，线上应用服务应该最先感知到，这时应用方会收到大量Redis超时异常，比如Jedis客户端会抛出JedisConnectionException异常\n\n此时可以进行日志记录 监控系统通过日志来进行监控报警 需要注意的是要改造Redis客户端 使其记录具体的Redis实例\n\n开源的监控系统：CacheCloud\n\n### 阻塞原因\n\n#### 内在原因\n\n- API或数据结构使用不合理\n\n有些操作的时间复杂度为O(n) 这在高并发场景是不能接受的\n\n这种情况需要重点注意**慢查询**以及**大对象** 针对它们进行优化\n\n- CPU饱和\n\n请求量很大 需要进行水平扩容来降低单实例的压力\n\n- 持久化阻塞\n\nfork阻塞：如避免使用过大的内存实例和规避fork缓慢的操作系统等\n\nAOF刷盘阻塞：当硬盘压力过大 fsync命令可能会导致阻塞\n\nHugePage写阻塞：对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB 会拖慢写操作的速度\n\n#### 外在原因\n\n- CPU竞争\n\n进程竞争：当其他进程过度消耗CPU时，将严重影响Redis吞吐量\n\nCPU绑定：如果将Redis绑定在某个核上 那么在持久化的时候子进程与父进程共存 会导致父进程可用CPU不足\n\n- 内存交换\n\n内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降\n\n- 网络问题：\n\n连接拒绝：网络闪断 连接数超过redis的最大连接数 linux文件符限制或者back_log限制导致的连接溢出\n\n网络延迟：避免物理距离过远\n\n网卡软中断：单个网卡队列只能使用一个CPU，高并发下网卡数据交互都集中在同一个CPU，导致无法充分利用多核CPU的情况\n\n### 单线程模型也能高效率的原因\n\n- 纯内存操作\n- C语言实现\n- 基于非阻塞IO多路复用\n- 单线程避免了频繁上下文切换带来的性能损失以及多线程的锁竞争问题\n\n## Redis的内存\n\n### 内存消耗\n\n内存使用统计：info memory命令\n\n属性名                      | 属性说明\n------------------------ | -------------------------------------\nused_memory              | Redis 分配器分配的内存总量，也就是内部存储的所有数据内存占用量\nused_memory_human        | 以可读的格式返回used_memory\nused_memory_rss         | 从操作系统的角度显示Redis进程占用的物理内存总量\nused_memory_peak         | 内存使用的最大值，表示used_memory 的峰值\nused_memory_peak_human | 以可读的格式返回used_memory_peak\nused_memory_lua         | Lua引擎所消耗的内存大小\nmem_fragmentation_ratio  | used_memory_rss/used_memory比值，表示内存碎片率\nmem_allocator            | Redis所使用的内存分配器。默认为jemalloc\n\n内存消耗划分：\n\n1. 对象内存 内存占用最大的一块 简单理解为sizeof（keys）+sizeof（values） 应当避免使用过长的键\n2. 缓冲内存 客户端缓存 复制积压缓冲 AOF缓冲等\n3. 内存碎片 默认的内存分配器采用jemalloc，可选的分配器还有：glibc、tcmalloc 频繁更新以及过期键的删除会使碎片率上升 使用整齐的是数据结构减少碎片 或者使用高可用架构重启服务器来整理内存碎片，4.0后通过将 activedefrag 配置项设置为 yes 来让 Redis 自动清理内存碎片\n\n子进程内存消耗：\n\nRedis产生的子进程并不需要消耗1倍的父进程内存，实际消耗根据期间写入命令量决定，但是依然要预留出一些内存防止溢出\n\n### 内存管理\n\n**Redis默认无限使用服务器内存**\n\n设置内存上限：maxmemory配置项 限制的是Redis实际使用的内存量，也就是used_memory统计项对应的内存\n\n动态调整内存上限：`config set maxmemory`\n\n#### 内存回收\n\n删除过期键对象：\n\n- 惰性删除 当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空 虽然节省CPU 但存在过期对象无法及时回收 内存泄漏的问题\n- 定时任务删除 Redis内部维护一个定时任务，默认每秒运行10次\n\n```mermaid\ngraph TD\n  默认采用慢模式运行 --> 每个数据库空间随机检查20个键\n  每个数据库空间随机检查20个键 --> A{是否超过25%的键过期}\n  A --> |yes| 循环执行\n  A --> |no| 退出\n  循环执行 --> B{执行时间超过25ms}\n  B --> |yes| 每次Redis事件之前采用快模式运行\n  B --> |no| 退出\n```\n\n循环执行指的是执行回收逻辑 直到不足25%或运行超时为止\n\n- 快模式：Redis 会将过期键的清理工作推迟到 事件循环的空闲时间，这样主线程就可以在忙碌的周期内继续处理其他任务\n- 慢模式：如果在这次检查中发现有超过 25% 的键已过期，Redis 会继续执行检查，并随机抽取更多的键进行判断，直到完成一定的检查量。这个过程可能会持续较长时间\n\n内存溢出淘汰策略：设置内存最大使用量，当内存使用量超出时，会执行数据淘汰策略\n\n策略              | 描述\n--------------- | --------------------------\nvolatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰（**最常用**）。< 3.0 的默认策略\nvolatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰\nvolatile-random | 从已设置过期时间的数据集中任意选择数据淘汰\nvolatile-lfu    | 从已设置过期时间的数据集中挑选访问频率最低的数据淘汰\nallkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰\nallkeys-random  | 从所有数据集中任意选择数据进行淘汰\nallkeys-lfu     | 从所有数据集中挑选访问频率最低的数据淘汰\nnoeviction      | 禁止驱逐数据，当内存不足时，写入操作会被拒绝。 >= 3.0 的默认策略\n\n内存溢出淘汰策略可以采用config set maxmemory-policy{policy}动态配置\n\n对于 lru 算法：在 redisObject 结构体中，有个 24 位的 lru 字段（秒级），这个记录了一个时间戳，每次操作 key 该字段都会被更新，当内存不足，Redis 会随机从全局哈希表中找出过期的 key，把这些 key 删除\n\n对于 lfu：lru 字段存储了 16 位的时间（分钟级），以及 8 位的访问次数，当键值对被再次访问时，lru 变量中的访问次数，会先根据上一次访问距离当前的时长，执行衰减操作，然后才按照一定的概率对访问次数进行增加，访问次数越大，执行增加操作的概率越小，在淘汰数据时，访问次数越小，就容易被淘汰\n\n#### 缩减键值对象\n\n设计键时，在完整描述业务情况下，键值越短越好 值对象尽量选择更高效的序列化工具进行压缩\n\n#### 共享对象池\n\n当数据大量使用[0-9999]的整数时，共享对象池可以节约大量内存\n\n当启用LRU相关淘汰策略如：volatile-lru，allkeys-lru时，Redis禁止使用共享对象池\n\n#### 编码优化\n\n通过不同编码实现效率和空间的平衡\n\n编码转换的流程：\n\n```mermaid\ngraph TB\n  hset --> A{判断当前编码类型}\n  A --> |hashtable| hashtable编码\n  A --> |ziplist| B{判断新数据长度 hash-max-ziplist-value}\n  B --> |大于| hashtable编码\n  B --> |小于等于| C{比较集合长度 hash-max-ziplist-entries}\n  C --> |大于| hashtable编码\n  C --> |小于等于| ziplist编码\n```\n\n#### 控制键的数量\n\n对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存\n\n对于需要对如hash的内部数据进行过期处理 就必须通过外部定时任务扫描的方式来进行过期处理\n\n## 整合Lua\n\n```sh\nredis-cli eval \"return 1+1\" 0\n```\n\n- 在redis-cli中\n\n```sh\nEVAL \"local msg='hello world' return msg..KEYS[1]\" 1 AAA BBB\n```\n\n- 独立文件\n\n```lua\nlocal count = redis.call(\"get\", \"count\")\nredis.call(\"incr\",\"count\")\nreturn count\n```\n\n```sh\nredis-cli --eval test.lua 0\n```\n\n### 部署\n\n加载到redis\n\n```sh\nredis-cli script load \"$(cat test.lua)\"\n```\n\n得到sha1值\n\n执行\n\n```sh\nredis-cli evalsha \"7a2054836e94e19da22c13f160bd987fbc9ef146\" 0\n```\n\n### lua脚本管理\n\n- script load\n- script exists\n- script flush\n- script kill\n\n## redis运维\n\n### Linux配置优化\n\n- vm.overcommit_memory：内存分配策略\n\n值 | 含义\n-| -\n0 | 表示内核将检查是否有足够的可用内存。如果有足够的可用内存，内存申请通过，否则内存申请失败，并把错误返回给应用进程\n1 | 表示内核允许超量使用内存直到用完为止\n2 | 表示内核决不过量的( \"never overcommit\")使用内存，即系统整个内存地址空间不能超过swap+50%的RAM值，50%是overcommit ratio默认值，此参数同样支持修改\n\n- swappiness：值越大，说明操作系统可能使用swap的概率越高\n\n值   | 策略\n--- | -------------------------------------------------------------------\n0   | Linux3.5以及以上:宁愿用OOM killer也不用swap，Linux3.4以及更早:宁愿用swap也不用OOM killer\n1   | Linux3.5以及以上:宁愿用swap也不用OOM killer\n60  | 默认值\n100 | 操作系统会主动地使用swap\n\n\n- THP特性：支持大内存页（2MB）分配，默认开启。当开启时可以降低fork子进程的速度，但fork操作之后，每个内存页从原来4KB变为2MB，会大幅增加重写期间父进程内存消耗 **建议关闭**\n\n- OOM killer会在可用内存不足时选择性地杀掉用户进程 会为每个用户进\n程设置一个权值，这个权值越高，被“下手”的概率就越高\n\n- 使用NTP（网络时间协议）来避免异常情况下的日志排查困难\n- ulimit 设置同时打开的最大文件个数\n- TCP backlog \n\n### 删库补救\n\n持久化文件是恢复数据的媒介\n\n误操作之后大调 AOF 重写参数 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size，让Redis不能产生AOF自动重写\n\n以及拒绝手动 bgrewriteaof\n\n### 安全\n\n- requirepass配置为Redis提供密码功能\n- rename-command伪装危险命令\n- bind指定Redis和哪个网卡进行绑定\n\n### bigkey处理\n\nbigkey是指key对应的value所占的内存空间比较大\n\n- 可能造成内存倾斜\n- 大key会造成操作阻塞或者网络阻塞\n\n使用redis-cli --bigkeys统计bigkey\n\n### 热点key\n\n- 客户端计数\n- 代理端计数\n- 服务端monitor命令输出统计 高并发情况下会有性能问题\n- 通过TCP网络抓包进行统计\n\n### 性能诊断checklist\n\n1. 获取 Redis 实例在当前环境下的基线性能\n2. 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做\n3. 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除\n4. 是否存在 bigkey？ 对于 bigkey 的删除操作，如果 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成\n5. Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘\n6. Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况\n7. 在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了\n8. 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞\n9. 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上\n\n## 监控\n\nRedis 会对 命令事件、AOF事件、fork事件、过期key事件、缓存替换事件 这些延迟事件的执行情况进行记录\n\n内部记录了一个事件的最大延迟以及一段时间内的延迟历史\n\n```c\nstruct latencySample {\n    int32_t time; /* We don't use time_t to force 4 bytes usage everywhere. */\n    uint32_t latency; /* Latency in milliseconds. */\n};\n\n/* The latency time series for a given event. */\nstruct latencyTimeSeries {\n    int idx; /* Index of the next sample to store. */\n    uint32_t max; /* Max latency observed for this event. */\n    struct latencySample samples[LATENCY_TS_LEN]; /* Latest history. */\n};\n```\n\n\n## redis vs memcached\n\n- redis支持复杂的数据结构\n- redis支持原生集群\n- redis 只使用单核，而 memcached 可以使用多核\n","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2024-12-16T19:56:39+08:00","author":"MY","message":"📦Redis","hash":"61d91e611dc55e7d92017abf8196d274cc12ca80"},{"date":"2024-11-20T14:24:23+08:00","author":"MY","message":"📦Redis","hash":"b64df2e87e14f86576fb82cc7b57e6b452aba69c"},{"date":"2023-12-13T19:40:21+08:00","author":"MY","message":"✏Redis","hash":"642b342a819421f389fef3a4e72f0ad641fe9c84"},{"date":"2023-12-11T19:59:23+08:00","author":"MY","message":"✏Redis","hash":"2f7e29a08817db6f3ce12f5fc78d44c23e8b1412"},{"date":"2023-12-07T20:05:48+08:00","author":"MY","message":"✏Redis","hash":"c242f11d707286af0133546d8d7c203ac219c28d"},{"date":"2023-12-06T19:59:46+08:00","author":"MY","message":"✏Redis","hash":"e0d5cfa5358133bd93587d26f55ff78955214b42"},{"date":"2023-11-21T20:11:59+08:00","author":"MY","message":"✏Redis","hash":"cb2689a2888eb05d909e7ba4caed644b192ce8a2"},{"date":"2023-11-20T20:05:41+08:00","author":"MY","message":"✏Redis","hash":"e10f240636511dc53c5ea31e7bc7f8f540a75414"},{"date":"2023-11-17T16:08:50+08:00","author":"MY","message":"✏Redis","hash":"d29fc4e4c292a10d3dde9449cbc5c04bca349d25"},{"date":"2023-11-16T18:57:34+08:00","author":"MY","message":"✏Redis","hash":"7955ae3a5874322931281a113be629782a29c57a"}],"createTime":"2020-11-05T16:53:44+08:00"}