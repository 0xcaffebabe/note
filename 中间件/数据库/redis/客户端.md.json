{"name":"客户端","id":"中间件-数据库-redis-客户端","content":"## 客户端\n\n### RESP(redis 序列化协议)\n\n- 发送命令\n\n```\n*< 参数数量 > CRLF\n$< 参数 1 的字节数量 > CRLF\n< 参数 1> CRLF\n...\n$< 参数 N 的字节数量 > CRLF\n< 参数 N> CRLF\n```\n\n- 返回结果\n\n状态回复：在RESP中第一个字节为\"+\"。\n\n错误回复：在RESP中第一个字节为\"-\"。\n\n整数回复：在RESP中第一个字节为\"：\"。\n\n字符串回复：在RESP中第一个字节为\"$\"。\n\n多条字符串回复：在RESP中第一个字节为\"*\"。\n\n###  java 客户端 Jedis\n\n基本使用\n\n```java\nJedis jedis = new Jedis(\"127.0.0.1\");\n\njedis.set(\"name\",\"my\");\nSystem.out.println(jedis.get(\"name\"));\njedis.close();\n```\n\n连接池\n\n```java\nJedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxIdle(15);\nconfig.setMaxTotal(30);\n\nJedisPool pool = new JedisPool(config);\n\nJedis resource = pool.getResource();\nSystem.out.println(resource.ping());\nresource.close();\n\npool.close();\n```\n\n### Spring Data Redis\n\nRedisTemplate基本操作\n\n- redisTemplate.opsForValue() ：操作字符串\n- redisTemplate.opsForHash() ：操作hash\n- redisTemplate.opsForList()：操作list\n- redisTemplate.opsForSet()：操作set\n- redisTemplate.opsForZSet()：操作zset\n\nStringRedisTemplate是K,V均为String的RedisTemplate\n\n使用\n\n```java\ntemplate.opsForValue().set(\"name\",\"hello,bitch\");\n```\n\n### 事务\n\n```sh\nmulti # 开启事务\nset name hello\nset hello world\nexec # 提交事务\n# discard 停止事务执行\n```\n\n命令语法错误导致的错误整个事务会回滚\n\n```sh\nset key java\nwatch key\nmulti\nset key cxk\nexec # 如果key在这个事务过程中别其他客户端修改 这个事务就不会执行\n```\n\n```java\n// 开启事务支持\ntemplate.setEnableTransactionSupport(true);\ntry{\n    // begin\n    template.multi();\n    // 事务中的多个命令被一次性发送给服务器\n    template.opsForValue().set(\"java\",\"langeuage\");\n    template.opsForValue().set(\"python\",\"langeuage\");\n    // commit\n    template.exec();    \n}catch (Exception e){\n    template.discard();\n}\n```\n\n### 客户端管理\n\n```sh\nclient list\n```\n```\nid=10733 addr=127.0.0.1:42158 fd=9 name= age=84021 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client user=default\n```\n\n序号|参数|含义\n-|-|-\n1|id|客户端连接id\n2|addr|客户端连接P和端口\n3|fd|socket的文件描述符\n4|name|客户端连接名\n5|age|客户端连接存活时间\n6|idle|客户端连接空闲时间\n7|flags|客户端类型标识\n8|db|当前客户端正在使用的数据库索引下标\n9|sub/psub|当前客户端订阅的频道或者模式数\n10|multi|当前事务中已执行命令个数\n11|gbuf|输入缓冲区总容量\n12|gbuf-free|输入缓冲区剩余容量\n13|obl|固定缓冲区的长度\n14|oll|动态缓冲区列表的长度\n15|omem|固定缓冲区和动态缓冲区使用的容量\n16|events|文件描述符事件(r/w):r和w分别代表客户端套接字可读和可写\n17|cmd|当前客户端最后一次执行的命令，不包含参数\n\n标识：\n\n- id\n- addr\n- fd\n- name\n\n输入缓冲区：\n\nRedis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时Redis从会输入缓冲区拉取命令并执行\n\n- qbuf 缓冲区的总容量\n- qbuf-free 剩余容量\n\n如果Redis的处理速度跟不上输入缓冲区的输入速度 机会造成缓冲区十分大\n\n输出缓冲区：\n\nRedis为每个客户端分配了输出缓冲区，它的作用是保存命令执行的结果返回给客户端\n\n输出缓冲区由两部分组成：固定缓冲区（16KB）和动态缓冲区，其中固定缓冲区返回比较小的执行结果，而动态缓冲区返回比较大的结果。 固定缓冲区使用的是字节数组，动态缓冲区使用的是列表\n\n- obl 固定缓冲区的长度\n- oll 动态缓冲区列表的长度\n- omem 代表使用的字节数\n\n客户端存活状态：\n\n单位为秒\n\n- age 客户端已经连接的时间\n- idle 最近一次的空闲时间\n\n客户端类型：\n\n- flag\n\n序号|客户端类型|说明\n-|-|-\n1|N|普通客户端\n2|M|当前客户端是master节点\n3|S|当前客户端是slave节点\n4|O|当前客户端正在执行monitor命令\n5|X|当前客户端正在执行事务\n6|b|当前客户端正在等待阻塞事件\n7|i|当前客户端正在等待VM I/O,但是此状态目前已经废弃不用\n8|d|一个受监视的键已被修改，EXEC命令将失败\n9|u|客户端未被阻塞\n10|c|回复完整输出后，关闭连接\n11|A|尽可能快地关闭连接\n\n#### setName getName\n\n设置名称方便管理\n\n```sh\nclient setName cxk\nclient getName\n```\n\n#### 杀掉客户\n\n```sh\nclient kill ip:port\n```\n\n#### 阻塞客户\n\n```sh\nclient pause timeout # 阻塞当前客户端指定毫秒数\n```\n\n#### 监控客户端命令执行\n\n```sh\nmonitor\n```\n\n### 客户端相关配置\n\n- timeout 检测客户端空闲连接的超时时间，一旦idle时间达到了\ntimeout，客户端将会被关闭，如果设置为0就不进行检测\n- maxclients 客户端最大连接数\n- tcp-keepalive 检测TCP连接活性的周期\n- tcp-backlog TCP三次握手后，会将接受的连接放入队列中，tcp-backlog就是队列的大小\n\n### 客户端统计\n\n```sh\ninfo clients\n```\n\n- connected_clients：代表当前Redis节点的客户端连接数\n- client_recent_max_input_buffer：当前所有输出缓冲区中队列对象个数的最大值\n- client_recent_max_output_buffer: 前所有输入缓冲区中占用的最大容量\n- locked_clients：正在执行阻塞命令（例如blpop、brpop、brpoplpush）的客户端个数","metadata":"","hasMoreCommit":false,"totalCommits":2,"commitList":[{"date":"2023-12-06T19:59:46+08:00","author":"MY","message":"✏Redis","hash":"e0d5cfa5358133bd93587d26f55ff78955214b42"},{"date":"2020-11-05T16:53:44+08:00","author":"MY","message":"📦重构 Redis","hash":"436d256214f45aea37f8659d4758b82fe1709560"}],"createTime":"2020-11-05T16:53:44+08:00"}