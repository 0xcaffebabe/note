{"name":"数据结构","id":"中间件-数据库-redis-数据结构","content":"# 数据结构\n\n二进制安全：底层没有类型概念，只有byte数组，所以客户端需要将数据序列化成字节数组\n\n## string\n\n- 字符串、数值、bit位图\n\n![屏幕截图 2020-09-24 142014](/assets/屏幕截图%202020-09-24%20142014.png)\n\n![内部编码](/assets/20231116165231.webp)\n\n应用场景：\n\n- 做简单的KV缓存\n\n```mermaid\nsequenceDiagram\n    participant User as 用户\n    participant WebServer as Web服务器\n    participant Redis as 缓存层 (Redis)\n    participant MySQL as 持久层 (MySQL)\n    \n    User->>WebServer: 请求数据\n    WebServer->>Redis: 查询缓存\n    alt hit\n        Redis-->>WebServer: return 缓存数据\n    else miss\n        Redis->>MySQL: 查询数据库\n        MySQL-->>Redis: 数据结果\n        Redis->>Redis: write cache\n        Redis-->>WebServer: 缓存数据\n    end\n    WebServer-->>User: return 数据响应\n```\n\n设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用`业务名：对象名：id：[属性]`作为键名\n\n- incr（计数）：抢购，秒杀，详情页，点赞，评论\n- session服务器\n\n```mermaid\nstateDiagram-v2\n  client --> WebServer1\n  RedisSession --> WebServer1\n  WebServer1 --> RedisSession\n  WebServer2 --> RedisSession\n  RedisSession --> WebServer2\n  WebServer3 --> RedisSession\n  RedisSession --> WebServer3\n```\n\n- 限速 通过对key设置过期时间的方式限制用户请求频率\n- 使用位图来处理海量数据\n\n1. 哈希类型 hash\n  - 做对象属性读写\n2. 列表类型 list\n  - 可以做消息队列或者可以来存储列表信息，进行分页查询\n3. 集合类型 set\n  - 自动去重\n  - 推荐系统：数据交集\n4. 有序集合类型 sortedset\n  - 排序\n\n## GEO\n\n地理信息定位功能\n\n```sh\ngeoadd locations 116.38 39.55 beijing # 添加成员\ngeopos locations beijing # 获取\ngeodist locations beijing tianjin [m|km|mi|ft] # 计算两地距离\ngeoradiusbymember locations beijing 150 km # 获取北京方圆150km内的成员\ngeohash locations beijing # 将二维经纬度转换为一维字符串\n```\n\n关于geohash：\n\n- 字符串越长，表示的位置更精确\n- 两个字符串越相似，它们之间的距离越近，Redis利用字符串前缀匹配\n算法实现相关的命令\n- Redis正是使用有序集合并结合geohash的特性实现了GEO的若干命令\n\n## [发布订阅](/软件工程/设计模式/行为模式.md#观察者)\n\n新开启的订阅客户端，无法收到该频道之前的消息\n\n```sh\npubsub channels # 查看活跃的频道(至少一个订阅者)\npubsub numsub chat # 查看频道订阅数\npubsub numpat # 查看模式订阅数\n```\n\n- 消费者\n\n```sh\nSUBSCRIBE redisChat # 订阅\nunsubscribe redisChat # 取消订阅\npsubscribe pattern # 按照给定模式订阅\npunsubscribe pattern # 按照给定模式取消订阅\n```\n\n- 生产者向频道发送数据\n\n```sh\nPUBLISH redisChat \"Redis is a great caching technique\"\n```\n\npub/sub 是通过一个 key 为频道名称，value 为客户端列表的哈希表、客户端所订阅的频道模式哈希表来实现的\n\n```c\nserver.pubsub_channels = dictCreate(&keylistDictType);\nserver.pubsub_patterns = dictCreate(&keylistDictType);\nserver.pubsubshard_channels = dictCreate(&keylistDictType);\n```\n\n在发送消息时，通过频道名称找到所有客户端，或者判断客户端所订阅的频道模式是否匹配发消息的频道，找到对应的客户端，挨个发消息\n\n```c\nwhile((de = dictNext(di)) != NULL) {\n    robj *pattern = dictGetKey(de);\n    list *clients = dictGetVal(de);\n    if (!stringmatchlen((char*)pattern->ptr,\n                        sdslen(pattern->ptr),\n                        (char*)channel->ptr,\n                        sdslen(channel->ptr),0)) continue;\n    listRewind(clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        client *c = listNodeValue(ln);\n        addReplyPubsubPatMessage(c,pattern,channel,message);\n        updateClientMemUsageAndBucket(c);\n        receivers++;\n    }\n}\n```\n\n而客户端订阅频道，则就是对上述的哈希表做添加操作\n\n```c\nif (dictAdd(type.clientPubSubChannels(c),channel,NULL) == DICT_OK) {\n    retval = 1;\n    incrRefCount(channel);\n    /* Add the client to the channel -> list of clients hash table */\n    de = dictFind(*type.serverPubSubChannels, channel);\n    if (de == NULL) {\n        clients = listCreate();\n        dictAdd(*type.serverPubSubChannels, channel, clients);\n        incrRefCount(channel);\n    } else {\n        clients = dictGetVal(de);\n    }\n    listAddNodeTail(clients,c);\n}\n/* Notify the client */\naddReplyPubsubSubscribed(c,channel,type);\n```\n\n\n## 内部数据结构\n\nRedis 为了尽量节省内存，不仅在数据结构的设计上下足了功夫，同时也运用了享元设计模式来提升内存效率\n\n```mermaid\nstateDiagram-v2\n  String --> 简单动态字符串(SDS)\n  List --> 双向链表\n  List --> 压缩链表\n  Hash --> 压缩列表\n  Hash --> 哈希表\n  SortedSet --> 压缩链表\n  SortedSet --> 跳表\n  Set --> 哈希表\n  Set --> 整数数组\n```\n\n名称|查找时间复杂度\n-|-\n哈希表|0(1)\n跳表|O(logN)\n双向链表|O(N)\n压缩列表|O(N)\n整数数组|O(N)\n\n### redisObject\n\nRedis存储的所有值对象在内部定义为redisObject结构体\n\n```c\nstruct {\n  type // 表示当前对象使用的数据类型\n  encoding // 代表当前对象内部采用哪种数据结构实现\n  lru // 记录对象最后一次被访问的时间\n  refcount // 记录当前对象被引用的次数 Redis可以使用共享对象的方式来节省内存\n  *ptr // 如果是整数，直接存储数据；否则表示指向数据的指针 如果对象是字符串且长度<=44字节的会直接存储在这 避免间接内存操作\n}\n```\n\n### SDS\n\n和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销\n\n同时 SDS 设计了针对不同长度字符串的结构头，是为了能灵活保存不同大小的字符串，从而有效节省内存空间\n\n```c\n// __attribute__ ((__packed__)) 告诉编译器取消结构体内存对齐，可以减少内存消耗，但可能会导致访问结构体成员时效率降低\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n```\n\n对于长度不超过 44 字节的字符串，Redis 先申请一块连续的内存空间，把 redisObject 结构体和 SDS 结构体紧凑地放置在一起，避免内存碎片和两次内存分配的开销\n\n```c\nrobj *createEmbeddedStringObject(const char *ptr, size_t len) {\n    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);\n    struct sdshdr8 *sh = (void*)(o+1);\n    ...\n    o->ptr = sh+1;\n    ...\n\n    //... 初始化字符串空间\n    return o;\n}\n```\n\n### 字典\n\nredis 使用了链表来应对哈希冲突\n\n```c\ntypedef struct dictIterator {\n    dict *ht;\n    int index;\n    dictEntry *entry, *nextEntry;\n} dictIterator;\ntypedef struct dict {\n    dictEntry **table;\n    dictType *type;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n    void *privdata;\n} dict;\nstruct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    struct dictEntry *next;     /* Next entry in the same hash bucket. */\n};\n```\n\nredis使用了两张哈希表来方便扩容时的rehash操作\n\n当满足以下条件，就会进行rehash\n\n- 刚开始时哈希表长度为0\n- 哈希表中的元素数量 / 哈希表长度 > dict_force_resize_ratio(负载因子)\n\n在进行rehash时，为避免给服务器带来过大负担，并不是一次性将所有值rehash到另外一张表，而是通过渐进的方式，每次对字典执行添加、删除、查找或者更新操作时，将哈希表 entry 的转移操作分散在后续的每一次请求中以及定时任务中，而非一次性执行完。每迁移一个 key，结构体 dict 的 used就会 - 1，当这个used为0时，就代表迁移完了\n\n此时新增的 key 都会写到目标ht中，而删改则会先对迁移源表找，没有的话再在新ht中找\n\n### 压缩列表\n\n数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束\n\n针对不同长度的数据，使用不同大小的元数据信息（prevlen 和 encoding）来描述每一个位置的数据，从而提升内存效率\n\n如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位\n\n虽然 ziplist 节省了内存开销，可它也存在两个设计代价：一是不能保存过多的元素，否则访问性能会降低；二是不能保存过大的元素，否则当一个元素插入后，会引起当前位置元素新增 prevlensize 的空间。而当前位置元素的空间增加后，又会进一步引起该元素的后续元素，其 prevlensize 所需空间的增加\n\n### SortedSet\n\nSorted Set 能支持范围查询，这是因为它的核心数据结构设计采用了跳表，而它又能以常数复杂度获取元素权重，这是因为它同时采用了哈希表进行索引\n\n```c\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n```\n\n### quicklist\n\n一个 quicklist 就是一个链表，而链表中的每个元素又是一个 ziplist。quicklist 通过控制每个 quicklistNode 中，ziplist 的大小或是元素个数，就有效减少了在 ziplist 中新增或修改元素后，发生连锁更新的情况\n\n```c\ntypedef struct quicklist {\n    quicklistNode *head;\n    quicklistNode *tail;\n    unsigned long count;        /* total count of all entries in all listpacks */\n    unsigned long len;          /* number of quicklistNodes */\n    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */\n    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */\n    unsigned int bookmark_count: QL_BM_BITS;\n    quicklistBookmark bookmarks[];\n} quicklist;\ntypedef struct quicklistNode {\n    struct quicklistNode *prev;\n    struct quicklistNode *next;\n    unsigned char *entry;\n    size_t sz;             /* entry size in bytes */\n    unsigned int count : 16;     /* count of items in listpack */\n    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */\n    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */\n    unsigned int recompress : 1; /* was this node previous compressed? */\n    unsigned int attempted_compress : 1; /* node can't compress; too small */\n    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */\n    unsigned int extra : 9; /* more bits to steal for future usage */\n} quicklistNode;\n```\n\n### listpack\n\n紧凑列表，它的特点就是用一块连续的内存空间来紧凑地保存数据，同时为了节省内存空间，listpack 列表项使用了多种编码方式，来表示不同长度的数据，这些数据包括整数和字符串\n\nlistpack 中每个列表项不再包含前一项的长度了，因此当某个列表项中的数据发生变化，导致列表项长度变化时，其他列表项的长度是不会受影响的\n\n### rax\n\n一种前缀树的变体，如果一系列单字符节点之间的分支连接是唯一的，那么这些单字符节点就可以合并成一个节点，而这种结构的树，就正是 Radix Tree，也被称为基数树\n\n```mermaid\nstateDiagram-v2\n  g --> o\n  o --> l\n  l --> d\n  o --> s\n  s --> e\n```\n```mermaid\nstateDiagram-v2\n  go --> ld\n  go --> se\n```\n\n## 操作复杂度\n\n- 集合类型对单个数据实现的增删改查操作，复杂度由集合采用的数据结构决定，如 Hash 的增加查找都是O(1)\n- 集合类型中的遍历操作，返回集合中的所有数据，这类操作的复杂度一般是 O(N)\n- 集合类型对集合中所有元素个数的记录，复杂度为 O(1)，因为这些结构中专门记录了元素的个数统计\n- 还有一些特殊情况，压缩列表和双向链表都会记录表头和表尾的偏移量，所以POP PUSH 操作也为 O(1)\n\n","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2024-02-20T19:15:31+08:00","author":"MY","message":"✏查找","hash":"03ecf112bbc77ebde7f8d3b54d923f5a82cff6fc"},{"date":"2023-12-11T19:59:23+08:00","author":"MY","message":"✏Redis","hash":"2f7e29a08817db6f3ce12f5fc78d44c23e8b1412"},{"date":"2023-12-06T19:59:46+08:00","author":"MY","message":"✏Redis","hash":"e0d5cfa5358133bd93587d26f55ff78955214b42"},{"date":"2023-12-05T20:02:47+08:00","author":"MY","message":"✏Redis","hash":"78cace37fb999236c4b5cc5388eceff451ae6ba9"},{"date":"2023-12-04T20:11:23+08:00","author":"MY","message":"✏Redis","hash":"2e6abfc4b006dede4dfe01594783b5c15659663b"},{"date":"2023-11-20T20:05:41+08:00","author":"MY","message":"✏Redis","hash":"e10f240636511dc53c5ea31e7bc7f8f540a75414"},{"date":"2023-11-17T16:08:50+08:00","author":"MY","message":"✏Redis","hash":"d29fc4e4c292a10d3dde9449cbc5c04bca349d25"},{"date":"2023-11-16T18:57:34+08:00","author":"MY","message":"✏Redis","hash":"7955ae3a5874322931281a113be629782a29c57a"},{"date":"2023-11-14T19:03:07+08:00","author":"MY","message":"✏Redis","hash":"ec82d21abc19ca666985861dd73bef564c0d7618"},{"date":"2022-07-13T11:35:15+08:00","author":"cjiping","message":"✏️更新 跳表","hash":"ea1f2a30bb6b6a63448c33a72d27663acea57b57"}],"createTime":"2020-11-05T16:53:44+08:00"}