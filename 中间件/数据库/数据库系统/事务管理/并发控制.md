# 并发控制

## 封锁

### 封锁粒度

锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高
封锁粒度越小，系统开销就越大

### 封锁类型

#### 读写锁

- 共享锁：简写为S锁，可读不可写
- 排它锁：简写为X锁，可读可写

加了排它锁的数据，就只能允许加锁的事务进行读写
加了共享锁的数据，允许其他事务对其再加共享锁进行读，但不允许再加排它锁

#### 意向锁

意向锁在读写锁的基础上，增加了IX（表的排它锁）与IS（表的共享锁）

- 当一个事务要对数据加S锁之前，就必须获得IS锁或者IX锁
- 当一个事务要对数据加X锁之前，必须获得IX锁

### 封锁协议

#### 三级封锁协议

- 一级封锁协议

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁

![批注 2020-03-08 201422](/assets/批注%202020-03-08%20201422.png)

- 二级封锁协议

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁

![批注 2020-03-08 201650](/assets/批注%202020-03-08%20201650.png)

- 三级封锁协议

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁

![批注 2020-03-08 201840](/assets/批注%202020-03-08%20201840.png)

#### 两阶段封锁协议

加锁和解锁分为两个阶段进行

- 增长阶段：可以获得锁，不能释放锁
- 缩减阶段：可以释放锁，不能获得锁

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定

- 封锁的实现

- 基于图的协议

# 死锁处理

- 死锁预防

  - 对加锁请求进行排序
  - 有可能导致死锁时，进行事务回滚

**锁超时**

- 死锁检测与恢复

  - 等待图
  - 恢复

    - 选择牺牲者
    - 回滚
    - 饿死

# 多粒度

# 基于时间戳的协议

- 时间戳
- 时间戳排序协议
- Thomas写规则

# 基于有效性检查的协议

# 多版本机制

## 多版本并发控制

MVCC（Multi-Version Concurrency Control） 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系

### undo日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

上面的三条sql对应于三个事务

![批注 2020-03-08 203234](/assets/批注%202020-03-08%20203234.png)

### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表

![批注 2020-03-08 203401](/assets/批注%202020-03-08%20203401.png)

## 多版本时间戳排序

## 多版本两阶封锁

# 快照隔离

# 插入操作、删除操作与谓词读

# 实践中的弱一致性级别

# 索引结构中的并发
