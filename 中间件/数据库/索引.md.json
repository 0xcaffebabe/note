{"name":"索引","id":"中间件-数据库-索引","content":"# 索引\n\n![RUM 猜想](/assets/20244214372.webp)\n\n对任何数据结构来说，在 Read Overhead（读）、Update Overhead（写） 和 Memory or Storage Overhead（存储） 中，同时优化两项时，需要以另一项劣化作为代价\n\n## 为什么使用索引\n\n1. 大大减少了服务器需要扫描的数据量\n2. 帮助服务器避免排序和临时表\n3. 将随机io变成顺序io\n\n![索引的原理](/assets/屏幕截图%202020-08-27%20093235.png)\n\n## 索引用处\n\n1. 快速查找匹配WHERE子句的行\n2. 从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引\n3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行\n4. 当有表连接的时候，从其他表检索行数据\n5. 查找特定索引列的min或max值\n6. 如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组\n7. 在某些情况下，可以优化查询以检索值而无需查询数据行\n\n## 索引使用条件\n\n- 小表全表扫描效率优于索引\n- 索引适合中大型表\n- 特大型表，建立和维护索引的代价将会随之增长\n\n### 评价\n\n索引好坏的评价维度\n\n- 访问类型：是否支持范围访问、特定值访问\n- 访问时间\n- 插入时间\n- 删除时间\n- 空间开销\n\n## 一些索引数据结构\n\n- hash（散列索引）\n  - 可以直接根据key访问\n  - **但是无法进行范围查询**\n- avl（顺序索引）\n  - 平衡二叉树，左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1\n  - 支持范围查询\n  - **插入操作可能需要旋转，效率低**\n- b+树（顺序索引）\n\n## 散列索引\n\n要求全部的索引要能放入内存\n\n- 静态散列\n- 动态散列：散列函数、桶大小可以动态改变，性能不随文件增长降低。空间开销小。并且增加了一个中间层，带来微小的性能损失。\n\n![动态散列](/assets/截屏2023-04-06%2021.24.06.png)\n\n## 位图索引\n\n```sql\n\n性别_男= 10010101\n性别_女= 01101010\n\n区_朝阳= 00000100\n```\n\n当要获取朝阳的男的时候，将两个向量相与，结果为1的位置的数据，就是搜索命中的结果\n\n### 位图操作的高效实现\n\n### 位图与B+树\n\n采用传统的 B+ 树建立索引，如果数据区分度很低，则B+树效率也不高\n\n## 顺序索引\n\n- 稠密索引: 每个属性都有一个索引项\n- 稀疏索引: 只为某些属性建立索引\n\n![稠密索引与稀疏索引](/assets/屏幕截图%202022-04-28%20173324.png)\n\n### 多级索引\n\n![多级索引](/assets/2022428173815.png)\n\n- 通过将一级索引表放置在内存中加快搜索速度\n\n### 索引的更新\n\n#### 插入新记录\n\n对于稠密索引：如果该索引值不存在于索引中，则在合适的位置插入索引值，如果存在于索引中，则找到索引值对应的记录链表，在链表尾部追加新记录\n\n对于稀疏索引：在合适的索引值范围内添加新记录\n\n#### 删除记录\n\n对于稠密索引：如果该记录时该索引值的唯一记录，删除即可。否则执行链表的节点删除操作\n\n对于稀疏索引：如果包含了索引值，则删除索引值对应的记录，并调整索引范围\n\n### 辅助索引\n\n在索引与实际记录之间的一个中间层，也就是非聚簇索引，索引的不是物理位置，而是根据某些列的值建立的一个独立的数据结构\n\n![2022428174651](/assets/2022428174651.png)\n\n## B树\n\n![202271210518](/assets/202271210518.webp)\n\n2-3 树是一种特殊的 B- 树\n\n- B 树的叶子结点跟非叶子结点都会存储数据\n- B 树不像 B+ 树，叶子节点会通过指针串连在一起\n\n## B+树\n\n在 B+ 树中查找不管成功还是失败，每次查找都要沿着从根节点到叶节点的路径进行。这意味着查找任何数据速度都差不多\n\nB 树减少了定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统\n\nB+树中叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value\n\n所有叶子节点位于同一层，之间会通过双向指针串联在一起，构成一个双向链表\n\n![批注 2020-03-10 192507](/assets/批注%202020-03-10%20192507.png)\n\nB+ 树可以让整个树状结构变得更加矮胖，而磁盘的预读特性每次都可以加载一整个节点中全部的键，到内存进行二分查找。同时叶子节点都被串联起来了，适合范围查询，非叶子结点没有存放数据，适合放到内存当中\n\n如果出现了两条或者多条记录在索引属性上拥有相同的值，解决方法：\n\n- 创建包含原始搜索码和其他额外属性的符合搜索码\n- 在B+树节点上使用列表来存储\n\nMySQL 中，一个页就是 B+ 树的一个节点，一个页的大小最大为 16K。因为非叶子节点保存的是主键值 + 指针，假设主键值类型是 __int64（占 8 字节），指针占 6 字节，一共 14 字节，那么一个页 16K（16384 字节）如果存满则大概可以保存下 1170 个“主键值 + 指针”对（16384/14=1170），假如每一条记录的大小为 1k，那么一个节点就能容纳 16 条记录，所以一个三层的 B+ 树能容纳 $1170 * 1170 * 16  = 21902400$\n\n### 文件结构\n\n### 操作\n\n更新操作比较复杂，但是需要较少的 IO 操作\n\n#### 批量加载\n\n如果一次性插入大量数据，在插入前对数据排序再插入到B+树中，可以有效提升性能\n\n同时，如果B+树是空的，还可以使用自底向上的方式来进行构建\n\n#### 查找\n\n首先在根节点进行二分查找，找到一个key的指针，接下来递归地不断向其非叶子节点查找，到了叶子节点，再进行二分查找，找出key所对应的data\n\n#### 修改\n\n查找出要修改节点的位置，由于每个中间节点能容纳的元素是有限的，所以修改之后会进行分裂、合并、旋转\n\n![插入元素导致的节点提升](/assets/2022712105845.webp)\n\n![删除元素导致节点合并](/assets/2022712105943.webp)\n\n### vs红黑树\n\n- 红黑树的出度为2，B树的出度要大很多，所以B树的查找次数更少\n- B+ Tree能更好地利用磁盘的预读特性 但操作也会更加复杂\n\n## LSM树\n\nlog-structured merge tree\n\n### Memtable\n\n内存中的数据结构，存储的是近期更新的记录值，可以用各种有序高效的数据结构来实现。为了保证内存中的数据在崩溃后能恢复，会采取 WAL 机制，先写日志再写内存，同时定期生成检查点快照，避免 WAL 日志无限增长。\n\n### Immutable Table\n\n在写入磁盘的过程中，系统很可能仍然在对外工作，所以创建副本，可以很好的地帮助避免读写冲突竞争\n\n### SSTable\n\n它要求key是有序的，并且每个段中每个key只能出现一次，查找key时，可以在稀疏索引中通过排序查找里快速找到\n\n![通过稀疏索引查找](/assets/202258212929.png)\n\n为了实现SSTables，需要在内存中维护一个有序的数据结构，每次写入时都会写到内存表，再由系统周期性刷到磁盘，为避免崩溃导致内存的数据还没刷到磁盘丢失，再维护一个日志文件，每进行一个操作就写到日志，以供恢复时使用\n\n需要查找时，就对段逐个倒叙查找，直到找到\n\n#### 压缩数据\n\n在 SSTable 的主流实现里，我们会把不同的阶段被合并的 segment 放到不同的层中，并限制每一层数量，当某层 segment 超过一定数量，我们就会把它们删除，合并出一个更大的 segment 放入下一层。\n\n#### 删除数据\n\n对数据标记了一个特殊的状态为记为删除，把这个特殊的状态称为 tombstone\n\n## MYSQL索引\n\n### 技术名词\n\n- 回表：使用索引就能完成查询 无需扫描表数据\n- 最左匹配：在检索数据时从联合索引的最左边开始匹配，也代表字符串最左N个字符可以走索引\n- 索引下推：在“仅能利用最左前缀索的场景”下，在遍历索引时，使用不在最左前缀索引中的其他联合索引字段，过滤会减少遍历索引查出的主键条数，减少回表\n\n### 分类\n\n- 根据叶子节点是否存储数据来划分，可以分成聚簇索引和非聚簇索引\n- 如果某个索引包含某个查询的所有列，那么这个索引就是覆盖索引\n- 如果索引的值必须是唯一的，不能重复，那么这个索引就是唯一索引\n- 如果索引的某个列，只包含该列值的前一部分，那么这个索引就是前缀索引。比如说在一个类型是 varchar(128) 的列上，选择前 64 个字符作为索引\n- 如果某个索引由多个列组成，那么这个索引就是组合索引，也叫做联合索引\n- 全文索引是指用于支持文本模糊查询的索引\n- 哈希索引是指使用哈希算法的索引，但是 MySQL 的 InnoDB 引擎并不支持这种索引\n\n### B+ Tree索引\n\n- 是大多数 MySQL 存储引擎的默认索引类型\n- 除了用于查找，还可以用于排序和分组\n- 适用于全键值、键值范围和键前缀查找\n\n### 哈希索引\n\n- 无法用于排序与分组\n- 只支持精确查找，无法用于部分查找和范围查找\n- 数据列只能回表查询，无法直接根据索引读取\n\n只有Memory引擎显式支持哈希索引。对于索引比较长的字符序列，哈希索引很好用\n\nInnoDB当某些索引值被使用的非常频繁时，会在B树索引的基础上创建一个哈希索引来提升效率，这个过程是内部且自动的。\n\n为了在InnoDB上模拟出哈希索引，可以考虑使用一个字段存储哈希值，每次查找时对这个哈希值做一个等值比较：\n\n```sql\nSELECT * FROM tb_url WHERE hash_code = CRC32('http://baidu.com') AND url = 'http://baidu.com';\n```\n\n### 全文索引\n\n- MyISAM 存储引擎支持（innodb 5.6后支持）\n- 用于查找文本中的关键词\n- 查找条件使用 MATCH AGAINST\n- 使用倒排索引\n\n### 空间数据索引\n\n空间数据索引（R-Tree），可以用于地理数据存储\n\n### 索引匹配方式\n\n#### 全值匹配\n\n全值匹配指的是和索引中的所有列进行匹配\n\n```sql\nexplain select * from staffs where name = 'July' and age = '23' and pos = 'dev'\n```\n\n但要注意，进行查询时，索引列不能是表达式的一部分，也不能是函数的参数\n\n```sql\nSELECT a FROM B WHERE a+3 = 6; -- 无法用到索引\n```\n\n像字符串跟数值比较的隐式类型转换、字段运算、字段是函数的参数、字符集不同等，本质上都是对字段做了转换操作，可能会破坏索引值的有序性，因此优化器就决定放弃走索引树的搜索，但还是会遍历索引\n\n#### 匹配最左前缀\n\n多个列作为条件进行查询时，使用组合索引比使用多个单列索引性能更好，MySQL会进行一项称为索引合并的策略，一定程度上可以使用多个单列索引来定位指定的行\n\n```sql\nexplain select * from staffs where name = 'July' and age = '23';\nexplain select * from staffs where name = 'July';\n-- 精确匹配某一列并范围匹配另外一列，可以查询第一列的全部和第二列的部分\nexplain select * from staffs where name = 'July' and age > 25;\n-- 2. 最左匹配，如果有一个(name,age,pos) 的索引，当一个索引不止一个列时，只有当最左索引（索引的第一个列）出现时，才会走索引查询\nexplain select * from staffs where age = 25 -- 不走索引\n```\n\n当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要\n\n但不考虑排序和分组的情况下，让选择性最强的索引列放在前面\n\n#### 匹配列前缀 \n\n可以匹配某一列的值的开头部分\n\n```sql\nexplain select * from staffs where name like 'J%'; -- 可以用索引\nexplain select * from staffs where name like '%y'; -- 用不到索引\n```\n\n可以选择开始的部分字符串来进行索引，索引的列的不重复值数量/总数量=索引的选择性 选择性越高 查询效率越好\n\n前缀索引占用的空间会比较少，但同时会增加扫描次数，为了达到索引空间与查询性能的平衡，需要统计数据整体前缀的区分度，选取一个折中的前缀索引长度\n\nBLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引\n\n前缀索引无法进行ORDER BY 或者GEOUP BY，也无法覆盖扫描，需要再回表查询\n\n有时候又需要后缀索引，为了达成这个目的，一种hack的方式是把字符串反转后进行存储\n\n#### 匹配范围值\n\n可以查找某一个范围的数据\n\n```sql\nexplain select * from staffs where name > 'Mary';\n```\n\n范围条件是：<、<=、>、>=、between 范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列\n\n#### 覆盖索引\n\n```sql\nexplain select name,age,pos from staffs where name = 'July' and age = 25 and pos = 'dev'; -- Extra:Using index 代表可以使用覆盖索引\n```\n\n如果一个索引包含所有需要查询的字段的值，称之为覆盖索引，当需要的数据被索引覆盖时，就不必回表查询。只使用索引可以减少数据读取量，同时由于索引是顺序存储的，相比直接读取数据，拥有较好的IO性能。MySQL中只能使用B树索引做覆盖索引\n\n### 聚簇索引与非聚簇索引\n\n- 聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起\n- 非聚簇索引：数据文件跟索引文件分开存放\n\n在InnoDB中，默认会选择主键来做聚簇索引，若没有主键，会生成一个隐藏的主键，主键最好使用自增的数值类型，这样在插入效率及空间占用都会最优\n\nMyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。\n\n而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录，。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。\n\n![myisam 非聚簇索引](/assets/2020325193319.png)\n\n![innodb 聚簇索引](/assets/202032519307.png)\n\n### 使用索引排序\n\nEXPLAIN的type为index时 代表使用索引扫描做排序\n\n只有当ORDER BY子句的列都是索引且排序方向一致时，才会使用索引排序\n\n### 压缩索引\n\nMyISAM会使用前缀压缩的方式将降低索引空间占用，从而使更多的索引可以放入内存。但代价是牺牲了CPU的运算时间。\n\n### 冗余索引\n\n大多数情况下应尽量扩展已有的索引而非创建新索引，索引越多，更新的时候越慢。\n\n但有时候为了兼容多个查询情况，为创建冗余索引来提升性能\n\n### 其他关于索引的优化\n\n- union all,in,or都能够使用索引，但是推荐使用in\n- 更新十分频繁，数据区分度不高的字段上不宜建立索引 更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能  区分不大的属性，建立索引是没有意义的，不能有效的过滤数据\n- 创建索引的列，不允许为null，可能会得到不符合预期的结果\n- 单表索引建议控制在5个以内\n- 单索引字段数不允许超过5个（组合索引）\n\n### 索引监控\n\n```sql\nshow status like 'Handler_read%';\n```\n\n- Handler_read_first：读取索引第一个条目的次数\n- Handler_read_key：通过index获取数据的次数\n- Handler_read_last：读取索引最后一个条目的次数\n- Handler_read_next：通过索引读取下一条数据的次数\n- Handler_read_prev：通过索引读取上一条数据的次数\n- Handler_read_rnd：从固定位置读取数据的次数\n- Handler_read_rnd_next：从数据节点读取下一条数据的次数\n\n### 维护索引和表\n\nCHECK TABLE 命令可以找出大多数表和索引的错误，使用REPAIR TABLE来修复损坏的表\n\nMySQL 使用基本成本模型的优化器，优化器会计算不同执行计划的执行成本，而执行成本则会使用表、索引等的统计信息计算得到，有时候这些统计信息会不准，使用ANALYZE TABLE 可以重新生成表的统计信息\n\n使用OPTIMIZE TABLE来整理碎片，对于不支持的存储引擎，执行\n\n```sql\nALTER TABLE table_name ENGINE=old_engine\n```\n","metadata":"tags: ['数据库', 'MySQL']\nbooks: [\n  {name: '数据库系统概念', chapters: ['第11章']},\n  {name: '高性能MySQL'}\n]","hasMoreCommit":true,"totalCommits":27,"commitList":[{"date":"2024-12-27T14:59:30+08:00","author":"MY","message":"📦索引","hash":"8e44eb9e91045fdf99bd5e881d4a3a70c77abc65"},{"date":"2024-12-11T19:59:57+08:00","author":"MY","message":"📦MySQL","hash":"5c96cf53bb2f2ca8359f5fab16cf12f5ef224bbc"},{"date":"2024-12-06T10:20:31+08:00","author":"MY","message":"📦MySQL","hash":"d532ea787648bc8393d88af0913622ace34cb094"},{"date":"2024-12-05T20:15:06+08:00","author":"MY","message":"📦MySQL","hash":"cdb32aeb50df56756186dd19009e666922259dd0"},{"date":"2024-12-04T19:58:48+08:00","author":"MY","message":"📦索引","hash":"d44cd8fd0c5ab3a19a6a77d8f0035dfe6695428c"},{"date":"2024-11-07T16:23:04+08:00","author":"MY","message":"📦MySQL","hash":"cc0b244f98955ea55043ef57b13e9fe490a110b1"},{"date":"2024-04-02T18:43:36+08:00","author":"MY","message":"✏数据库","hash":"b5ca237b4d2ce050f4dd0918af4cb0be969b0b02"},{"date":"2023-04-14T15:40:56+08:00","author":"MY","message":"✏MySQL","hash":"fcccd31969efcdefb9e7f872b7d1ca649dcfb6b3"},{"date":"2023-04-12T15:20:12+08:00","author":"MY","message":"✏MySQL","hash":"845841745789020073dd3e3f35a8e583f641e3a8"},{"date":"2023-04-06T21:52:20+08:00","author":"MY","message":"✏️索引","hash":"99a2ac7930de991f9dbd7a3f35006d662cd0f62c"}],"createTime":"2020-03-25T20:42:26+08:00"}