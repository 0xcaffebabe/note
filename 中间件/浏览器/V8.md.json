{"name":"V8","id":"中间件-浏览器-V8","content":"# V8\n\n- JavaScript 虚拟机\n\n## 对象内存布局\n\n![](/assets/20231226151111.webp)\n\n- element属性：数字属性，会按照数字的值排序存储\n- properties属性：常规属性，会按照存入的顺序进行存储\n- 对象内属性：有两种策略。快属性策略：属性比较少时，直接存放在对象内。慢属性策略：属性超过10个，多出来的属性将被存储到properties属性中。\n\n![函数对象的内存布局](/assets/20231226155213.webp)\n\n## [原型链](/编程语言/JavaScript/面向对象.md#原型链)\n\n## 作用域链\n\n在 V8 启动后，会创建全局作用域。启动后进入正常的事件循环，当解析到顶层的代码后，会把相应的全局变量加入全局作用域，而在执行函数调用时，会创建出一个本地作用域。在进行变量查找时，遵循的是本地作用域 -> 全局作用域 这条路线进行查找的。\n\n## 运行时\n\n- 宿主环境：浏览器中的渲染进程 或 nodejs 进程，宿主环境为 V8 提供了运行 js 所需的组件\n  - 数据存储空间\n    - 栈空间：管理函数调用\n    - 堆空间：树形的存储结构，用来存储对象类型的离散的数据\n  - 全局执行上下文：保存在堆中，用来实现全局作用域\n  - 事件循环系统：一个基于消息队列的 take and execute 模型\n\n### 事件循环\n\n```c\n// libuv 事件循环\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  ...\n\n  while (r != 0 && loop->stop_flag == 0) {\n    can_sleep =\n        uv__queue_empty(&loop->pending_queue) &&\n        uv__queue_empty(&loop->idle_handles);\n\n    uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n    \n    ...\n  }\n}\n```\n\n### [宏任务微任务](/中间件/浏览器/浏览器.md#宏任务微任务)\n\n宏任务队列由宿主环境管理，微任务队列由V8管理\n\n```cpp\nclass V8_EXPORT_PRIVATE MicrotaskQueue final : public v8::MicrotaskQueue {...}\n```\n\n只有V8的微任务队列执行完了，才会执行下一个宏任务\n\n## 延迟解析\n\n解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码，称之为延迟解析。\n\n由于闭包允许在函数内部定义函数，而内部函数可以访问外部函数所定义的变量。所以预解析启当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析。\n\n预解析除了会快速地检查一下语法错误外，另一件重要的事就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用\n\n## 字节码\n\n```mermaid\nstateDiagram-v2\n  js代码 --> AST: 解析\n  AST --> 基线编译器: 编译执行\n  state 基线编译 {\n    基线编译器 --> 未优化的二进制代码\n  }\n  AST --> 优化编译器: 编译执行\n  AST --> 解释器: 解释执行\n  解释器 --> 优化编译器: 热点代码优化\n  state 优化编译 {\n    优化编译器 --> 优化后的二进制代码\n  }\n  优化后的二进制代码 --> 未优化的二进制代码: 反优化\n```\n\nV8 的解释器是基于寄存器的虚拟机\n\n![](/assets/20231227191256.webp)\n\n累加器是一个非常特殊的寄存器，用来保存中间的结果\n\n## 优化\n\n### 隐藏类优化\n\nV8 对每个对象做如下两点假设：\n\n- 对象创建好了之后就不会添加新的属性\n- 对象创建好了之后也不会删除属性\n\n在以上假设的基础上，V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括：对象中所包含的所有的属性；每个属性相对于对象的偏移量\n\n当访问对象的某个属性中，就从记录的布局信息中，查找属性对应的偏移量并进行内存操作。这样就不必经历一系列的查找过程\n\n当给一个对象添加新的属性，或者删除属性时，V8 要为新改变的对象重新构建新的隐藏类，这是一笔开销\n\n### 内联缓存优化\n\nV8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程\n\n每个函数都会有一个反馈向量 (FeedBack Vector)，反馈向量中的每一行的内容就是函数中每一行字节码所使用到的隐藏类地址及属性偏移量\n\nslot|type|state|map|offset\n-|-|-|-|-\n0|LOAD|MONO|3425...|8\n1|STORE|MONO|3425...|12\n2|LOAD|POLY|`[3425...,3425...]`|`[8,12]`\n\n由于字节码对一个变量做操作，并不一定是确定的类型，所以map与offset可能为多项，超过4个隐藏类，就会使用哈希表来进行存储，否则使用线性结构\n\n## 垃圾回收\n\nV8 也是采取从 GC Roots 扫描来判断垃圾对象的，\n\nGC Root 通常包括了以下几种 (但是不止于这几种)：\n\n- 全局的 window 对象（位于每个 iframe 中）\n- 文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成\n- 存放栈上变量\n- ...\n\n在[分代收集](/编程语言/JAVA/JVM/自动内存管理/垃圾回收.md#分代收集)的基础上，V8 采用了两个垃圾回收器，主垃圾回收器 Major GC 和副垃圾回收器 Minor GC (Scavenger)\n\n- 副垃圾回收器主要负责新生代的垃圾回收\n- 主垃圾回收器主要负责老年代的垃圾回收\n\n为了解决垃圾回收 STW 带来的主线程阻塞问题，V8 组合使用以下三种方式解决，这点与 [JVM 实现的算法一样](/编程语言/JAVA/JVM/自动内存管理/垃圾回收.md#HotSport算法细节实现)：\n\n- 并行回收：使用多条线程进行标记清理工作，主线程还是会 STW\n- 增量回收：通过三色标记与写屏障实现，每次只回收一点，避免阻塞主线程太久\n- 并发回收：回收线程完全可以与主线程并发\n\n","metadata":"","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2023-12-28T16:56:05+08:00","author":"MY","message":"✏V8","hash":"79bbd082dbc88afbf5aebcc15ccd2a537349e9e5"},{"date":"2023-12-27T20:12:45+08:00","author":"MY","message":"✏V8","hash":"1381905a0885a92c45ee83207519b933405f1cf6"},{"date":"2023-12-26T17:24:10+08:00","author":"MY","message":"➕V8","hash":"4b43bac8a89d60953a8b2c83d0e4b8005673ae71"}],"createTime":"2023-12-26T17:24:10+08:00"}