{"name":"前端性能优化","id":"中间件-浏览器-前端性能优化","content":"# 前端性能优化\n\n- 实时性指标\n  - 可控时延\n  - 不可控时延\n\n## RAIL模型\n\n### 响应(Response)\n\n- 在50毫秒内处理用户输入事件, 对于需要超过50毫秒才能完成的操作，需要提供反馈\n\n### 动画(Animation)\n\n当动画的帧率是 >= 60帧/秒 的时候，人眼才不会觉得卡顿。此时的理论值为 1000毫秒/60帧 = 16.6 毫秒/帧\n\n浏览器需要大约6毫秒的时间来渲染每一帧，所以，每一帧的准则建议是10毫秒\n\n### 空闲时间(Idle Time)\n\n最大化闲置时间，增加页面在50毫秒内响应用户输入的几率\n\n### 加载(Loading)\n\n目标在5秒或更短的时间内加载、解析、渲染，并确保用户可以交互\n\n## 性能测量\n\n### DevTools 网络\n\n- 右键可以保存为请求为 [har](https://zh.wikipedia.org/wiki/.har)格式 方便在其他机器或软件上查看请求详细信息\n\n#### [单条请求详情](https://docs.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/network/reference#timing-breakdown-phases-explained)\n\n![请求详情(edge)](/assets/屏幕截图%202021-12-01%20173237.png)\n\n- 排队阶段：图片、音频等非核心资源如果遇到TCP连接满了，正在被其他css、js核心资源占用时，就会进入排队\n  - HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了\n  - 总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数\n- Initial connection/SSL 阶段：包括了建立 TCP 连接所花费的时间；如果使用了 HTTPS，那么还需要一个额外的 SSL 握手时间\n- equest sent 阶段：浏览器把从缓冲区的数据发送出去的时间\n- 第一字节时间（TTFB）\n\n### 帧率\n\nctrl + shift + p 开启帧率显示\n\n![帧率显示](/assets/屏幕截图%202021-12-01%20174010.png)\n\n### Performance Timing API\n\n- 浏览器内核自带的JS API\n\n#### 耗时计算\n\n```js\nlet timing = performance.getEntriesByType('navigation')[0];\ntiming.domInteractive - timing.fetchStart\n```\n\nDNS 解析耗时: domainLookupEnd - domainLookupStart\n\nTCP 连接耗时: connectEnd - connectStart\n\nSSL 安全连接耗时: connectEnd - secureConnectionStart\n\n网络请求耗时 (TTFB): responseStart - requestStart\n\n数据传输耗时: responseEnd - responseStart\n\nDOM 解析耗时: domInteractive - responseEnd\n\n资源加载耗时: loadEventStart - domContentLoadedEventEnd\n\nFirst Byte时间: responseStart - domainLookupStart\n\n白屏时间: responseEnd - fetchStart\n\n首次可交互时间（TTI）: domInteractive - fetchStart\n\nDOM Ready 时间: domContentLoadEventEnd - fetchStart\n\n页面完全加载时间: loadEventStart - fetchStart\n\nhttp 头部大小： transferSize - encodedBodySize\n\n重定向次数：performance.navigation.redirectCount\n\n重定向耗时: redirectEnd - redirectStart\n\n#### 长任务观察\n\n```js\nconst observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n        console.log(entry)\n    }\n})\n\nobserver.observe({entryTypes: ['longtask']})\n```\n\n#### 可见性状态监听\n\n- visibilitychange | webkitvisibilitychange 事件\n- document.hidden || document.webkitHidden 属性\n\n#### 网络状况监听\n\n```js\nconst connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\nconnection.effectiveType;\n```\n\n#### 元素可见性检测\n\n- [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)\n\n相较于 Element.getBoundingClientRect() , 后者是在主线程上运行，因此频繁触发、调用可能会造成性能问题\n\n- Profile\n  - 浏览器自带\n- 页面埋点计时\n- 资源加载时序图\n\n## 优化全过程\n\n### 静态资源优化\n\n- 图片、资源文件的压缩合并等\n\n优化图片 LCP 时间：\n\n- 避免在浏览器视口使用大尺寸图片\n- 减少浏览器视口的最大内容块区域，以减少下载和渲染时间\n- 预加载\n\n### 长任务优化\n\n1. 通过 setTimeout 把长任务拆分成多个宏任务\n2. 通过 Promise 的回调函数把长任务拆分为微任务\n3. 通过 requestAnimationFrame 拆分为微任务\n4. 使用 requestIdleCallback 在空闲时间执行长任务\n5. 使用 scheudler 决定任务运行时的优先级\n\n### 页面渲染技术方案选型\n\n- [前后端分离](/软件工程/架构/Web前端/前后端分离.md)\n- SPA\n- PWA\n\n### 原生 混合开发优化\n\n- 静态资源缓存代理离线技术\n- 跨平台等\n\n### 服务端网络优化\n\n- CDN\n- DNS\n- 压缩\n- HTTPS\n- HTTP2\n\n### [前端全链路监控](/软件工程/架构/系统设计/前端监控.md)\n\n### 渲染优化\n\n#### 布局防抖\n\n- 使用虚拟DOM减少、避免重排\n- FastDom\n\n#### 事件防抖\n\n- 使用节流或者防抖等方式降低事件触发频率\n\n#### 绘制\n\n当DOM或CSS发生改动后，就会触发绘制\n\n#### 白屏优化\n\n- 使用 PWA，使得可以缓存一些静态资源在本地\n- hybrid 应用宿主可以缓存 HTML 在本地\n\n#### FCP与FP优化\n\n- 减少资源的加载时间\n- 减少资源大小\n- 预加载\n- HTTP缓存\n- 避免自定义字体\n\n#### 布局偏移优化\n\n元素偏移的位置距离越远，布局偏移值就越大；影响视口面积越大，其影响比例也就越高，布局偏移值也就越大。CLS 值越小，用户体验越好。\n\n一些常见的布局偏移原因：\n\n1. 异步加载图片，图片没有初始宽高，导致布局发生抖动\n2. 动态插入的内容，如广告\n3. 动画导致的布局抖动\n4. 自定义字体导致加载字体时的字体闪烁\n\n## 静态资源优化\n\n### 图片\n\n- png无损 有透明通道\n- jpg有损\n- web的压缩介于png与jpg之间\n\n优化方法：\n\n- 打包时对图片进行压缩\n- 根据不同网络状况加载不同质量图片\n- 懒加载\n- 精灵图\n- Web Font 、Data URI代替图片\n\n### HTML\n\n- 精简字符\n- CSS与JS的放置位置错误会阻塞影响页面的渲染\n- 优化首屏加载的用户体验\n\n### CSS\n\n- 渲染性能\n  1. 避免深层级选择器\n  2. 避免代价高的属性（费内存，费CPU、GPU）\n  3. 避免代价高的选择器（expression表达式，正则表达式）\n- 加载性能\n  1. CDN\n  2. @import会阻塞\n  3. 精简字符\n- 字体\n  1. CDN\n- 动画\n  1. 避免同时过多动画\n  2. 使用SVG替代\n\n### JavaScript\n\nJavaScript 文件的下载过程会阻塞 DOM 解析\n\n该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行\n\n- 脚本位置：位于开头会阻塞页面渲染\n- 合并脚本\n- 异步脚本 (`<script async>`)\n  - async 下载完后立刻执行\n  - defer 会在等待dom加载完成后被触发\n- 动态脚本（通过动态创建dom节点实现）\n- 预解析\n  - DNS Prefetch \n  ```html\n  <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" />\n  ```\n  - preload\n  ```html\n  <link rel=\"preload\" href=\"/main.js\" as=\"script\">\n  ```\n  - prefetchprefetch\n  ```html\n  <link href=\"main.js\" rel=\"prefetch\">\n  ```\n\n## 页面渲染优化\n\n- 重排指的是当页面布局发生变化时，浏览器重新计算元素的几何属性，然后更新布局的过程\n- 重绘是指在布局计算完成后，浏览器根据元素的样式信息重新绘制页面内容的过程\n\n重排在布局变化时触发，重绘在布局计算完成后触发。减少重排与重绘的一些原则：\n\n1. 批量操作、批量更新 DOM\n2. 减少不必要的样式属性的计算与读取\n3. 使用 CSS 动画\n4. 降低 DOM 结构与数量\n\n### 渲染方案\n\n#### 静态化方案\n\n- 物理HTML文件 性能较高 服务器负载较低\n- 需要考虑文件占用的磁盘空间及文件更新问题\n\n#### 前后端分离\n\n- 前端负责实现页面前端交互，根据后端 API 接口拼装前端模板\n\n##### SPA\n\n- 使用js重写当前页面 达到不刷新页面重载页面的目的\n\n#### BigPipe方案\n\n- 通过将页面划分为不同独立的小块 加快传输渲染\n\n#### 同构直出\n\n只开发一套项目代码，既可以实现前端的渲染，也可以做后台的直出， 所谓直出，指的是直接由服务端执行js返回渲染好的html内容\n\n#### PWA\n\n## 桌面端优化策略\n\n网络：\n\n- 减少HTTP请求次数及请求大小\n- 使用外部文件引入css或者js可以利用浏览器缓存\n- 避免空href和src 他们也会发起请求\n- 合理利用HTTP缓存\n- 减少重定向\n- 增加静态域增加下载并行数\n- 合理利用CDN\n- 使用可缓存的AJAX\n- 减少cookie大小\n- 缓存favicon.ico\n- 异步加载js资源\n- 避免CSS或者js资源阻塞渲染\n\n页面渲染：\n\n- CSS放头部：优先下载完成渲染\n- JS放底部：避免JS对页面渲染造成阻塞\n- 避免在HTML直接缩放图片\n- 减少DOM数量及深度（只渲染可视内容）\n- 避免table iframe等慢元素\n- 避免运行耗时过长的JS\n- 避免CSS表达式或者滤镜\n\n## 移动端优化策略\n\n网络：\n\n- 提前首屏数据请求 避免JS文件加载后才加载数据\n- 首屏按需加载 展示延时不超过3秒\n- 模块化资源并行下载\n- 内联首屏必须的css及js\n- dns预解析\n- 资源预加载\n- 合理利用MTU 1500B\n\n缓存：\n\n- 合理利用浏览器缓存\n- 静态资源离线方案\n- AMP HTML\n\n图片：\n\n- 对所有移动端的图片都需要压缩处理\n- 使用较小的图片 合理利用BASE64内嵌图片\n- 使用更高压缩比的格式 如webp\n- 图片懒加载\n- 利用CDN加载不同大小的图片\n- 图标精良使用iconfont\n- 限制图片最大大小\n\n脚本：\n\n- 使用ID选择器  其最快\n- 缓存DOM对象\n- 使用事件代理 避免直接事件绑定\n- 使用touchstart代替click\n- 避免touchmove scroll 连续事件代理 需要合理进行节流\n- 避免eval with 推荐ES6模板字符串\n- 推荐使用ES6规范\n\n渲染：\n\n- 使用viewport固定屏幕渲染\n- 避免各种重排重绘\n- 使用CSS3动画 开启GPU加速\n- 使用canvas实现动画更高效\n- 使用SVG代替图片\n- 少用float 耗性能\n- 避免过多的font-size声明\n\n架构协议：\n\n- 使用SPDY与HTTP2等新协议\n- 后端数据渲染\n- 使用NativeView代替传统DOM","metadata":"","hasMoreCommit":true,"totalCommits":12,"commitList":[{"date":"2024-07-16T16:34:37+08:00","author":"MY","message":"✏前端性能优化","hash":"0f01cccb72db1dc8d6e6dd4af5d2f6572dda1906"},{"date":"2024-07-15T19:59:30+08:00","author":"MY","message":"✏前端性能优化","hash":"030a3f5157dcbb5d0454cad768dbfd94ca5641ee"},{"date":"2024-07-12T17:35:58+08:00","author":"MY","message":"✏前端性能优化","hash":"2aee92282949491b1ea6eba4aa14cc23dd04cabd"},{"date":"2022-10-18T16:19:22+08:00","author":"cjiping","message":"✏️浏览器","hash":"917b0877ffc7030c6666916cb11a3c2a26db8eee"},{"date":"2022-10-17T16:15:45+08:00","author":"cjiping","message":"✏️前端性能优化","hash":"71659b88a4df03bdbb9b6fcb642fa0a2243d17c7"},{"date":"2022-10-17T15:26:37+08:00","author":"cjiping","message":"📦浏览器","hash":"07b49bbcd2ffa7f61ead7892b19de15b3565f65d"},{"date":"2022-09-22T19:11:00+08:00","author":"cjiping","message":"✏️浏览器","hash":"096ed8c77864bdbae49a1cfdcecaecd4aa59e077"},{"date":"2021-12-09T17:53:52+08:00","author":"cjiping","message":"✏️更新 前端性能优化","hash":"b083079c10efb7fdad64f467d60550ce079aed3b"},{"date":"2021-12-08T17:14:44+08:00","author":"cjiping","message":"✏️更新 前端性能优化","hash":"14ca6da99093744d9b902cf6c099f4f8353a7a4c"},{"date":"2021-12-07T17:11:15+08:00","author":"cjiping","message":"✏️更新 前端性能优化","hash":"fa2094e2f4ab5b25864ec6321a3e75c1ccf067e5"}],"createTime":"2021-12-01T17:53:59+08:00"}