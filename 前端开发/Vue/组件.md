# 组件

## 前端组件化

利用组件化开发，拆分功能，封装组件，单独维护

```js
// 定义一个名为 button-counter 的全局组件
Vue.component('button-counter', {
    data: function () {
        return {
            count: 0
        }
    },
    template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
});
new Vue({ el: '#app' });
```
```html
<div id="app">
    <!-- 使用自定义组件 -->
    <button-counter></button-counter>
</div>
```

## 父子组件通信

```js
const introduce = {
    template:'<h1 @click="fun()">{{msg}}</h1>',
    methods: {
        fun() {
            // 触发上一层事件
           this.$emit('delete');
        }
    },
    props:['msg']
}
new Vue({
    el: '#app'
    ,
    data:{
        msg:'大家好，我是渣渣辉'
    }
    ,
    methods: {
        handleDelete() {
            // delete son
        }
    }
    ,
    components:{
        introduce
    }

});
```
```html
<div id="app">
    <introduce :msg="msg" @delete="handleDelete"></introduce>
</div>
```

## 组件使用中的细节

- 使用`is='componentName'来解决html结构问题`
- 子组件的data应该是一个函数，如果是对象的话，则所有的子组件的data都是共享的
- 可以通过ref来获取到子组件的引用

## 组件化带来的问题

- 组件状态管理(vuex)
- 多组件混合使用(vue-router)
- 组件间的合作(props,emit/on,bus)

## vue-router

- 引入vue组件

```js
import Info from '../views/Info.vue';
```

- 在router中添加

```js
const routes = [
  //...
  {
    path: '/info',
    name: 'info',
    component: Info,
  },
];
```

## vuex

使用vuex来管理全局状态

- info组件向vuex发起请求

```js
import store from '@/store';

export default {
  name: 'info',
  store,
  methods: {
    add() {
      console.log('add');
      store.commit('add');
    },
  },
};
```

- vuex更新状态

```js
//...
export default new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    add() {
      this.state.count++;
      console.log('vuex add');
    },
  }
  // ...
});
```

- about组件通过vuex来获取状态

```js
import store from '@/store';
  
export default {
  name: 'about',
  store,
  data() {
    return { count: store.state.count };
  },
};
```
