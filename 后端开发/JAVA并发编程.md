# 线程安全性

>当多个线程访问某个类时，这个类始终都能表现出正确的行为，则称这个类是线程安全的

- 无状态对象一定是线程安全的

## 原子性

```java
if (condition){
    a++; // 当此段代码运行在多线程的环境时，则会产生线程安全问题
}
```

观察结果的失效就是大多数竞态条件的本质

一种常见的竞态条件发生在单例构造模式中：

```java
public static Object get(){

    if (instance == null){
        instance = new Object();
    }
    return instance;
}
```

- 复合操作：由一系列原子操作构成

## 加锁机制

- 内置锁:`synchronized`关键字

>重入：某个线程试图获得一个已经由它持有的锁

锁能使其保护的代码路径以串行形式访问

- 对持有锁的范围、时间进行良好设计

# 对象的共享

## 可见性

在没有同步的情况下，编译器或者处理器都会对一些上下文无关的指令进行**重排序**，这可能会导致一个线程修改了某一个数值，而另一个线程无法马上读取到修改后的数值

- 失效数据
- 非原子的64位操作

    >在java当中，一个64位大小的数值可以被分为2个32位的操作

### 加锁与可见性

![](https://wiki.jikexueyuan.com/project/java-concurrency/images/synchronous.jpg)

之所以要在访问某个共享的可变变量时要求所有线程在锁上同步，就是为了确保读写可见性。
加锁的含义不局限与互斥行为，还包括内存可见性

volatile是比synchronized更为轻量级的同步机制，它无法进行互斥操作，但能保证内存可见性

- 典型用法

```java
voatile boolean f;
...
while (f){
    // do something
}
```

## 发布与逸出

发布:
>使对象能在当前代码作用域之外使用

逸出:
>某个不该发布的对象被发布了

## 线程封闭

>某个对象只能在线程之内使用

- Ad-hoc线程封闭
  - 完全由程序承担，很脆弱
- 栈封闭
  - 对象只能在局部（方法内）使用
- ThreadLocal
  - 使用ThreadLocal包装的对象只能在当前线程使用

## 不变性





