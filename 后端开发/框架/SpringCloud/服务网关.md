# API Gateway

![](http://favorites.ren/assets/images/2017/springcloud/api_gateway.png)

# Spring Cloud Zuul

- 添加依赖

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        </dependency>
```

- 配置

```properties
server.port=8010
spring.application.name=gateway

#这里的配置表示，访问/bd/** 直接重定向到http://baidu.com/**
zuul.routes.baidu.path=/bd/**
zuul.routes.baidu.url=http://baidu.com/


eureka.client.serviceUrl.defaultZone=http://localhost:8001/eureka/
```

# 默认路由规则

http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**

比如访问http://localhost:8010/producer/

则gateway就会把请求转发到producer服务上面去

# Zuul的核心

- Fliter

    ![](http://favorites.ren/assets/images/2018/springcloud/zuul-core.png)

## 自定义Filter

- 实现ZuulFilter

```java
public class MyFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return -100;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {

        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        String token = request.getParameter("token");

        if ("my".equals(token)){
            ctx.setSendZuulResponse(true);
            ctx.setResponseStatusCode(200);
            ctx.set("isSuccess",true);

        }else{
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(400);
            ctx.setResponseBody("error token");
            ctx.set("isSuccess",false);

        }

        return null;

    }
}
```

- 将其注入到容器

```java
@Bean
    public ZuulFilter zuulFilter(){
        return new MyFilter();
    }
```

这样当通过网关访问服务时，不符合条件的请求将会被过滤掉


# 路由熔断

- 自定义fallback

```java
@Component
public class MyFallback implements FallbackProvider {
    @Override
    public String getRoute() {
        return "producer";
    }

    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {

        cause.printStackTrace();


        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.valueOf(500);
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 500;
            }

            @Override
            public String getStatusText() throws IOException {
                return "SERVER ERROR";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("service is unavailable".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.TEXT_PLAIN);
                return headers;
            }
        };
    }
}
```

当producer挂掉时，将会返回相关信息

# 路由重试

- 添加依赖

```xml
        <dependency>
            <groupId>org.springframework.retry</groupId>
            <artifactId>spring-retry</artifactId>
        </dependency>
```

- 配置

```properties
#是否开启重试功能
zuul.retryable=true
#对当前服务的重试次数
ribbon.MaxAutoRetries=2
#切换相同Server的次数
ribbon.MaxAutoRetriesNextServer=0
```

当相同的服务挂掉一部分后，如果多次请求不成功，则接下来的请求则会转发到其他服务上

> 也就是说,自动的寻找到正确响应的服务上去.错误的实例被抛弃







