# API Gateway

![](http://favorites.ren/assets/images/2017/springcloud/api_gateway.png)

# Spring Cloud Zuul

![](https://github.com/0xcaffebabe/leyou/raw/master/day03-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A12/assets/1525675648881.png)

- 添加依赖

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
```

- 配置

```properties
server.port=8010
spring.application.name=gateway

#这里的配置表示，访问/bd/** 直接重定向到http://baidu.com/**
zuul.routes.baidu.path=/bd/**
zuul.routes.baidu.url=http://baidu.com/


eureka.client.serviceUrl.defaultZone=http://localhost:8001/eureka/
```

# 默认路由规则

<http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**>

比如访问<http://localhost:8010/producer/>

则gateway就会把请求转发到producer服务上面去

## 简化路由配置

```yml
zuul:
  routes:
    user-service: /user-service/** # 这里是映射路径
```

# Zuul的核心

- Fliter

  ![](http://favorites.ren/assets/images/2018/springcloud/zuul-core.png)
- 场景
  - 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了
  - 异常处理：一般会在error类型和post类型过滤器中结合来处理。
  - 服务调用时长统计

## 自定义Filter

- 实现ZuulFilter

```java
public class MyFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return FilterConstants.PRE_DECORATION_FILTER_ORDER;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {

        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        String token = request.getParameter("token");

        if ("my".equals(token)){
            ctx.setSendZuulResponse(true);
            ctx.setResponseStatusCode(200);
            ctx.set("isSuccess",true);

        }else{
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(400);
            ctx.setResponseBody("error token");
            ctx.set("isSuccess",false);

        }

        return null;

    }
}
```

- 将其注入到容器

```java
@Bean
public ZuulFilter zuulFilter(){
    return new MyFilter();
}
```

这样当通过网关访问服务时，不符合条件的请求将会被过滤掉

## 进行跨域配置

```java
@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        final CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true); // 允许cookies跨域
        config.addAllowedOrigin("*");// #允许向该服务器提交请求的URI，*表示全部允许，在SpringMVC中，如果设成*，会自动转成当前请求头中的Origin
        config.addAllowedHeader("*");// #允许访问的头信息,*表示全部
        config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了
        config.addAllowedMethod("*");// 允许提交请求的方法，*表示全部允许
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

# 路由熔断

- 自定义fallback

```java
@Component
public class MyFallback implements FallbackProvider {
    @Override
    public String getRoute() {
        return "producer";
    }

    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {

        cause.printStackTrace();


        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.valueOf(500);
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 500;
            }

            @Override
            public String getStatusText() throws IOException {
                return "SERVER ERROR";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("service is unavailable".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.TEXT_PLAIN);
                return headers;
            }
        };
    }
}
```

当producer挂掉时，将会返回相关信息

# 路由重试

- 添加依赖

```xml
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```

- 配置

```properties
#是否开启重试功能
zuul.retryable=true
#对当前服务的重试次数
ribbon.MaxAutoRetries=2
#切换相同Server的次数
ribbon.MaxAutoRetriesNextServer=0
```

当相同的服务挂掉一部分后，如果多次请求不成功，则接下来的请求则会转发到其他服务上

> 也就是说,自动的寻找到正确响应的服务上去.错误的实例被抛弃

# Spring Cloud Gateway

- 路由
- 断言
- 过滤器

![](http://favorites.ren/assets/images/2018/springcloud/spring-cloud-gateway.png)

## 配置

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
```

- 定义路由规则

```java
@Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("path_route", r -> r.path("/hi")
                        .uri("http://localhost:8503"))
                .build();
    }
```

- 通过时间匹配

```java
builder.routes()
                .route("path_route", r -> r.before(ZonedDateTime.now())
                        .uri("http://localhost:8503"))
                .build();
```

- 通过Cookie匹配

```java
builder.routes()
                .route("path_route", r -> r.cookie("key","value")
                        .uri("http://localhost:8503"))
                .build();
```

- 通过header属性匹配
- 通过Host匹配
- 通过请求方式匹配
- 通过请求路径匹配
- 通过请求参数匹配
- 通过请求IP匹配

### 服务化

- 依赖

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
```

- 配置

```yml
server:
  port: 8888
spring:
  application:
    name: gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8001/eureka/
logging:
  level:
    org.springframework.cloud.gateway: debug
```

- 默认转发规则

> <http://网关地址：端口/服务中心注册> serviceId/具体的url

### Filter

- PRE

> 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等

- POST

> 这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等

#### 简单过滤器实例

- 配置

```yml
server:
  port: 8888
spring:
  application:
    name: gateway
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: http://localhost:9003
        filters:
        - AddRequestParameter=name, my
        predicates:
          - Method=GET
      discovery:
        locator:
          enabled: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8001/eureka/
logging:
  level:
    org.springframework.cloud.gateway: debug
```

在上面的配置中，添加了一个路由过滤规则：对9003端口的get请求添加一个请求参数name:my

- 服务化配置

改成`uri: lb://producer` 则路由配置只会对producer服务生效

#### 修改路径的过滤器

- StripPrefix Filter

  ```yml
  - id: nameRoot
            uri: lb://producer
            predicates:
                - Path=/name/**
            filters:
                - StripPrefix=2
  ```

  如果访问/name/my/hello，网关就会将路径修改为/hello

- PrefixPath Filter

  ```yml
  - id: prefixpath_route
            uri: lb://producer
            predicates:
            - Path=*
            filters:
            - PrefixPath=/mypath
  ```

  自动给URL加上mypath前缀

#### 限速路由器

#### 熔断路由器

- 依赖

```xml
<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
```

```yml
- id: hystrix_route
          uri: http://localhost:9001
          predicates:
            - Path=/*
          filters:
            - Hystrix=myCommandName
```

#### 重试路由器
