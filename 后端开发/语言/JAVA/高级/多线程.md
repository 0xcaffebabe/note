进程是所有线程的集合，每一个线程是进程中的一条执行路径

- 并发：指两个或多个事件在同一个时间段内发生。
- 并行：指两个或多个事件在同一时刻发生（同时发生）。

# 线程分类

- 用户线程
  - 主线程
  - 子线程
- 守护线程
  - *守护线程当进程不存在或主线程停止，守护线程也会被停止*
  - GC线程

# 线程创建方法

## 继承Thread类

```java
class MyThread extends Thread{
    @Override
    public void run() {}
}
```

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈

![批注 2019-08-02 115159](/assets/批注%202019-08-02%20115159.png)

### Thread类

#### 常用方法

- public String getName() :获取当前线程名称。
- public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
- public void run() :此线程要执行的任务在此处定义代码。
- public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
- public static Thread currentThread() :返回对当前正在执行的线程对象的引用

## 实现Runnable接口

**实现Runnable接口比继承Thread类所具有的优势：**

- 适合多个相同的程序代码的线程去共享同一个资源。
- 可以避免java中的单继承的局限性。
- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

## 匿名内部类实现

```java
new Thread(new Runnable() {
    @Override
    public void run() {}
}).start();

new Thread(){
    @Override
    public void run(){}
}.start();
```

# 线程安全

> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。

## JAVA API中的线程安全问题

- StringBuffer
- Vector

## 同步

- 同步代码块。

  ```java
  synchronized(同步锁){
    需要同步操作的代码
   }
  ```

- 同步方法。

  ```java
  public synchronized void method(){
           可能会产生线程安全问题的代码   

   }
  ```

- 锁机制。

  - public void lock() :加同步锁。
  - public void unlock() :释放同步锁。

### 原理

> 使用了锁对象，这个锁对象一瞬间只能被一个线程所持有

## 线程状态

![](http://img.jeepxie.net/upload/7/ca/7caf5a9e4101afb775d70caa256d7db8_thumb.jpg)

线程状态                | 导致状态发生条件
------------------- | -------------------------------------------------------------------------------------------------------------
NEW(新建)             | 线程刚被创建，但是并未启动。还没调用start方法。
Runnable(可运行)       | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。
Blocked(锁阻塞)        | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。
Waiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。
Teminated(被终止)      | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

## 线程间通信

- 等待-唤醒机制

![06_等待唤醒案例分析](/assets/06_等待唤醒案例分析.bmp)

```java
Object object = new Object();

new Thread(){
    @Override
    public void run() {
        synchronized (object){
            System.out.println("要5个包子");
            // 进入等待，这时候锁会被释放
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("得到了5个包子");
        }
    }
}.start();

new Thread(){
    @Override
    public void run() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (object){
            System.out.println("包子生产完毕，告诉顾客");
            // 通知等待线程中的任意一个
            object.notify();
        }
    }
}.start();
```

- wait与notify一定要在线程同步中使用,并且是同一个锁的资源
- 在调用sleep()方法的过程中，线程不会释放对象锁

### 计时等待

![批注 2019-08-02 144634](/assets/批注%202019-08-02%20144634.png)

### 被阻塞

![批注 2019-08-02 144710](/assets/批注%202019-08-02%20144710.png)

### 等待

![批注 2019-08-02 144817](/assets/批注%202019-08-02%20144817.png)


## 线程池

好处：
- 降低资源消耗
- 提高响应速度
- 提高线程的可管理性

### 使用

```java
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        for (int i =0;i<100;i++){
            int finalI = i;
            executorService.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("run"+ finalI);
                }
            });
        }
        executorService.shutdown();
```

