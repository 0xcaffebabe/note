# 资源

排他性使用的对象

- 可抢占资源
- 不可抢占起源

1）请求资源 2）使用资源 3）释放资源

## 资源获取

可能产生死锁的编码

```c
void fa(){
    down(r1);
    down(r2);
    up(r1);
    up(r2);
}

void fb(){
    down(r2);
    down(r1);
    up(r1);
    up(r2);
}
```

# 死锁简介

> 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的

- 资源死锁的条件

  - 互斥
  - 占有和等待
  - 不可抢占
  - 环路等待

## 死锁建模

圆形表示进程，方形表示资源

![enter image description here](https://upload-images.jianshu.io/upload_images/7130568-ed1f23d8c8f7bc69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/298/format/webp)

如果产生环路，则产生死锁

- 处理死锁的策略

  - 忽略问题
  - 检测并恢复
  - 仔细分配资源
  - 破坏引起死锁的四个必要条件

# 鸵鸟算法

# 死锁检测和死锁恢复

- 每种类型一个资源的死锁检测

  检测有向图环路的算法 深度优先搜索

- 每种类型多个资源的死锁检测

  基于向量检测

- 从死锁中恢复

  - 利用抢占恢复
  - 利用回滚恢复
  - 杀死进程恢复

# 死锁避免

## 资源轨迹图

## 安全状态和不安全状态

从安全状态出发，系统能保证所有进程都能完成

## 单个资源的银行家算法

## 多个资源的银行家算法

# 死锁预防
- 破坏互斥条件
- 破坏占有并等待条件
- 破坏不可抢占条件
- 破坏环路等待条件

![enter image description here](https://www.zoomfeng.com/images/2019/02/11/3.png)

# 其他问题
- 两阶段加锁
- 通信死锁
- 活锁
- 饥饿


