{"name":"死锁","id":"操作系统-死锁","content":"# 死锁\n\n## 0. 引言：死锁的本质\n\n死锁（Deadlock）的本质并不是\"几个进程卡住不动\"，而是：\n\n> **系统进入了一个不可逃逸的状态空间（Irreversible State），其内部所有进程的推进都依赖于彼此引发的事件，而这些事件永远不会发生。**\n\n从统一抽象模型看：\n死锁 = **等待关系图（Wait-For Graph）中出现不可消除的环路**。\n\n理解死锁要从 **系统状态空间** 与 **资源分配图** 入手，再将所有策略归纳为一套 **死锁治理体系**。\n\n---\n\n# 1. 死锁的抽象模型（核心框架）\n\n## 1.1 资源分配图（RAG：Resource Allocation Graph）\n\n系统由两类节点构成：\n\n* **进程 P**\n* **资源 R**\n\n边表示关系：\n\n* `R → P`：资源被某进程持有\n* `P → R`：进程正在请求资源\n\n若改写为等待图（WFG），则为：\n\n* `P1 → P2`: P1 等待 P2 所持资源\n\n所有死锁判定和策略都可从此图推导。\n\n---\n\n## 1.2 死锁的四个必要条件（从模型导出）\n\n死锁产生要求 **全部成立**：\n\n| 条件        | 本质含义       | 对应模型表现              |\n| --------- | ---------- | ------------------- |\n| **互斥**    | 资源不可共享     | R 节点只有一个出边          |\n| **占有并等待** | 持有部分资源继续请求 | P 节点同时连接 Rout 和 Rin |\n| **不可抢占**  | 资源不能强制收回   | 图结构不可修改             |\n| **环路等待**  | 存在闭环       | WFG 出现环路            |\n\n> **四条件不是规则，而是图结构的特征**\n> 只要等待图中出现\"闭环\"，其成因必然表现为这四条。\n\n---\n\n# 2. 死锁的类型（从系统视角分类）\n\n## 2.1 静态顺序死锁\n\n资源顺序固定但多个线程以不同顺序请求 → 环路出现。\n\n## 2.2 动态顺序死锁\n\n资源的请求动态变化，无法保证统一顺序。\n\n## 2.3 资源死锁（经典 OS 死锁）\n\n争夺有限、不可抢占资源（锁、文件、IO）。\n\n---\n\n# 3. 死锁的生命周期（能力体系总览）\n\n建议用统一治理体系理解死锁：\n\n```\n死锁治理体系\n├── 预防（Prevention）——破坏必要条件\n├── 避免（Avoidance）——仅进入安全状态\n├── 检测（Detection）——持续检测环路\n└── 恢复（Recovery）——打破死锁\n```\n\n此体系适用于：\n\n* 操作系统\n* 数据库\n* 分布式系统\n* JDK、Go、Rust 等语言运行时\n\n---\n\n# 4. 死锁预防（Prevention）：运行前避免死锁\n\n核心思想：**从根源破坏\"导致死锁的必要条件\"之一**。\n\n| 要破坏的条件 | 对应策略      | 原理      |\n| ------ | --------- | ------- |\n| 互斥     | 共享资源、假脱机  | 消除独占性   |\n| 占有并等待  | 运行前请求全部资源 | 不形成链式请求 |\n| 不可抢占   | 允许抢占      | 消除封闭环路  |\n| 环路等待   | 资源编号、顺序锁  | 阻止环路形成  |\n\n**适用于：**\n数据库锁顺序、两阶段加锁、资源分级、多锁策略等。\n\n---\n\n# 5. 死锁避免（Avoidance）：运行中确保安全状态\n\n## 5.1 安全状态（Safe State）\n\n存在至少一种**进程顺序**能让所有执行完毕 → 状态安全。\n否则→ 不安全。不安全 ≠ 死锁，但可能发展为死锁。\n\n## 5.2 银行家算法（Banker's Algorithm）\n\n通过模拟资源分配，判断是否会进入不安全状态。\n\n核心结构：\n\n* **E**：资源总量向量\n* **A**：当前可用向量\n* **C**：当前已分配资源矩阵\n* **R**：最大需求矩阵\n\n算法思想：\n\n1. 找到一个需求 ≤ A 的进程\n2. 假设其结束并释放资源\n3. 更新 A\n4. 重复直到全部结束\n\n该算法体现：\n\n> **避免死锁不是避免等待，而是避免进入无法撤退的状态空间。**\n\n---\n\n# 6. 死锁检测（Detection）：发现环路\n\n## 6.1 单实例资源：等待图环路检测\n\n使用 DFS 或 Tarjan 算法检查环路。\n复杂度：O(V + E)\n\n## 6.2 多实例资源：资源分配矩阵检测\n\n检测是否存在一个进程可获满足请求，若所有都不能则死锁。\n\n适用系统：数据库、OS、线程调度器。\n\n---\n\n# 7. 死锁恢复（Recovery）：从死锁中走出\n\n策略按破坏成本排序：\n\n## 7.1 抢占（Preemption）\n\n从某进程强制拿走资源 → 恢复可行性。\n\n## 7.2 回滚（Rollback）\n\n回到检查点 → 放弃部分计算 → 常见于事务系统。\n\n## 7.3 终止进程（Kill）\n\n选择\"牺牲者（victim）\"终止。数据库常用。\n\n> 牺牲者选择策略可按代价模型（cost model）优化：已运行时间、持有资源数量、优先级等。\n\n---\n\n# 8. 工程视角：现代系统中的死锁\n\n## 8.1 操作系统\n\n* mutex、semaphore\n* IO 资源竞争\n* 内核锁（如 Linux Big Kernel Lock 历史）\n\n## 8.2 JVM / Java\n\n* synchronized 死锁\n* ReentrantLock + tryLock 作为死锁规避\n* 通过 Thread Dump 查看 WFG\n\n## 8.3 Go\n\n* goroutine + channel 死锁（运行时直接 panic）\n* select + timeout 避免通信死锁\n\n## 8.4 数据库\n\n* 行锁 / 表锁\n* 两阶段锁协议（2PL）\n* 死锁检测器（等待图）\n\n## 8.5 分布式系统\n\n* 分布式锁（Redis/ZK）死锁风险更高\n* 因网络分区导致\"伪死锁\"\n* 租约（Lease）、超时、心跳是核心策略\n\n---\n\n# 9. 相关问题与概念边界（避免混淆）\n\n| 概念       | 特征           | 是否死锁？    |\n| -------- | ------------ | -------- |\n| **死锁**   | 所有进程都停止推进    | ✔        |\n| **活锁**   | 进程不断变化但不前进   | ✘        |\n| **饥饿**   | 某些进程永远不得资源   | ✘        |\n| **通信死锁** | 双方等待消息，不涉及资源 | ✔（等待图形式） |\n| **响应性慢** | 资源分配不均衡      | ✘        |\n\n这是构建概念体系的重要部分，帮助工程中准确定位问题。\n\n---\n\n# 10. 典型错误示例（编程层面）\n\n```c\nvoid fa(){\n    down(r1);\n    down(r2);\n    up(r1);\n    up(r2);\n}\n\nvoid fb(){\n    down(r2);\n    down(r1);\n    up(r1);\n    up(r2);\n}\n```\n\nfa 和 fb 对资源请求顺序不一致 → 静态顺序死锁。\n\n工程解决方案：\n\n* 固定资源顺序（资源编号法）\n* tryLock + 超时\n* 两阶段锁协议\n\n---\n\n# 11. 死锁治理最佳实践（统一策略）\n\n### ✔ 编程层面\n\n* 固定资源获取顺序（资源编号法）\n* 尽量减少锁的粒度和持有时间\n* 使用 tryLock / select+timeout\n* 尽量使用无锁结构\n\n### ✔ 系统层面\n\n* 运行时死锁检测器\n* 线程转储分析\n* 资源监控与报警\n\n### ✔ 分布式系统层面\n\n* 分布式锁需带超时避免永久死锁\n* 使用租约（lease）而非永久锁\n* 心跳 + 强制回收\n\n---\n\n# 12. 总结：统一心智模型\n\n> 死锁不是一个孤立问题，而是\"系统状态空间不可逆\"的表现。\n> 所有策略都围绕\"让系统进入、维持或恢复到可逆状态\"展开。\n\n核心统一框架：\n\n```\n抽象模型：资源分配图 / 等待图（WFG）\n↓\n四个必要条件：图结构特征\n↓\n策略体系：预防 / 避免 / 检测 / 恢复\n↓\n工程实现：OS / JVM / DB / 分布式系统\n↓\n边界概念：死锁 vs 活锁 vs 饥饿\n```\n\n这就是一个可复用、可迁移、跨学科的**死锁知识体系**。\n\n## 关联内容（自动生成）\n\n- [/中间件/数据库/数据库系统/事务管理/事务.md](/中间件/数据库/数据库系统/事务管理/事务.md) 数据库事务管理中包含死锁处理策略，与操作系统死锁有相似的模型和解决方案\n- [/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md](/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md) Java并发编程涉及锁、线程同步等概念，与死锁密切相关\n- [/操作系统/进程与线程.md](/操作系统/进程与线程.md) 进程与线程管理是死锁问题的核心场景，涉及同步与互斥机制\n- [/编程语言/JAVA/JVM/自动内存管理/内存结构.md](/编程语言/JAVA/JVM/自动内存管理/内存结构.md) JVM内存结构中包含锁和死锁检测机制，是Java应用层面死锁处理的重要参考\n- [/编程语言/并发模型.md](/编程语言/并发模型.md) 并发模型中的资源循环依赖与死锁问题相关\n- [/软件工程/架构/系统设计/分布式/分布式事务.md](/软件工程/架构/系统设计/分布式/分布式事务.md) 分布式事务中的锁竞争和死锁检测与操作系统死锁处理方法类似\n- [/编程语言/JAVA/JAVA并发编程/线程池.md](/编程语言/JAVA/JAVA并发编程/线程池.md) 线程池中的任务依赖可能导致死锁问题\n- [/中间件/数据库/mysql/mysql.md](/中间件/数据库/mysql/mysql.md) MySQL中的表级锁、行级锁及死锁处理机制与操作系统锁机制相似\n- [/编程语言/JAVA/Java谜题.md](/编程语言/JAVA/Java谜题.md) Java谜题中包含死锁示例，展示了并发编程中的死锁场景\n- [/中间件/数据库/数据库优化.md](/中间件/数据库/数据库优化.md) 数据库优化中的锁冲突分析与死锁预防相关\n- [/软件工程/架构/系统设计/分布式/分布式一致性与协调机制.md](/软件工程/架构/系统设计/分布式/分布式一致性与协调机制.md) 分布式一致性协议中的锁机制与死锁问题\n- [/操作系统/多处理机系统.md](/操作系统/多处理机系统.md) 多处理机系统中的同步和锁机制与死锁预防相关\n- [/编程语言/JAVA/JAVA并发编程/基础概念.md](/编程语言/JAVA/JAVA并发编程/基础概念.md) Java并发编程基础概念中包含锁和同步机制\n- [/编程语言/JAVA/JAVA并发编程/并发工具类.md](/编程语言/JAVA/JAVA并发编程/并发工具类.md) Java并发工具类中的同步机制与死锁预防相关\n- [/编程语言/JAVA/高级/JDBC.md](/编程语言/JAVA/高级/JDBC.md) JDBC中的死锁预防和资源管理\n- [/软件工程/软件设计/代码质量/软件测试/性能测试.md](/软件工程/软件设计/代码质量/软件测试/性能测试.md) 性能测试中可发现死锁等并发问题\n- [/中间件/数据库/redis/集群.md](/中间件/数据库/redis/集群.md) Redis集群中的分布式锁与死锁预防\n- [/个人成长/职场/职业素养.md](/个人成长/职场/职业素养.md) 职业素养中提到的资源分配顺序与死锁预防相关\n- [/计算机网络/网络安全/Web安全.md](/计算机网络/网络安全/Web安全.md) Web安全中的并发控制与死锁预防\n- [/软件工程/架构模式/对象关系模式.md](/软件工程/架构模式/对象关系模式.md) 工作单元模式可减少死锁\n","metadata":"tags: ['操作系统', '并发编程']","hasMoreCommit":false,"totalCommits":9,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2025-12-08T18:28:28+08:00","author":"MY","message":"docs(操作系统): 重构死锁文档内容，完善死锁理论体系与工程实践","hash":"f660638ef86e88ce312f2851e5494d2e0645f965"},{"date":"2022-05-01T16:34:01+08:00","author":"MY","message":"✏️更新 死锁","hash":"9137fff5852a8ae90437eb011214ef54f385596b"},{"date":"2022-03-15T16:34:46+08:00","author":"cjiping","message":"✏️更新 死锁","hash":"dd32213c87de1c47eb03ce3f218c8fc99d827b48"},{"date":"2021-01-21T19:05:17+08:00","author":"cjiping","message":"✏更新 操作系统 死锁","hash":"a4de1a9372f3abe9f9ce615289b972629236f487"},{"date":"2020-08-06T10:47:01+08:00","author":"MY","message":"✏更新 死锁","hash":"46664d9b1a1bf8eee1d572e21069df82ce4c5fd9"},{"date":"2020-03-02T18:41:52+08:00","author":"MY","message":"操作系统 更新死锁","hash":"531b51c4c9a2aa7c37f27d605c5dbd03b6e794e7"},{"date":"2019-07-05T14:31:04+08:00","author":"My","message":"20190705","hash":"4f208c321252e5e648f7f5665b032cf311d7fb41"},{"date":"2019-07-05T12:28:07+08:00","author":"My","message":"20190705u","hash":"b2167ed370c3b392e41171b1d62e252a9b1513a4"}],"createTime":"2019-07-05T12:28:07+08:00"}