{"name":"虚拟化","id":"操作系统-虚拟化","content":"# 虚拟化与云\n\n虚拟化的必要条件：\n\n- 安全：虚拟机程序可以完全掌控虚拟资源\n- 保真：虚拟机里的程序行为要跟在裸机上执行相同\n- 高效：虚拟机的代码不受虚拟机程序干涉\n\n为了保证宿主机的安全性，虚拟机程序采用解释执行虚拟机发起的命令\n\n另一方面，对于某些指令，则需要CPU的支持，才能支持虚拟化，如Intel的VT（虚拟化技术）\n\n![第一类和第二类虚拟机管理程序](/assets/屏幕截图%202022-03-28%20154136.png)\n\n两者的区别在于第二类虚拟机程序运行在锁住操作系统之上\n\n第一类的代表有ESX Server 第二类的代表则有 VMware\n\n服务器虚拟化技术：\n\n- Hypervisor也叫VMM（virtual machine monitor）\n  - 在虚拟程序上运行操作系统\n- Containers容器化技术\n  - 虚拟程序上直接运行程序，无操作系统\n\n## 高效虚拟化技术\n\n![CPU支持虚拟化技术时, 客户操作系统陷入虚拟机程序的虚拟内核态](/assets/屏幕截图%202022-03-28%20155305.png)\n\n目前已有一些研究提出通过定义一个统一的虚拟化调用接口，然后操作系统直接使用这些虚拟化接口来进行半虚拟化或者全虚拟化，而虚拟化调用接口则和真正的硬件或者虚拟机程序打交道\n\n![虚拟化调用接口](/assets/屏幕截图%202022-03-28%20161310.png)\n\n### 在不支持虚拟化的平台上实现虚拟化\n\n客户及的敏感指令调用会被模拟会对虚拟机程序的指令调用，硬件不会真正执行这些指令\n\n![客户操作系统运行与虚拟机程序与用户进程之间](/assets/屏幕截图%202022-03-28%20155951.png)\n\n### 虚拟化的开销\n\nVT硬件虚拟化会产生大量陷入，而陷入会对缓存、TLB等造成不利影响\n\n软件形式的虚拟化在诸如页表管理上则需要不小的开销\n\n### VMware 原理\n\n- 虚拟化x86架构：通过决策算法模拟CPU指令或者直接执行\n- 客户操作系统为中心：针对特定操作系统做虚拟化支持\n- 虚拟硬件平台：通过将模拟前端硬件与后端实现硬件分离，进行硬件无关封装以物理硬件的虚拟化\n- 宿主操作系统作为驱动程序的寄生者，进行VMX与VMM的中间通信器\n\n![VMware架构](/assets/屏幕截图%202022-03-29%20164055.png)\n\n通过系统切换，将整个地址空间在宿主操作系统及VMM之间切换，这样VMM才能有对资源的完全掌控权限\n\n## 虚拟化容器\n\nchroot、namespaces、cgroups -> LXC -> Docker -> K8S\n\n三方面的兼容性：\n\n1. ISA兼容：目标机器指令集兼容性\n2. ABI兼容：目标系统或者依赖库的二进制兼容性\n3. 环境兼容：配置文件 环境变量等\n\n几种虚拟化技术：\n\n- 指令集虚拟化：通过软件来模拟不同ISA架构的处理器工作过程，将虚拟机发出的指令转换为符合本机ISA的指令\n- 硬件抽象层虚拟化：使用软件来模拟硬件，或者直接将硬件直通到虚拟机使用\n- 操作系统层虚拟化：采用隔离手段，使得不同进程拥有独立的系统资源和资源配额 也就是容器化\n- 运行库虚拟化：使用软件翻译的方法来模拟系统，它以一个独立进程来代替操作系统内核来提供目标软件运行所需的全部能力 如WINE\n- 语言层虚拟化：由虚拟机将高级语言生成的中间代码转换为目标机器可以直接执行的指令\n\n### 容器隔离\n\n- 隔离文件：chroot\n  - 当某个进程经过chroot操作之后，它的根目录就会被锁定在命令参数所指定的位置，以后它或者它的子进程将不能再访问和操作该目录之外的其他文件\n- 隔离访问：namespaces\n  - 由内核直接提供的全局资源封装如文件 进程 用户 网络等信息，是内核针对进程设计的访问隔离机制\n- 隔离资源：cgroups\n  - 控制进程对资源的使用\n\n### 容器封装\n\n- 封装系统：LinuxX Containers\n- 封装应用：Docker\n- 封装集群：Kubernetes\n\n### 基于容器构建系统\n\n- 隔离：名称空间\n- 协作：基于同一个pod\n\n这里在K8S中 相互协作的容器运行在同一个pod中 这个pod就是被调度的基本单位\n\nK8S的协作 如果运行单个pod 那么系统是十分脆弱的 使用ReplicaSet等手段来保持住系统的状态\n\n这种组件被称为控制回路：\n\n```mermaid\nstateDiagram-v2\n  [*] --> 调节项: 误差 = 期望值 - 实际值\n  调节项 --> 控制器: 调节器根据误差调整\n  控制器 --> 受控资源: 受控资源根据控制器的输出调节自身\n  受控资源 --> 指标监视器: 监控指标\n  指标监视器 --> 调节项: 输出\n```\n\n### 应用为中心的封装\n\n- Kustomize：使用一个配置文件描述配置文件\n- Helm与Chart：模仿Linux包管理器的思路去管理Kubernetes应用\n- Operator与CRD：把应用封装为另一种更高层次的资源，再把Kubernetes的控制器模式从面向于内置资源，扩展到了面向所有自定义资源\n- 开放应用模型\n\n## 内存虚拟化\n\n虚拟机作为一个中间层，需要维护客户操作系统与真实硬件内存页表的映射\n\n- 嵌套页表的硬件扩展：由原来的虚拟页表-物理页表变成客户机虚拟页表-客户机物理页表-宿主机物理页表\n- 回收内存：这就需要虚拟机自己作为中间层，来管理内存\n\n## IO虚拟化\n\n- IO MMU：现代硬件具备 IO MMU, 可以实现设备穿透（直接从物理硬件映射到虚拟机），也可以保证设备隔离\n- 设备域：用专门的一台虚拟机管理硬件，其他虚拟机通过这台虚拟机来使用硬件（半虚拟化）\n- 单根IO虚拟化：由IO设备本身提供虚拟化支持，通过提供VF（虚拟化函数）给虚拟机使用\n\n## 虚拟装置\n\n- 封装虚拟机，交付运行，跟现阶段的容器很像\n\n## 多核CPU上的虚拟机\n\n通过复用相同的内存，使用**去重**技术避免重复保存相同的数据，大体就是通过先判断内存块的散列值，然后再比对具体内容来判断是否能复用，当内存块被修改时，采取写时复制技术，复制出新的内存块给虚拟机使用\n","metadata":"","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2024-11-13T19:11:32+08:00","author":"MY","message":"📦操作系统","hash":"e61620c72f4b61f38fd4124dcae670b77ff2f358"},{"date":"2023-09-12T13:49:02+08:00","author":"MY","message":"📦云原生","hash":"4c213f91c490c073914b5d702ed791d18d3d3d99"},{"date":"2022-03-29T17:00:25+08:00","author":"MY","message":"✏️更新 虚拟化与云","hash":"f731811fe7b7ac97741241804f2ebcf94b1e61fc"},{"date":"2022-03-28T16:55:57+08:00","author":"MY","message":"✏️更新 虚拟化与云","hash":"b9e39e41ad346942f46121e397c1e7ba77be7bbb"},{"date":"2019-07-06T11:55:58+08:00","author":"My","message":"20190706","hash":"83a03f95e0ae02e0dcdda71139cc3e596f295779"},{"date":"2019-07-05T14:31:04+08:00","author":"My","message":"20190705","hash":"4f208c321252e5e648f7f5665b032cf311d7fb41"}],"createTime":"2019-07-05T14:31:04+08:00"}