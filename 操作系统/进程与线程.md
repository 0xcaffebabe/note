# 进程与线程

## 进程
在某一个瞬间，CPU只能运行一个进程。
### 进程模型
计算机上所有可运行的软件，通常包括操作系统，被组织成若干**顺序进程**，称为**进程**

*思考：程序与进程的关系*
### 进程的创建
导致进程创建的4种主要事件：
- 系统初始化
- 系统调用
- 用户请求创建
- 批处理作业初始化

**守护进程**：停留在后台的线程

*思考：写时复制*
### 进程的终止
终止的条件：
- 正常退出（自愿）
- 出错退出（自愿）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）
### 进程的层次结构
UNIX中，进程创建一个新进程后，该进程称为其的父进程，它与它的所有后代组成一个**进程组**。
但在Windows中，进程之间没有层次关系，除了父进程在创建子进程时，会获得其的句柄，除此之外，没有任何联系。
### 进程的状态
- 运行态（正在占用CPU）
- 就绪态（可运行，但还没有运行）
- 阻塞态（正在等待外部事件，如IO读取）

*思考：像不像线程*

**调度程序**：负责切换进程的执行
### 进程的实现
为实现进程模型，操作系统维护一张表：**进程表**
进程表主要包括三项内容：
- 进程管理
    - 寄存器
    - 程序计数器
    ...
- 存储管理
    - 正文段指针
    ...
- 文件管理
    - 根目录
    - 工作目录
    ...

**中断向量**：中断服务程序的入口地
### 多道程序设计模型
CPU利用率 = 1-P<sup>n</sup>
n称为**多道程序设计的道数**
P为CPU空转的概率
## 线程
### 线程的使用
使用线程的理由：
- 更好描述程序的行为
- 线程比进程更轻量
- 提高性能

*思考：有限状态机*

### 经典的线程模型
**每个线程都有自己的堆栈**

### POSIX线程
一种线程标准，定义的线程包叫做**pthread**

### 在用户空间中实现线程
用户级线程的优点：
- 快
- 可以定制自己的调度算法
局限性：
- 如何实现阻塞系统调用
### 在内核中实现线程
代价很大
### 混合实现
### 调度程序激活机制
*上行调用*
### 弹出线程
一个消息的到达导致系统创建一个处理该消息的线程
### 使单线程代码多线程化
*思考：全局变量的问题*

## 进程间通信
有关问题：
- 进程之间传递信息
- 进程之间的活动不会出现交叉
- 进程之间运行的顺序
### 竞争条件
两个或多个进程读写某些共享数据，得到的结果取决于进程运行的精确时序
### 临界区
通过**互斥**来组织多个进程同时读写共享数据
把对共享内存进行访问的程序片段称为临界区
### 忙等待的互斥
- 屏蔽中断：进程进入临界区后屏蔽所有中断，这样系统就无法切换到其他进程了
- 锁变量
- 严格轮换法：

















