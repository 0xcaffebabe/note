{"name":"进程与线程","id":"操作系统-进程与线程","content":"# 进程与线程\n\n## 一、并发系统的第一性原理\n\n### 1. 并发的本质是什么？\n\n**并发不是为了更快，而是为了更好地使用有限资源。**\n\n在任何计算系统中，都存在三种不可回避的约束：\n\n1. **计算资源有限**（CPU 核心、内存、I/O）\n2. **任务数量不确定**（用户请求、系统服务、后台作业）\n3. **任务执行时间不可预测**（I/O、外部事件、中断）\n\n因此，并发系统的本质目标是：\n\n> 在有限资源条件下，对多个任务的**时间、状态与共享资源**进行有序管理。\n\n这直接引出并发系统必须回答的三个根本问题：\n\n1. **执行单元是什么？**（谁在“跑”）\n2. **如何分配 CPU？**（谁先跑、跑多久）\n3. **如何安全协作？**（如何共享而不出错）\n\n后续所有概念，都是这三个问题的不同解法。\n\n---\n\n## 二、执行单元的抽象演进：进程 · 线程 · 协程\n\n### 2.1 执行单元的设计哲学\n\n执行单元的演进，本质是三种诉求之间的权衡：\n\n* **隔离性**（安全、稳定）\n* **并发性**（吞吐、响应）\n* **调度控制权**（灵活性、成本）\n\n---\n\n### 2.2 进程：资源隔离的基本单位\n\n**进程不是“正在运行的程序”，而是：**\n\n> 一个拥有**独立资源视图**的执行容器。\n\n#### 原理层定义\n\n* 拥有独立的地址空间\n* 拥有完整的资源描述（内存、文件、信号）\n* 是操作系统进行**资源分配与保护**的基本单位\n\n#### 设计动机\n\n* 防止错误扩散（一个进程崩溃不影响其他进程）\n* 建立清晰的安全与权限边界\n\n#### 代价\n\n* 创建与切换成本高\n* 进程间通信复杂\n\n> **进程解决的是“安全与隔离”问题，而不是“高并发”问题。**\n\n---\n\n### 2.3 线程：共享资源下的并发执行\n\n**线程的引入不是为了节省 CPU，而是为了节省“进程的重复成本”。**\n\n#### 原理层定义\n\n> 线程是**共享进程资源的执行流**，是调度的基本单位。\n\n#### 核心特征\n\n* 共享地址空间与全局资源\n* 拥有独立的栈与寄存器上下文\n* 可被内核抢占调度\n\n#### 本质权衡\n\n| 获得        | 付出        |\n| --------- | --------- |\n| 更低创建/切换成本 | 共享状态导致复杂性 |\n| 更高并发能力    | 同步与一致性问题  |\n\n> **线程本质上是：用复杂性换性能。**\n\n---\n\n### 2.4 协程：调度权下放到用户态\n\n**协程的出现不是因为线程“不够快”，而是因为“内核调度太贵、太不可控”。**\n\n#### 原理层定义\n\n> 协程是由程序显式让渡执行权的执行单元。\n\n#### 关键特征\n\n* 切换发生在用户态\n* 不依赖内核抢占\n* 通常以函数/栈为单位保存上下文\n\n#### 本质优势\n\n* 极低切换成本\n* 调度语义可被程序精确控制\n\n#### 本质限制\n\n* 不能自动利用多核\n* 阻塞系统调用会阻塞整个调度器（除非运行时接管）\n\n> **协程的核心价值在于：控制权，而不是并行度。**\n\n---\n\n### 2.5 执行单元统一对比（原理层）\n\n| 维度   | 进程   | 线程  | 协程   |\n| ---- | ---- | --- | ---- |\n| 抽象层级 | 资源容器 | 执行流 | 调度原语 |\n| 资源隔离 | 强    | 无   | 无    |\n| 调度者  | 内核   | 内核  | 用户态  |\n| 切换成本 | 高    | 中   | 极低   |\n| 设计目标 | 安全   | 并发  | 可控   |\n\n---\n\n## 三、调度：有限 CPU 的分配艺术\n\n### 3.1 调度的第一性问题\n\n> 当多个执行单元同时就绪，而 CPU 有限时，**谁先运行？运行多久？**\n\n调度的本质是一个**资源分配问题**，不存在绝对最优解，只有目标权衡。\n\n---\n\n### 3.2 调度目标的分类\n\n| 系统类型  | 核心目标      |\n| ----- | --------- |\n| 批处理系统 | 吞吐量、周转时间  |\n| 交互式系统 | 响应时间、公平性  |\n| 实时系统  | 截止时间、可预测性 |\n\n调度算法的差异，本质是**目标函数不同**。\n\n---\n\n### 3.3 策略与机制分离\n\n* **机制（Mechanism）**：\n\n  * 上下文切换\n  * 中断\n  * 就绪队列\n\n* **策略（Policy）**：\n\n  * FCFS / SJF / 时间片\n  * 优先级 / 多级反馈队列\n\n> 操作系统只负责提供“如何切换”，不决定“该切换给谁”。\n\n这是调度设计中最重要、也最稳定的思想之一。\n\n---\n\n## 四、协作与约束：并发正确性的核心\n\n### 4.1 并发错误的根源\n\n所有并发错误，本质都来自：\n\n> **多个执行单元，在不可预测的时序下，访问共享状态。**\n\n这导致三类问题：\n\n* 竞争条件\n* 不一致可见性\n* 死锁 / 饥饿\n\n---\n\n### 4.2 临界区：共享状态的最小边界\n\n**临界区不是代码问题，而是“状态所有权”的问题。**\n\n设计原则：\n\n1. 同一时刻只允许一个执行单元进入\n2. 不依赖 CPU 数量与速度假设\n3. 不阻塞临界区外的执行\n4. 有限等待\n\n---\n\n### 4.3 同步机制的抽象分层\n\n#### 第一层：忙等待（时间换简单）\n\n* 自旋锁\n* TSL / CAS\n\n#### 第二层：阻塞同步（让出 CPU）\n\n* 信号量\n* 互斥量\n* 条件变量\n\n#### 第三层：结构化并发\n\n* 管程\n* 屏障\n* 读写锁\n\n#### 第四层：避免共享\n\n* 消息传递\n* RCU\n\n> **同步机制的演进趋势：从“控制访问”到“消除共享”。**\n\n---\n\n## 五、通信模型：共享内存 vs 消息传递\n\n### 5.1 两种世界观\n\n| 模型   | 核心思想        |\n| ---- | ----------- |\n| 共享内存 | 状态共享 + 同步约束 |\n| 消息传递 | 状态隔离 + 显式通信 |\n\n两者不是对错，而是**复杂性转移的位置不同**。\n\n---\n\n### 5.2 IPC 机制的层级关系\n\n* 管道 / FIFO：字节流\n* 消息队列：结构化通信\n* 共享内存：最高性能，最高风险\n* 套接字：跨机器边界\n\n---\n\n## 六、经典并发问题的统一视角\n\n| 问题      | 本质        |\n| ------- | --------- |\n| 哲学家就餐   | 资源竞争 + 死锁 |\n| 读者-写者   | 不同访问语义    |\n| 生产者-消费者 | 速率不匹配     |\n\n这些问题的价值不在解法，而在于：\n\n> **暴露并发系统中不可避免的结构性矛盾。**\n\n---\n\n## 七、从操作系统到语言运行时\n\n### 7.1 为什么现代语言要“重造并发模型”？\n\n* 内核线程太重\n* 阻塞语义不可控\n* 调度策略无法表达业务意图\n\n因此出现：\n\n* Go：Goroutine + M:N 调度\n* Java：线程池 + Loom\n* Erlang：Actor\n\n> **并发的未来，不是更快的线程，而是更高层的抽象。**\n\n---\n\n## 八、总结：稳定知识的沉淀\n\n这套并发体系中，真正长期稳定的不是 API，而是：\n\n* 并发的第一性原理\n* 执行单元的权衡逻辑\n* 调度的目标函数\n* 协作的约束模型\n\n## 关联内容（自动生成）\n\n- [/操作系统/死锁.md](/操作系统/死锁.md) 死锁是并发系统中进程/线程资源竞争可能导致的问题，与本文档中提到的同步机制和资源管理密切相关\n- [/计算机网络/IO模型.md](/计算机网络/IO模型.md) I/O模型涉及进程/线程如何处理I/O操作，与本文档中的执行单元和调度概念紧密相关\n- [/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md](/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md) Java并发编程是进程与线程概念的实际应用，展示了如何在编程语言层面实现并发控制\n- [/中间件/数据库/数据库系统/事务管理/事务.md](/中间件/数据库/数据库系统/事务管理/事务.md) 数据库事务管理涉及并发控制，与操作系统中的进程/线程同步机制有相似之处\n- [/软件工程/架构/系统设计/高并发.md](/软件工程/架构/系统设计/高并发.md) 高并发系统设计需要深入理解进程与线程的工作原理，以实现高效的资源利用和任务调度\n- [/操作系统/虚拟化.md](/操作系统/虚拟化.md) 虚拟化技术与进程和线程管理密切相关，涉及资源隔离和调度的高级概念\n- [/编程语言/JAVA/JAVA并发编程/线程.md](/编程语言/JAVA/JAVA并发编程/线程.md) Java线程是操作系统线程概念的具体实现，展示了线程在编程语言中的应用\n- [/操作系统/linux/Linux性能优化.md](/操作系统/linux/Linux性能优化.md) Linux性能优化涉及进程调度和线程管理，与本文档内容密切相关\n- [/计算机网络/运输层.md](/计算机网络/运输层.md) 运输层协议处理进程间通信，与操作系统中的进程概念直接相关\n- [/中间件/web中间件/Nginx.md](/中间件/web中间件/Nginx.md) Nginx的并发处理模型与进程和线程的使用方式密切相关\n","metadata":"tags: ['操作系统', '并发编程', '计算机系统']","hasMoreCommit":true,"totalCommits":16,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2026-01-27T18:45:24+08:00","author":"MY","message":"feat(process-thread): 重构进程与线程文档内容并添加图片资源","hash":"6eedf47fe628d2939892f0b67f7056472fe83cfb"},{"date":"2025-11-16T21:30:56+08:00","author":"MY","message":"docs: 统一并精简文档标签","hash":"21362e9d7aeb62e05364cd5e7f3a3c24d7e293c7"},{"date":"2024-11-13T19:11:32+08:00","author":"MY","message":"📦操作系统","hash":"e61620c72f4b61f38fd4124dcae670b77ff2f358"},{"date":"2024-03-01T18:59:54+08:00","author":"MY","message":"✏操作系统","hash":"99b3c5cbeaa75dc349453feebc7dc5d3ff62db8b"},{"date":"2023-08-23T20:19:40+08:00","author":"MY","message":"✏进程与线程","hash":"8a4312a21cf54e20c81b1c67ea4e799eccd5683a"},{"date":"2022-07-10T15:08:09+08:00","author":"MY","message":"✏️更新 操作系统","hash":"96cd8f3752fc76a06e935a9069dcf2c6a322d797"},{"date":"2022-05-06T19:06:57+08:00","author":"cjiping","message":"✏️更新 进程与线程","hash":"8bb5e1f556db66fabe093fc233646205b16b980a"},{"date":"2022-04-25T21:44:13+08:00","author":"MY","message":"✏️更新 进程与线程","hash":"7c27739d977dceda227eb3b35b9e14a7e61e9d87"},{"date":"2022-04-24T23:11:07+08:00","author":"MY","message":"✏️更新 进程与线程","hash":"1d71cc090cbda3195b324c528c5ce61d922093d9"}],"createTime":"2019-06-04T17:22:12+08:00"}