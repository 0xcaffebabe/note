# 事务

> 构成单一逻辑工作单元的操作集合称为事务，可以通过commit提交一个事务，也可以使用rollback回滚

![批注 2020-03-08 193412](/assets/批注%202020-03-08%20193412.png)

## ACID

- 原子性(Atomicity)：不可分割的最小操作单位，要么同时成功，要么同时失败
- 一致性(Consistency)：事务操作前后，数据总量不变
- 隔离性(Isolation)：多个事务之间相互独立
- 持久性(Durability)：当事务提交或回滚后，数据会持久化的保存数据

只有满足一致性，事务执行结果才是正确的
事务串行执行，就能确保隔离性，此时只要满足原子性，就能满足一致性
在并发执行的情况下，要满足原子性和隔离性，才能满足一致性
满足持久性的原因是为应对系统崩溃的情况

![批注 2020-03-08 194014](/assets/批注%202020-03-08%20194014.png)

## 存储结构

_稳定性存储器_

## 事务原子性和持久性

**补偿事务**

- 活动的
- 部分提交的
- 失败的
- 终止的
- 提交的

![](https://static.oschina.net/uploads/space/2018/0514/120548_mjP9_3403834.png)

## 事务隔离性

- 提高吞吐量和资源利用率
- 减少等待时间

**并发控制**

## 可串行化

## 事务隔离性和原子性

- 可恢复调度
- 无级联调度

## 事务隔离性级别

- 可串行化
  - 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题
- 可重复读
  - 保证在同一个事务中多次读取同一数据的结果是一样的
- 已提交读
  - 一个事务只能读取已经提交的事务所做的修改
- 未提交读
  - 事务中的修改，即使没有提交，对其它事务也是可见的

**脏写**

## 隔离性级别的实现

> 并发控制机制

- 锁
- 时间戳
- 多版本和快照隔离

## 并发一致性问题

并发环境下，事务的隔离性很难保证

解决并发一致性问题的方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现

### 丢失修改

两个事务修改同一个数据，后修改的事务覆盖之前事务的修改

![批注 2020-03-08 194449](/assets/批注%202020-03-08%20194449.png)

### 读脏数据

一个事务修改了数据，随后回滚了，但是这个数据在回滚之前被另外一个事务读到了

![批注 2020-03-08 194657](/assets/批注%202020-03-08%20194657.png)

### 不可重复读

一个事务读取数据后，这个数据被另外的事务修改了，先前的事务再读一次，发现两次读取的数据不一致

![批注 2020-03-08 194838](/assets/批注%202020-03-08%20194838.png)

### 幻读

一个事务读取某个范围的数据，另外一个事务在这个范围上修改了数据，从而导致先前的事务两次读取数据不一致

![批注 2020-03-08 195126](/assets/批注%202020-03-08%20195126.png)

## 事务的SQL语句表示
