# 事务

> 构成单一逻辑工作单元的操作集合称为事务，可以通过commit提交一个事务，也可以使用rollback回滚

![批注 2020-03-08 193412](/assets/批注%202020-03-08%20193412.png)

## ACID

- 原子性(Atomicity)：不可分割的最小操作单位，要么同时成功，要么同时失败

这点相较于并发编程的原子性有所不同：如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。与并发编程原子性较为相似概念的是ACID的隔离性

- 一致性(Consistency)：事务操作前后，数据总量不变

一致性的这种概念取决于应用程序对不变量的观念，应用程序负责正确定义它的事务，并保持一致性。如果你的应用程序非要写入脏数据，那么数据库也无能为力

- 隔离性(Isolation)：多个事务之间相互独立

隔离性最强的实现手段就是可序列化，但这种方式对性能极差。如Oracle中有一个名为“可序列化”的隔离级别，但实际上它实现了一种叫做快照隔离（snapshot isolation） 的功能，这是一种比可序列化更弱的保证。

- 持久性(Durability)：当事务提交或回滚后，数据会持久化的保存数据

完美的持久性是不存在的 ：如果所有硬盘和所有备份同时被销毁，那显然没有任何数据库能救得了你，最好抱着怀疑的态度接受任何理论上的“保证”。

----

只有满足一致性，事务执行结果才是正确的。事务串行执行，就能确保隔离性，此时只要满足原子性，就能满足一致性，在并发执行的情况下，要满足原子性和隔离性，才能满足一致性。

满足持久性的原因是为应对系统崩溃的情况，本质上满足持久性最终的目的也是为了满足一致性

AID是因 C是果

![批注 2020-03-08 194014](/assets/批注%202020-03-08%20194014.png)

为了应对系统崩溃，事务采取了事务日志，也就是追加的方式记录所有操作，这样在系统崩溃后也可以根据这些日志进行恢复。

### 实现原子性和持久性

原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态

但事实上磁盘写入总需要个过程，需要个额外的机制来保证出现下列情况后能进行恢复：

1. 未提交事务，写入后崩溃
2. 已提交事务，写入前崩溃

数据库通过修改数据前写入日志的情况来达到崩溃后能恢复的目的，称之为提交日志

同时为了实现事务功能 通过undo log来记录数据的修改的情况，以便随时回滚

### 实现隔离性



## 存储结构

_稳定性存储器_

## 事务原子性和持久性

**补偿事务**

- 活动的
- 部分提交的
- 失败的
- 终止的
- 提交的

![](https://static.oschina.net/uploads/space/2018/0514/120548_mjP9_3403834.png)

## 事务隔离性

- 提高吞吐量和资源利用率
- 减少等待时间

**并发控制**

## 可串行化

## 事务隔离性和原子性

- 可恢复调度
- 无级联调度

## 事务隔离性级别

从上往下，隔离级别递减

- 可串行化 SERIALIZABLE
  - 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题 实际使用中会导致大量超时和锁争用

每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。如果需要在单线程执行的事务中访问，系统就会变得非常慢

- 可重复读 REPEATABLE-READ
  - 保证在同一个事务中多次读取同一数据的结果是一样的
- 已提交读 READ-COMMITTED
  - 一个事务只能读取已经提交的事务所做的修改

数据库通过使用行锁（row-level lock） 来防止脏写。但想要防止脏读使用读锁就8太行了

- 未提交读 READ-UNCOMMITTED
  - 事务中的修改，即使没有提交，对其它事务也是可见的

隔离级别             | 脏读 | 不可重复读 | 幻读 | 加锁读
---------------- | -- | ----- | -- | ---
READ-UNCOMMITTED | √  | √     | √  | ×
READ-COMMITTED   | ×  | √     | √  | ×
REPEATABLE-READ  | ×  | ×     | √  | ×
SERIALIZABLE     | ×  | ×     | ×  | √


无论是脏读 幻读 不可重复读，原因都是因为隔离性被破坏 实现上面各种隔离级别都是使用读锁 写锁 或者范围锁相互配合来实现的

MVCC是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的

**脏写**

## 隔离性级别的实现

> 并发控制机制

- 锁
- 时间戳
- 多版本和快照隔离

## 并发一致性问题

并发环境下，事务的隔离性很难保证

解决并发一致性问题的方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现

### 丢失修改

两个事务修改同一个数据，后修改的事务覆盖之前事务的修改

![批注 2020-03-08 194449](/assets/批注%202020-03-08%20194449.png)

丢失修改有几种解决方案：

- 原子写：通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它
- 显式锁定：通过加锁只允许一个事务
- 原子操作和锁是通过强制读取-修改-写入序列按顺序发生,另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列
- CAS操作

### 脏读

一个事务修改了数据，随后回滚了，但是这个数据在回滚之前被另外一个事务读到了

![批注 2020-03-08 194657](/assets/批注%202020-03-08%20194657.png)

### 不可重复读

一个事务读取数据后，这个数据被另外的事务修改了，先前的事务再读一次，发现两次读取的数据不一致

![批注 2020-03-08 194838](/assets/批注%202020-03-08%20194838.png)

### 幻读

一个事务读取某个范围的数据，另外一个事务在这个范围上修改了数据，从而导致先前的事务两次读取数据不一致

![批注 2020-03-08 195126](/assets/批注%202020-03-08%20195126.png)

### 不可重复读与幻读

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

## 死锁

为了打破死锁，必须通过部分或者完全回滚某个事务。

## 单对象多对象事务

新型文档数据库也提供了原子性和隔离性的实现，比如通过编程语言的原子操作或者CAS操作来实现，

