# 分布式事务

> 在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务。

## 分布式系统

> 部署在不同结点上的系统通过网络交互来完成协同工作的系统

## CAP理论

![批注 2019-10-31 194221](/assets/批注%202019-10-31%20194221.png)

- 一致性(Consistency)：服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。
  - 对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性
- 可用性(Availability)：服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结 点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。
  - 对于用户的每一个操作请求总是能够在有限的时间内返回结果
- 分区容忍性(Partition Tolerance)：分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。

最多只能同时满足其中两项

![202031017918](/assets/202031017918.png)

分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的，所以CAP理论实际上是要在可用性和一致性之间做权衡

- 保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性
- 保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致

## BASE理论

- BA：（Basically Available ），基本可用
  - 分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性
- S：（ Soft State），软状态，状态可以在一段时间内不同步
  - 允许系统不同节点的数据副本之间进行同步的过程存在时延
- E：（Eventually Consistent ），最终一致，在一定的时间窗口内， 最终数据达成一致即可

## 柔性事务与刚性事务

- 柔性事务满足BASE理论（基本可用，最终一致）
- 刚性事务满足ACID理论

## Paxos

对多个节点产生的值，该算法能保证只选出唯一一个值

### 节点类型

- 提议者（Proposer）：提议一个值
- 接受者（Acceptor）：对每个提议进行投票
- 告知者（Learner）：被告知投票的结果，不参与投票过程

![202031620538](/assets/202031620538.jpg)

## Raft

分布式一致性协议，主要是用来竞选主节点

有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段

当 Candidate获得超过半数票时，就成为Leader节点
如果有多个Candidate获得相同的票数，则重新开始投票
每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低

### 数据同步

- 自客户端的修改都会被传入 Leader。此时该修改还未被提交，只是写入日志中
- Leader 会把修改复制到所有 Follower
- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交
- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致

## 解决方案

### 两阶段提交(2PC)

![2020310184042](/assets/2020310184042.png)

准备阶段：协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志，然后锁定资源，执行操作，但并不提交

提交阶段:如果每个参与者明确返回准备成功，则协调者向参与者发送提交指令，参与者释放锁定的资源，如何任何一个参与者明确返回准备失败，则协调者会发送中止指令，参与者取消已经变更的事务，释放锁定的资源。

- 优点：实现强一致性
- 缺点：整个事务的执行需要由协调者在多个节点之间去协调
  - 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作
  - 协调者如果发生故障会造成很大影响
  - 当在提交阶段网络发生异常，只有部分参与者commit了消息，造成数据不一致
  - 任意一个节点失败就会导致整个事务失败

### 三阶段提交(3PC)

询问阶段：协调者询问参与者是否可以完成指令，协调者只需要回答是还是不是，而不需要做真正的操作，这个阶段超时将导致事务中止

准备阶段

提交阶段

### 事务补偿(TCC)

![2020321151354](/assets/2020321151354.png)

- 优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好。
- 缺点：开发成本高，每个事务操作每个参与者都需要实现try/confirm/cancel三个接口。

### 使用消息队列实现最终一致性

![批注 2019-10-31 201018](/assets/批注%202019-10-31%20201018.png)

#### 最大努力通知方案

类似于第三方支付的支付回调

#### 本地消息表

- 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中
- 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发
- 分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作

![202031620440](/assets/202031620440.png)

#### 补偿的方式

- 生产者一定要将数据投递到MQ服务器中（消息确认机制）
- MQ消费者消息能够正确消费消息，采用手动ACK模式（当消费者消费消息失败，则不确认消息，消息进行重试）
- 当生产者出错回滚，发送到补偿队列的消息会检测生产者的数据是否提交成功，如果没有，则补偿队列的消费者会重新执行一遍生产者没有提交的事务

![批注 2020-03-16 164628](/assets/批注%202020-03-16%20164628.png)

## LCN

### 原理

![2020311161130](/assets/2020311161130.png)

### 使用

- 启动tx-manager

#### 客户端

- 依赖

```xml
<dependency>
    <groupId>com.codingapi.txlcn</groupId>
    <artifactId>txlcn-tc</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>

<dependency>
    <groupId>com.codingapi.txlcn</groupId>
    <artifactId>txlcn-txmsg-netty</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

- 配置

```java
@EnableDistributedTransaction
```

- 使用

发起者

```java
@LcnTransaction
@Transactional(rollbackFor = Exception.class)
public void consume(){
    jdbcTemplate.update("INSERT INTO tb_order VALUES(1,1,'test')");
    String result = producerRemote.home();
}
```

参与者

```java
@LcnTransaction
@Transactional(rollbackFor = Exception.class)
public String home() {
    jdbcTemplate.update("UPDATE stock SET stock = stock -1 WHERE product_id = 1");
    return name+port;
}
```

### 集群

- 启动多台tx-manager
- 发起者与参与者配置地址

```properties
tx-lcn.client.manager-address=127.0.0.1:8070,127.0.0.1:8071
```
