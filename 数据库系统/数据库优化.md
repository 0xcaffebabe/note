# 数据库优化

## 优化原因

- 避免网站出现访问错误
- 低效的查询导致数据库不稳定
- 优化用户体验

## 优化方面

- 硬件
- 系统配置
- 数据库表结构
- SQL与索引

成本从下到上递增，效果从上到下递减

# MYSQL优化

## 开启慢查询

```shell
set global slow_query_log=ON; #开启慢查询
set global long_query_time=1.0; #设置记录时长为1秒
set global log_queries_not_using_indexes = ON; #不适用索引
```

慢查询日志地址：

地址存储在slow_query_log_file变量中

## 慢查询日志存储格式

```
# Time: 2019-11-29T06:01:43.909217Z 执行时间
# User@Host: root[root] @ localhost []  Id:     9 主机信息
# Query_time: 0.104442 查询时间
  Lock_time: 0.000153 锁定时间
   Rows_sent: 1  发送行数
   Rows_examined: 16249 锁扫描行数
SET timestamp=1575007303; 执行时间戳
select count(*) from actor,payment; SQL
```

## 慢查询分析工具

- mysqldumpslow

```shell
mysqldumpslow -t 10 日志地址 # 分析前10条记录
```

- pt-query-digest

```shell
wget percona.com/get/pt-query-digest # 下载
chmod u+x pt-query-digest # 添加执行权限
/pt-query-digest 慢查询日志地址 # 分析日志
```

## 问题定位

- 次数多、时间长
- IO大
- 未命中索引

## 查询执行计划

```sql
explain sql
```

```text
id: 1
  select_type: SIMPLE # 
        table: staff
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_fk_store_id
      key_len: 1
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using index
```

- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
- **select_type**: SELECT 查询的类型.

  - SIMPLE, 表示此查询不包含 UNION 查询或子查询
  - PRIMARY, 表示此查询是最外层的查询
  - UNION, 表示此查询是 UNION 的第二或随后的查询
  - DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询
  - UNION RESULT, UNION 的结果
  - SUBQUERY, 子查询中的第一个 SELECT
  - DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

- table: 查询的是哪个表

- partitions: 匹配的分区
- type: join 类型 通常来说, 不同的 type 类型的性能关系:ALL < index < range ~ index_merge < ref < eq_ref < const < system
- possible_keys: 此次查询中可能选用的索引
- **key**: 此次查询中确切使用到的索引
- key_len:表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到
- **rows**:估算 SQL 要查找到结果集需要扫描读取的数据行数，这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好
- extra:EXplain 中的很多额外的信息会在 Extra 字段显示

  - Using filesort:表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果，一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大
  - Using index："覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错
  - Using temporary：查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化

## 索引优化

### 索引

### 创建索引

ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引

```sql
ALTER TABLE table_name ADD INDEX index_name (column_list)

ALTER TABLE table_name ADD UNIQUE (column_list)

ALTER TABLE table_name ADD PRIMARY KEY (column_list)
```

CREATE INDEX可对表增加普通索引或UNIQUE索引

```sql
CREATE INDEX index_name ON table_name (column_list)

CREATE UNIQUE INDEX index_name ON table_name (column_list)
```

获取索引

```sql
show keys  from table_name
```

### 何时使用索引

- 主键列中创建索引
- 多表连接时连接列创建索引
- where子句查询的列
- 需要经常GROUP BY和ORDER BY的列

### 索引优化

- 找出重复冗余索引
- 索引不包含NULL
- 短索引
- 排序的索引问题
- like语句前%不会使用索引
- 列上运算问题
- NOT IN会进行全表扫描

## 数据库结构优化

- 选择合适的数据类型
- 范式化
- 反范式化
- 垂直拆分
- 水平拆分

## 数据访问优化

### 减少请求的数据量

- SELECT 只返回必要的列
- 使用LIMIT只返回必要的行
- 在内存缓存数据避免查询数据库

### 减少扫描行数

使用索引覆盖来覆盖查询

## 查询方式优化

### 分解大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源

### 分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联

- 可以有效利用缓存
- 减少锁竞争
- 应用层拼接数据，数据库拆分更容易，从而做到高性能和可伸缩
- 单表查询效率可能比连接高

# 配置优化

- 设置文件最大打开数
- 设置最大连接数
- 设置back_log

  - 存放等待连接的堆栈大小

- interactive_timeout
- 缓冲区

  - key_buffer_size
  - query_cache_size
  - record_buffer_size
  - read_rnd_buffer_size
  - sort_buffer_size
  - join_buffer_size
  - tmp_table_size
  - table_cache
  - max_heap_table_size
  - thread_cache_size
  - thread_concurrency
  - wait_timeout

- 关于InnoDB

# 执行顺序

![](https://images0.cnblogs.com/i/243280/201406/082230505368061.png)

- FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1
- ON: 对虚表VT1进行ON筛选，只有那些符合`<join-condition>`的行才会被记录在虚表VT2中。
- JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。
- WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合`<where-condition>`的记录才会被插入到虚拟表VT4中。
- GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.
- CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.
- HAVING： 对虚拟表VT6应用having过滤，只有符合`<having-condition>`的记录才会被 插入到虚拟表VT7中。
- SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。
- DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.
- ORDER BY: 将虚拟表VT9中的记录按照`<order_by_list>`进行排序操作，产生虚拟表VT10.
- LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。

# 执行引擎

## MyISAM存储引擎

1、大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持。 2、当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成。 3、每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16 4、NULL被允许在索引的列中，这个值占每个键的0~1个字节 5、可以把数据文件和索引文件放在不同目录（InnoDB是放在一个目录里面的）

## InnoDB存储引擎

1、InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合

2、InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的

3、InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上

4、InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键

## MEMORY存储引擎

1、MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度 2、MEMORY存储引擎执行HASH和BTREE缩影 3、可以在一个MEMORY表中有非唯一键值 4、MEMORY表使用一个固定的记录长度格式 5、MEMORY不支持BLOB或TEXT列 6、MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引 7、MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表） 8、MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享 9、当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）

## 对比

功能     | MYISAM | Memory | InnoDB | Archive
------ | ------ | ------ | ------ | -------
存储限制   | 256TB  | RAM    | 64TB   | None
支持事务   | No     | No     | Yes    | No
支持全文索引 | Yes    | No     | No     | No
支持数索引  | Yes    | Yes    | Yes    | No
支持哈希索引 | No     | Yes    | No     | No
支持数据缓存 | No     | N/A    | Yes    | No
支持外键   | No     | No     | Yes    | No
