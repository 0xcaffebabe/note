# 程序编码

在编译时指定'-Og'选项让GCC产生符合原始程序结构的机器代码

## 机器级代码

对C语言隐藏， 但对汇编代码可见的： 

- 程序计数器
- 整数寄存器文件
- 条件码寄存器
- 向量寄存器

输出c源码的机器表示

```shell
gcc -Og -S mstore.c
```

机器代码与反汇编的特性： 

- x86-64的指令长度从1-15字节不等
- 指令设计的格式， 从某个给定位置， 能将字节唯一解码成机器指令

    *哈夫曼编码*

- 反汇编无需访问源代码
- 反汇编与gcc的命名规则有些许差别

    *比如movq的q在反汇编中会被省略*

## 关于格式的注解

```assembly
	.file	"mstore.c"
	.text
	.globl	mulstore
	.type	mulstore, @function
mulstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	mulstore, .-mulstore
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)"
	.section	.note.GNU-stack,"",@progbits

```

以上是gcc完整生成的.s文件

所有. 开头的是伪指令， 可以忽略

### ATT汇编代码格式

```asm
	.file	"mstore.c"
	.text
	.globl	mulstore
	.type	mulstore, @function
mulstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	mulstore, .-mulstore
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)"
	.section	.note.GNU-stack,"",@progbits
```

# 数据格式

- 16位： 字(w)
- 32位： 双字(l)
- 64位： 四字(q)

![enter image description here](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3376004043, 3845334967&fm=15&gp=0.jpg)

- moveb： 传送字节
- movew： 传送字
- movel： 传送双字
- moveq： 传送四字

# 访问信息
x86-64的CPU包含一组16个存储64位的通用目的寄存器

![enter image description here](https://images2017.cnblogs.com/blog/123045/201708/123045-20170803104941928-1961116877.png)

- 16位操作可以访问2位字节
- 32位操作可以访问4位字节

...

**栈指针（%rsp）**

## 操作数指示符

- 立即数： 代表常数

    $后面接c语言表示法的整数

- 寄存器： 表示寄存器里的内容

    r<sub> a </sub>用来表示寄存器a
    用R[r<sub> a </sub>]表示里面的内容

- 内存引用： 指定内存地址里的内容
    M[地址]

![enter image description here](https://images2017.cnblogs.com/blog/1120165/201709/1120165-20170925204134214-1101378630.png)






