{"name":"图","id":"算法与数据结构-图","content":"# 图\n\n一个图（一般记作G）由两类元素构成，分别称为**顶点**（或节点、结点）和**边**。每条边有两个顶点作为其端点，我们称这条边“连接”了它的两个端点\n\n顶点相连接的边的条数叫做度，度分为入度（In-degree）和出度（Out-degree），入度表示有多少条边指向这个顶点，出度表示有多少条边是以这个顶点为起点指向其他顶点\n\n**分类**\n\n- 有向图与无向图\n- 有权图与无权图\n\n## 表示方法\n\n### 邻接矩阵\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    0 --> 1\n    3 --> 1\n    1 --> 2\n    2 --> 3\n```\n\n```js\n[[0,1,0,0],\n[0,0,1,0],\n[0,0,0,1],\n[0,1,0,0]]\n```\n\n```java\nboolean[][] g;\n// n代表顶点的数量，v代表边的数量\nint n, m;\n// 判断两个顶点是否存在边\nboolean hasEdge(int v, int w) {\n    return g[v][w];\n}\n// 给两个顶点增加一条边\nvoid addEdge(int v, int w) {\n    if (hasEdge(v, w)) {\n        return;\n    }\n    g[v][w] = true;\n    if (!directed) {\n        g[w][v] = true;\n    }\n    m++;\n}\n// \n```\n\n邻接矩阵对于稀疏图而言，比较浪费存储空间，但邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时非常高效。用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算\n\n### 邻接表\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    0 --> 1\n    1 --> 2\n    2 --> 3\n    3 --> 1\n```\n\n```js\n[\n    [1], // 0 连接 1\n    [2], // 1 连接 2\n    [3], // 2 连接 3\n    [1] // 3 连接 1\n]\n```\n\n```java\nList<List<Integer>> g;\nvoid addEdge(int v, int w) {\n    g.get(v).add(w);\n    if (!directed && v != w) {\n        g.get(w).add(v);\n    }\n    m++;\n}\nboolean hasEdge(int v, int w) {\n    for (int i = 0; i < g.get(v).size(); i++) {\n        if (g.get(v).get(i).equals(w)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n邻接表适合表示稀疏的图，如果邻接表使用的是链表或者其他非连续结构，由于存储空间不连续，对缓存不友好，在邻接表中查询两个顶点之间的关系就没那么高效了\n\n### 边表\n\n每一条边通常由两个顶点组成。边表只包含边的信息，而不包含关于顶点的额外信息\n\n节点 | 连接该节点的节点\n-|-\nA | B\nA | C\nC | D\nD | B\n\n## 搜索\n\n两个算法的不同之处只在于获取下一个节点的方式不一样\n\n- 广度优先下一个节点是最早加入的节点\n- 深度优先下一个节点是最晚加入的节点\n\n在搜索空间很大，但已知搜索路径不会特别长的情况下，DFS 可能会比 BFS 要慢很多，但如果要通过搜索算法求最短路径，只能选择BFS\n\n两者的时间复杂度都是O(顶点数)，深度优先虽然没有广度优先使用一个显式的queue来存储节点，但是其最深的函数调用栈就是描述一条经过了所有节点的路径\n\n广度优先搜索和深度优先搜索是最基本的搜索算法，没有什么优化，是暴力搜索算法\n\n### 深度优先\n\n从一个点开始 如果这个点没有被访问过 则选择该点的某个连接点进行深度优先搜索 直到所有能访问的顶点都被访问过\n\n```java\nfor (int i = 0; i < graph.V(); i++) {\n    // 对每个节点进行深度优先遍历\n    if (!visited[i]) {\n        dfs(i);\n    }\n}\nvoid dfs(int v) {\n    visited[v] = true;\n    id[v] = count;\n    // 对传进来的节点所连接的节点再进行DFS\n    GraphIterator iterator = graph.iterator(v);\n    for (int i = iterator.begin(); !iterator.end(); i = iterator.next()) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n}\n```\n\n从起点出发递归遍历图，通过结果集判重，保证重复的节点不会被递归两次，从而每条边只会被遍历一次，整体时间复杂度为 O(边数)\n\n### 广度优先\n\n```java\nvoid bfs(int v) {\n    if (visited[v]) return;\n    visited[v] = true;\n    while(!queue.isEmpty()) {\n        v = queue.poll();\n        for(var w : neighbor(v)) queue.offer(w);\n    }\n}\n```\n\n从一个点开始 逐个遍历与该点连接的所有顶点 在遍历某节点时 将该节点的所有连接点入队，队列 FIFO 的特性保证了，下一层的元素一定会比上层的元素更晚出现 每次进行广度搜索的节点就从队列里面拿\n\n所有顶点入队一次、出队一次，每条边都会在边起点出队的时候被遍历一次，所以整体的时间复杂度为 O(顶点数+边数)\n\n## 连通分量\n\n>无向图G的极大连通子图称为G的连通分量\n\n## 有向图\n\n### 表示\n\n同样也是使用邻接表表示\n\n### 可达性\n\nDFS 与　BFS　同样适用于有向图\n\n### 环\n\n> 拓扑排序：将所有顶点排序，使得所有的有向边均从排在前面的元素指向后面的元素，在有循环依赖的图中，是没法进行拓扑排序的\n\n#### Khan 算法\n\n- 基于BFS\n\n先把没有其他节点连接的节点加入可达节点，然后从剩下的节点中选出可以从可达节点到达的节点，按这样的顺序反复进行\n\n#### 基于DFS\n\n优先找出没有后继节点的节点，把它作为最终节点\n\n### 强连通性\n\n如果两个顶点互相可达，则称它们是强连通的\n\n## 有权图\n\n### 表示\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    0 --> 1: 0.12\n    3 --> 1: 0.52\n    3 --> 2: 0.28\n    2 --> 1: 0.34\n```\n\n- 邻接矩阵\n\n```js\n[\n    [0, 0.12, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0.34, 0, 0],\n    [0, 0.52, 0.28, 0]\n]\n```\n\n- 邻接表\n\n```js\n[\n    [{to: 1, w: 0.12}],\n    [],\n    [{to: 1, w: 0.34}],\n    [{to: 1, w: 0.52}, {to: 2, w: 0.28}]\n]\n```\n\n一副连通加权无向图中一棵权值最小的生成树\n\n## 最小生成树\n\n- 贪心算法\n\n>找到最小生成树的一条边，不断重复，直到找到所有最小生成树的所有边\n\n### Prim算法\n\n每次将一个与树节点连接但不在树中且权值最小的边加入树，直至边数达到节点数-1\n\n![202002131423](/assets/202002131423.png)\n\n### kruskal算法\n\n每次将权值最小的且不会构成环的边加入生成树，直至边数达到节点数-1\n\n![202002131458](/assets/202002131458.png)\n\n![202002131459](/assets/202002131459.png)\n\n- 如何判断环\n\n当边加入之后，使用union find判断从某一节点是否连接它自己，如果是，则就是有环\n\n## 最短路径\n\n找到从一个顶点到另一个顶点成本最小的路径\n\n### Floyd算法\n\n核心思想是，在两个顶点之间插入一个或一个以上的中转点，比较经过与不经过中转点的距离哪个更短\n\n```c\nfor(k=0;k<n;k++)//中转站0~k\n    for(i=0;i<n;i++) //i为起点\n        for(j=0;j<n;j++) //j为终点\n            if(d[i][j]>d[i][k]+d[k][j])//松弛操作 \n                d[i][j]=d[i][k]+d[k][j]; \n```\n\n### Dijkstra算法\n\n用来求解单源最短路径\n\n- 前提：图中不能存在负权边\n\n引入了一种叫做最短路径树的构造方法。基于贪心的思想逐步找出距源点 s 最近、次近的点，就能得到一个 G 的子图，里面包含了 s 及所有从 s 出发能到达的节点，它们以 s 为根一起构成了一颗树，就是最短路径树\n\n![202002140953](/assets/202002140953.jpg)\n\n```java\nMap<String, Map<String, Integer>> g = new HashMap<>();\ng.put(\"A\", Map.of(\"B\", 12, \"G\", 14, \"F\", 16));\ng.put(\"B\", Map.of(\"A\", 12, \"F\", 7, \"C\", 10));\ng.put(\"G\", Map.of(\"A\", 14, \"F\", 9, \"E\", 8));\ng.put(\"F\", Map.of(\"A\", 16, \"B\", 7, \"G\", 9, \"E\", 2, \"C\", 6));\ng.put(\"E\", Map.of(\"G\", 8, \"F\", 2, \"C\", 5, \"D\", 4));\ng.put(\"C\", Map.of(\"B\", 10, \"F\", 6, \"E\", 5, \"D\", 3));\ng.put(\"D\", Map.of(\"E\", 4, \"C\", 3));\n\nString start = \"D\";\nMap<String, Integer> S = new HashMap<>();\nSet<String> visited = new HashSet<>();\nPriorityQueue<String> U = new PriorityQueue<>(Comparator.comparingInt(S::get));\n\n// Initialize distances\nfor (String node : g.keySet()) {\n    S.put(node, Integer.MAX_VALUE);\n}\nS.put(start, 0);\n\nU.add(start);\n\nwhile (!U.isEmpty()) {\n    String current = U.poll();\n    if (visited.contains(current)) continue;\n    visited.add(current);\n\n    // Update distances for each neighbor\n    for (Map.Entry<String, Integer> neighborEntry : g.get(current).entrySet()) {\n        String neighbor = neighborEntry.getKey();\n        int weight = neighborEntry.getValue();\n        if (visited.contains(neighbor)) continue;\n\n        int newDist = S.get(current) + weight;\n        if (newDist < S.get(neighbor)) {\n            S.put(neighbor, newDist);\n            U.add(neighbor);\n        }\n    }\n}\n\nSystem.out.println(S);\n```\n\n### A*算法\n\n- 快速找出一条接近于最短路线的次优路线\n\n是一种启发式搜索算法，通过选择启发函数来影响搜索的方向，如果启发函数能够准确地估计到目标节点的距离，那么A*算法可以找到最短路径。相比于Dijkstra算法，该算法在选择下一个扩展的节点时，通过启发式函数引入额外的背景信息来作为的依据，这样可以让整个算法更快地往终点走，从而避免掉 Dijkstra 算法一些盲目无效的搜索\n","metadata":"tags: ['数据结构']","hasMoreCommit":true,"totalCommits":12,"commitList":[{"date":"2024-12-04T15:39:37+08:00","author":"MY","message":"📦图","hash":"6ec9778ee9562da8b666d76e0869b7f0d56c6a23"},{"date":"2024-11-08T11:37:41+08:00","author":"MY","message":"✏图","hash":"89e85332f0f2971e951d8e034ed8c0c35675f81a"},{"date":"2024-03-28T09:58:20+08:00","author":"MY","message":"✏图算法","hash":"d8216282ebbb8e43b80515c384d20c22a0936e86"},{"date":"2024-02-27T20:07:27+08:00","author":"MY","message":"✏算法","hash":"8a6529c0b37f98855cb1857f560564cc6401fd7b"},{"date":"2024-02-23T14:48:06+08:00","author":"MY","message":"✏图","hash":"dc4a47043c9deb774fe8456ca12a8a512557d9e7"},{"date":"2022-07-10T16:05:00+08:00","author":"MY","message":"✏️更新 计算机网络算法","hash":"61bd4c9bf67fd790d9670c1a59424404f6ee214c"},{"date":"2022-07-09T15:26:49+08:00","author":"MY","message":"✏️更新 算法","hash":"2d8ca900074aa66c48b668e03cc082547eae7449"},{"date":"2020-08-05T09:29:56+08:00","author":"MY","message":"✏更新 图","hash":"755bc1ea20534a45902710d6ab43cb813c2dc778"},{"date":"2020-02-14T10:43:53+08:00","author":"MY","message":"更新Dijkstra算法","hash":"10e2ffa8e704863a2a5623b28ecdc0fa67b06575"},{"date":"2020-02-13T15:15:05+08:00","author":"MY","message":"更新最小生成树相关内容","hash":"fd842f40192058b4724c55eae882a765229d26b7"}],"createTime":"2019-12-04T19:59:31+08:00"}