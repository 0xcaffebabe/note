{"name":"字符串","id":"算法与数据结构-字符串","content":"# 字符串\n\n## 排序\n\n- 低位优先排序\n\n```java\npublic static void sort(String[]a,int W) {\n        int N = a.length;\n        int R = 256;\n        String[] aux = new String[N];\n        //循环W次键索引记数法\n        for(int d = W-1; d>=0;d--) {\n            int[] count = new int[R+1];\n            //键索引记数法第一步--频率统计\n            for(int i=0;i<N;i++)\n                count[a[i].charAt(d)+1]++;\n            //键索引记数法第二步--将频率转化为索引\n            for(int r=0;r<R;r++)\n                count[r+1]+=count[r];\n            //键索引记数法第三步--排序\n            for(int i=0;i<N;i++)\n                aux[count[a[i].charAt(d)]++] = a[i];\n            //键索引记数法第四步--回写\n            for(int i=0;i<N;i++)\n                a[i]=aux[i];\n        }\n}\n```\n\n- 高位优先排序\n\n```java\npublic class MSD {\n    private static int R = 256;    //字符串中最多可能出现的字符的数量\n    private static final int M = 15;    //当子字符串长度小于M时，用直接插入排序\n    private static String[] aux;    //辅助数组\n    //实现自己的chatAt()方法\n    private static int charAt(String s, int d) {\n        if(d<s.length())return s.charAt(d);\n        else return -1;\n    }\n\t\n    public static void sort(String[] a) {\n        int N = a.length;\n        aux = new String[N];\n        sort(a,0,N-1,0);\n    }\n    private static void sort(String[] a,int lo, int hi, int d) {\n        if(hi<=lo+M) {Insertion.sort(a,lo,hi,d);return;}    //切换为直接插入排序\n        int[] count = new int[R+2];\n        //键索引记数法第一步\n        for(int i=lo; i<=hi;i++)\n            count[charAt(a[i],d)+2]++;\n        //键索引记数法第二步\t\t\n        for(int r=0;r<R+1;r++)\n            count[r+1]+=count[r];\n        //键索引记数法第三步\t\t\n        for(int i=lo;i<=hi;i++)\n            aux[count[a[i].charAt(d)+1]++] = a[i];\n        //键索引记数法第四步\t\t\n        for(int i=lo;i<=hi;i++)\n            a[i]=aux[i-lo];\n\t\t//递归以每个字符为键进行排序\n        for(int r=0;r<R;r++)\n            sort(a,lo+count[r],lo+count[r+1]-1,d+1);\n    }\n}\n```\n\n- 三向字符串快速排序\n\n```java\npublic class Quick3string {\n    private static int charAt(String s, int d) {\n        if(d<s.length())return s.charAt(d);\n        else return -1;\n    }\n    public static void sort(String[] a) { sort(a,0,a.length-1,0); }\n\t\n    public static void sort(String[] a,int lo, int hi, int d) {\n        if(hi<=lo)\treturn;\n        int lt = lo, gt = hi;\n        int v = charAt(a[lo], d);\n        int i = lo+1;\n        while(i<=gt) {\n            int t = charAt(a[lo],d);\n            if(t<v)\texch(a,lt++,i++);\n            else if(t>v)\texch(a,i,gt--);\n            else i++;\n        }\n        sort(a,lo,lt-1,d);\n        if(v>=0) sort(a,lt,gt,d+1);\n        sort(a,gt+1,hi,d);\n    }\n}\n```\n\n## 单词查找树\n\ntrie 树存储的开销要小得多，并且因为它天然的前缀匹配和排序的特性，在很多时候也能更快检索数据\n\ntrie 树的本质就是利用字符串之间的公共前缀，将重复的前缀合并在一起\n\n单次查找树是一种多模式串的字符匹配算法\n\n```mermaid\nstateDiagram-v2\n    g --> o\n    o --> l\n    l --> d\n    l --> a\n    a --> n\n    n --> s\n```\n\n- 查找\n\n\n- 插入\n\n\n- 查询所有键　\n  - 通过递归的方式，如果有分叉，则生成一个由pre+branch的新字符串\n\n```java\npublic Interable<String> keys() {\n  return keysWithPrefix(\"\");\n}\npublic Interable<String> keysWithPrefix(String pre) {\n  Queue<String> q = new Queue<String>();\n  collect(get(root, pre, 0), pre, q);\n  return q;\n}\nprivate void collect(Node x, String pre, Queue<String> q) {\n  if (x == null) return;\n  if (x.val != null) q.enqueue(pre);\n  for (char c = 0; c < R; c++)\n    collect(x.next[c], pre + c, q);\n}\n```\n\n- 删除\n\n找到键所对应的结点并将它的值设为空（null）。如果该结点含有一个非空的链接指向某个子结点，那么就不需要在进行其他操作了。如果它的所有链接均为空，那就需要在数据结构中删去这个结点。如果删去它使得它的父结点的所有链接也均为空，就需要继续删除它的父结点，以此类推\n\n```java\npublic void delete(String key) {\n  root = delete (root, key, 0);\n}\nprivate Node delete(Node x, String key, int d) {\n  if (x == null) return null;\n  if (d == key.length())\n    x.val = null;\n  else {\n    char c = key.charAt(d);\n    x.next[c] = delete(x.next[c], key, d+1);\n  }\n  if (x.val != null) return x;\n  for (char c = 0; c < R; c++)\n    if (x.next[c] != null) return x;\n  return null;\n}\n```\n\n- 优化\n\n为了解决内存消耗的问题，有一种称之为缩点优化的手段，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并\n\n```mermaid\nstateDiagram-v2\n    g --> o\n    o --> l\n    l --> d\n    l --> ans\n```\n\n### 三向单词查找树\n\n在三向单词查找树（TST）中，每个结点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于结点字母的所有键\n\n![](/assets/20233916246.png)\n\n## 子字符串查找\n\n### 暴力查找\n\n```java\npublic static int search(String pat, String txt) { \n        int M = pat.length(); \n        int N = txt.length(); \n \n        // 逐个位置匹配模式字符串 \n        for (int i = 0; i < N; i++) { \n            int j; \n            for (j = 0; j < M; j++) { \n                if (txt.charAt(i + j) != pat.charAt(j)) { \n                    break; \n                } \n            } \n \n            // 找到了匹配的字符串 \n            if (j == M) { \n                return i; \n            } \n        } \n        return N; \n}\n```\n\n这种算法的最坏情况时间复杂度是 O(n*m)\n\n### 暴力查找(显式回退)\n\n```java\n  public static int searchother(String pat, String txt) { \n        int M = pat.length(); \n        int N = txt.length(); \n        int i; \n        int j; \n \n        // 逐个位置匹配模式字符串 \n        for (i = 0, j = 0; i < N && j < M; i++) { \n            if (txt.charAt(i) == pat.charAt(j)) { \n                j++; \n            } else { \n                i -= j; \n                j = 0; \n            } \n        } \n \n        // 找到了匹配的字符串 \n        if (j == M) { \n            return i - M; \n       } else { \n            return N; \n       } \n\n  }\n```\n\n### RK算法\n\n通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了\n\n为了提高效率，需要特别设计哈希算法，相邻两个子串的哈希值的计算公式有一定关系，只需要扫描一遍主串就能计算出所有子串的哈希值了\n\n```js\nb a d d e f\nb a d d => [h1, h2, h3, h4] =>  H1\n  a d d e => [h2, h3, h4 , h5] => H2\n    d d e f => [h3, h4, h5, h6] => H3\n```\n\n由于哈希冲突的存在，当哈希相同时，还要去比较子串是否匹配模式串。如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)\n\n### KMP算法\n\nKMP 算法的整体思想跟 BM 算法一样，通过构建一个 next 数组，当发现模式串不匹配时，尽量地多往后移动，降低匹配次数\n\n### BM算法\n\nBM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率\n\nBM 算法在最好情况下的时间复杂度非常低，是 O(n/m)\n\n坏字符规则（Bad Character Rule）： 当发现不匹配的字符时，算法会将模式串向右移动，使得模式串中的字符与目标串中的字符对齐，以最大化跳过的比较次数。为了实现这一点，BM 算法会预先计算每个字符在模式串中的最右出现位置，并根据目标串中的字符在模式串中的位置进行调整。\n\n好后缀规则（Good Suffix Rule）： 当匹配失败时，算法会尽量将模式串向右滑动，以使得模式串的某个后缀能够与目标串中的已匹配部分相匹配。这需要事先计算模式串中每个后缀与目标串中的已匹配部分相匹配的最大长度\n\n### RK指纹字符查找算法\n\n### AC自动机\n\nAC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组\n\n## 正则表达式\n\n- 连接\n\nAB -> {AB}\n\n- 或\n\nＡ|B -> {A,B}\n\n- 闭包\n\nＢ* -> 0个或多个Ｂ\n\n### 构造正则表达式\n\n![](/assets/20233916432.png)\n\n## 数据压缩\n\n### 游程编码\n\n行程编码（Run Length Encoding，RLE), 又称游程编码、行程长度编码、变动长度编码 等，是一种统计编码。主要技术是检测重复的比特或字符序列，并用它们的出现次数取而代之\n\n### 哈夫曼编码\n\n用较少的比特表示出现次数多的字符，用较多的比特表示出现频率低的字符，不同的字符编码间不能彼此成为对方的前缀\n\n- 使用单词查找树实现\n\n使用变长前缀，用一棵二叉树来标记每个字符的编码方式，左分支代表 0、右分支代表 1，所有需要编码的字符都对应二叉树的叶子节点，根结点到该叶子结点的路径就代表着该字符的编码方式\n\n![哈夫曼编码算法1](/assets/20227915238.webp)\n![哈夫曼编码算法2](/assets/202279152323.webp)\n\n### LZW压缩\n\nLZW编码 (Encoding) 的核心思想其实比较简单，就是把出现过的字符串映射到记号上，这样就可能用较短的编码来表示长的字符串，实现压缩\n\nLZW的一个核心思想，即压缩后的编码是自解释 (self-explaining) 的。什么意思？即字典是不会被写进压缩文件的，在解压缩的时候，一开始字典里除了默认的0->A和1->B之外并没有其它映射，2->AB是在解压缩的过程中一边加入的。这就要求压缩后的数据自己能告诉解码器，完整的字典，例如2->AB是如何生成的，在解码的过程中还原出编码时用的字典\n\n","metadata":"","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2024-02-26T19:42:15+08:00","author":"MY","message":"✏算法","hash":"d5fb62fdbd3a50125f819ecf0d2ca8e1b6868d28"},{"date":"2024-02-23T17:34:36+08:00","author":"MY","message":"✏字符串","hash":"6cadacd85f899a958294f14d642dfce098d4361f"},{"date":"2023-03-09T09:41:00Z","author":"My","message":"🛠替换在线图片","hash":"0c8b08bc22fbe482ba02da2f1fcad211441d3c23"},{"date":"2022-07-13T14:17:35+08:00","author":"cjiping","message":"✏️更新 trie","hash":"5dc09852098380a664db931c7c36ab6b3de5442e"},{"date":"2022-07-09T15:26:49+08:00","author":"MY","message":"✏️更新 算法","hash":"2d8ca900074aa66c48b668e03cc082547eae7449"},{"date":"2019-12-06T21:20:51+08:00","author":"0xcaffebabe","message":"新增正则表达式与压缩算法","hash":"e09b5aeeda9e2ffdf002249606b4843a36d54b63"},{"date":"2019-12-05T21:21:45+08:00","author":"0xcaffebabe","message":"新增了几个关于字符串的算法与数据结构","hash":"bb085afff221c8a2c964b2a7d66993055fd57d5d"}],"createTime":"2019-12-05T21:21:45+08:00"}