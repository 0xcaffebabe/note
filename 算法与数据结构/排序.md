# 排序

## 选择排序

找到数组中最小的元素，第一次将它与第一个元素交换位置，第二次交换将它与第二个位置交换，以此类推

```java
public static void selectSort(int[] arr) {

        int N = arr.length;

        for (int i = 0; i < N; i++) {
            int min = i;
            for (int i1 = i + 1; i1 < N; i1++) {
                // 找到最小的元素
                if (arr[i1] < arr[min]) {
                    min = i1;
                }
            }
            // 交换最小元素与当前第ｉ个元素
            int t = arr[i];
            arr[i] = arr[min];
            arr[min] = t;
        }
    }
```

## 插入排序

第一次从后到前逐个扫描下标０-１的元素，如果发现后面一个比前面小，则两个交换位置 

第二次从后到前逐个扫描下标０-２的元素，如果发现后面一个比前面小，则两个交换位置 

依此类推

```java
    public static void insertSort(int[] a){
        int N =a.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0; j--) {
                if (a[j] < a[j-1]){
                    int t = a[j];
                    a[j] = a[j-1];
                    a[j-1] = t;
                    break;
                }
            }
        }
    }
```

## 希尔排序

希尔排序是将插入排序中的交换相邻元素改为交换不相邻元素

```java
    public static void shellSort(int[] a){
        int N =a.length;
        int h =1;
        while (h<N/3) {h=3*h+1;}
        while (h>=1){
            for (int i = 0; i < N; i++) {
                for(int j =i;j>=h;j-=h){
                    if (a[j]<a[j-h]){
                        int t = a[j];
                        a[j] = a[j-h];
                        a[j-h] = t;
                        break;
                    }
                }
            }
            h=h/3;
        }
    }
```

## 归并排序

对两个有序子序列进行合并，得到一个更大的有序子序列，以此类推，直到只剩下一个序列

```java
public static void mergeSort(int[] arrays, int L, int R) {

        //如果只有一个元素，那就不用排序了
        if (L == R) {
            return;
        } else {

            //取中间的数，进行拆分
            int M = (L + R) / 2;

            //左边的数不断进行拆分
            mergeSort(arrays, L, M);

            //右边的数不断进行拆分
            mergeSort(arrays, M + 1, R);

            //合并
            merge(arrays, L, M + 1, R);

        }
    }


    public static void merge(int[] arrays, int L, int M, int R) {

        //左边的数组的大小
        int[] leftArray = new int[M - L];

        //右边的数组大小
        int[] rightArray = new int[R - M + 1];

        //往这两个数组填充数据
        for (int i = L; i < M; i++) {
            leftArray[i - L] = arrays[i];
        }
        for (int i = M; i <= R; i++) {
            rightArray[i - M] = arrays[i];
        }


        int i = 0, j = 0;
        // arrays数组的第一个元素v
        int k = L;


        //比较这两个数组的值，哪个小，就往数组上放
        while (i < leftArray.length && j < rightArray.length) {

            //谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个
            if (leftArray[i] < rightArray[j]) {
                arrays[k] = leftArray[i];

                i++;
                k++;
            } else {
                arrays[k] = rightArray[j];
                j++;
                k++;
            }
        }

        //如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)
        while (i < leftArray.length) {
            arrays[k] = leftArray[i];

            i++;
            k++;
        }
        //如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)
        while (j < rightArray.length) {
            arrays[k] = rightArray[j];

            k++;
            j++;
        }
    }
```

## 快速排序

选定一个元素，将比该元素小的元素放其左边，比它大的放在其右边，并递归地对它左右两边的子序列进行排序

```java
public static void quickSort(int a[], int low, int hi) {
        if (hi<=low) {
            return;
        }
        int j =partition(a,low,hi);
        quickSort(a, low, j - 1);　//　左子序列排序
        quickSort(a, j + 1, hi);　// 右子序列排序
    }

    private static int partition(int[] a, int low, int hi) {

        int i=low, j=hi+1; // 左右扫描指针
        int v = a[low];　// 基准数
        while (true){
            while (a[++i]<v){　// 从左往右扫描，直到扫描元素大于等于基准数
                if (i==hi) {
                    break;
                }
            }
            while (v<a[--j]){　// 从右往左扫描，直到扫描元素小于等于基准数
                if (j==low){
                    break;
                }
            }
            if (i>=j){　//　扫描结束的标志：左指针在右指针的右边或在一起
                break;
            }
            // 交换左右指针的元素，也就是把把右边比基准数小的跟左边比基准数大的交换位置
            int t=a[i];
            a[i]=a[j];
            a[j]=t;
        }
        // 把基准数放入正确的位置
        int t= a[low];
        a[low]=a[j];
        a[j]=t;
        return j;
    }
```

