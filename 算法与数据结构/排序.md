# 排序

**为什么要学习O(N^2)的排序算法**

- 是其他算法的基础
- 编码简单
- 作为子过程，用于改进复杂的排序算法

## 选择排序

![202002070942](/assets/202002070942.gif)

找到数组中最小的元素，第一次找到的最小元素将它与第一个元素交换位置，第二次找到的最小元素交换将它与第二个位置交换，以此类推

```java
for (int i = 0; i < arr.length; i++) {
    // 寻找[i,n)里的最小值
    int min = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (less(arr[j],arr[min])) {
            min = j;
        }
    }
    swap(arr, i, min);
}
```

## 插入排序

![202002070926](/assets/202002070926.gif)

第一次从后到前逐个扫描下标０-１的元素，如果发现后面一个比前面小，则两个交换位置，否则就开始下一次扫描

第二次从后到前逐个扫描下标０-２的元素，如果发现后面一个比前面小，则两个交换位置 ，否则就开始下一次扫描

依此类推

- 插入排序对近乎有序的数组性能很强

```java
for (int i = 1; i < a.length; i++) {
    // 从右到左扫描，如果右值小于左值，则交换，否则跳出本轮循环
    for (int j = i; j > 0; j--) {
        if (less(a[j], a[j - 1])) {
            swap(a, j, j - 1);
        }else {
            break;
        }
    }
}

// 改进后的插入排序
for (int i = 1; i < a.length; i++) {
    var e = a[i];
    int j;
    for (j = i; j > 0 && greater(a[j - 1], e); j--) {
        // 将
        a[j]=a[j-1];
    }
    a[j]=e;
}
```

## 冒泡排序

![202002081000](/assets/202002081000.gif)

第一次扫描下标为0的元素到最后一个元素，如果发现后面一个比前面小，则两个交换位置

第一次扫描下标为0的元素到倒数第二个元素，如果发现后面一个比前面小，则两个交换位置

以此类推

```java
for (int i = 1; i < a.length; i++) {
    for (int j = 0; j < a.length - i; j++) {
        if (less(a[i],a[j])){
            swap(a,i,j);
        }
    }
}
// 改进的冒泡排序
for (int i = 1; i < a.length; i++) {
    int lastSwap = 1;
    for (int j = 0; j < a.length - i && j < lastSwap; j++) {
        if (less(a[i], a[j])) {
            swap(a, i, j);
            // 记录最后一次交换的位置，该位置后的元素在下一轮扫描后不会被扫描
            lastSwap = j;
        }
    }
}
```

## 希尔排序

![202002081040](/assets/202002081040.gif)

希尔排序是将插入排序中的交换相邻元素改为交换不相邻元素

- 选择一个增量序列t1，t2，…，tk
- 按增量序列个数k，对序列进行k 趟排序

```java
int h = 1;
// 计算增长序列，1,4，13,40...
while (h < a.length / 3) {
    h = 3 * h + 1;
}
while (h>=1){
    for (int i = h; i < a.length; i++) {
        // 对第i,i-h,i-2*h,i-3*h进行插入排序
        var e = a[i];
        int j;
        for (j = i; j > h && less(a[j - h], e); j-=h) {
            a[j]=a[j-h];
        }
        a[j]=e;
    }
    h/=3;
}
```

## 归并排序

![202002081126](/assets/202002081126.gif)

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列

对两个有序子序列进行合并，得到一个更大的有序子序列，以此类推，直到只剩下一个序列

- 但是一个缺点是需要额外的O(N)空间

```java
private void mergeSort(Comparable<?>[] a, int l, int r) {
    if (l >= r) {
        return;
    }
    int mid = (l + r) / 2;
    mergeSort(a, l, mid); // 对左边排序
    mergeSort(a, mid + 1, r); // 对右边排序
    merge(a, l, mid, r); // 对两个数组进行归并
}
private void merge(Comparable<?>[] a, int l, int mid, int r) {
    // 开辟一块新空间给l-r之间的元素
    Comparable<?>[] aux = new Comparable<?>[r - l + 1];
    for (int i = l; i <= r; i++) {
        aux[i - l] = a[i];
    }

    int i = l, j = mid + 1;
    // 对l到r之间的元素进行扫描，将它们放到指定位置
    for (int k = l; k <= r; k++) {
        if (i > mid) { // 如果左指针已经跑过了mid，那此时让右指针去跑
            a[k] = aux[j - l];
            j++;
        } else if (j > r) { // 如果右指针已经跑完了，则此时让左指针去跑
            a[k] = aux[i - l];
            i++;
        } else if (less(a[i - l], a[j - l])) { // 否则就比较左右两指针谁的值比较小，谁小就把谁的值复制到结果里，然后该指针往后移动
            a[k] = aux[i - l];
            i++;
        } else {
            a[k] = aux[j - l];
            j++;
        }
    }
}
```

### 优化

当mid+1位置的元素大于mid位置的元素时，就没有必要进行归并了

```java
if (greater(a[mid],a[mid+1])){
    merge(a, l, mid, r);
}
```

也可以当被归并排序的数组数量小于某一数量级时，使用其他排序算法，来提高性能

### 自底向上的归并排序

```java
// 每次归并的数组大小依次为1 2 4 ...
for (int sz = 1; sz <= a.length; sz += sz) {
    for (int i = 0; i < a.length; i += sz + sz) {
        // 归并a[i...i+size-1] 与 a[i+size...i+2*size-1]
        if (i + sz < a.length) { // 只有左数组长度小于整个排序数组长度使（代表目前没有右数组），才进行归并（否则数组就是有序的了）
            merge(a, i, i + sz - 1, min(i + sz + sz - 1, a.length - 1));
        }
    }
}
```

## 快速排序

选定一个元素，将比该元素小的元素放其左边，比它大的放在其右边，并递归地对它左右两边的子序列进行排序

```java
public static void quickSort(int a[], int low, int hi) {
        if (hi<=low) {
            return;
        }
        int j =partition(a,low,hi);
        quickSort(a, low, j - 1);　//　左子序列排序
        quickSort(a, j + 1, hi);　// 右子序列排序
    }

    private static int partition(int[] a, int low, int hi) {

        int i=low, j=hi+1; // 左右扫描指针
        int v = a[low];　// 基准数
        while (true){
            while (a[++i]<v){　// 从左往右扫描，直到扫描元素大于等于基准数
                if (i==hi) {
                    break;
                }
            }
            while (v<a[--j]){　// 从右往左扫描，直到扫描元素小于等于基准数
                if (j==low){
                    break;
                }
            }
            if (i>=j){　//　扫描结束的标志：左指针在右指针的右边或在一起
                break;
            }
            // 交换左右指针的元素，也就是把把右边比基准数小的跟左边比基准数大的交换位置
            int t=a[i];
            a[i]=a[j];
            a[j]=t;
        }
        // 把基准数放入正确的位置
        int t= a[low];
        a[low]=a[j];
        a[j]=t;
        return j;
    }
```

