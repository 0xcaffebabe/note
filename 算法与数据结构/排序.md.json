{"name":"排序","id":"算法与数据结构-排序","content":"# 排序算法\n\n## 一、排序的第一性原理\n\n### 1. 排序的本质\n\n**排序 = 将一个无序集合，转换为满足某种全序关系的序列。**\n\n从信息视角看，排序解决的是：\n\n* 元素之间**相对顺序不确定**的问题\n* 系统如何通过操作逐步**消除不确定性**\n\n---\n\n### 2. 有序度与逆序度模型\n\n$$\n\\text{有序度} = \\sum_{i<j}\\delta(A[i] < A[j])\n$$\n\n* **满有序度**：完全有序时的有序度\n* **逆序度** = 满有序度 − 当前有序度\n\n> **排序过程的本质：不断减少逆序对的过程。**\n\n不同排序算法的区别，不在于“是否排序”，而在于：\n\n* 如何发现逆序\n* 如何消除逆序\n* 一次消除多少逆序\n\n---\n\n### 3. 排序算法的两种信息来源\n\n| 类型    | 核心思想       | 代价与约束       |\n| ----- | ---------- | ----------- |\n| 比较排序  | 通过比较逐步获取信息 | 下界 O(nlogn) |\n| 非比较排序 | 利用数值分布直接映射 | 对数据分布有前提    |\n\n---\n\n## 二、排序算法的认知结构树\n\n```\n排序算法\n├── 比较排序\n│   ├── 插入型（插入、希尔）\n│   ├── 交换型（冒泡、快速）\n│   ├── 选择型（选择、堆）\n│   └── 分治型（归并、快速）\n└── 非比较排序\n    ├── 计数（计数排序）\n    ├── 映射（桶排序）\n    └── 位分解（基数排序）\n```\n\n> 分类的目的不是记忆，而是理解**算法之间的血缘关系**。\n\n---\n\n## 三、排序算法的评价维度（设计代价）\n\n| 维度    | 本质含义          |\n| ----- | ------------- |\n| 时间复杂度 | 消除逆序所需的操作数量   |\n| 空间复杂度 | 是否用空间换信息      |\n| 稳定性   | 是否破坏等值元素的相对顺序 |\n| 原地性   | 是否允许额外存储结构    |\n\n**稳定性本质**：\n\n> 稳定排序 = 不跨越相等元素\n\n---\n\n## 四、基础比较排序（O(n²) 的意义）\n\n> O(n²) 排序不是“低级算法”，而是：\n>\n> * 小规模最优解\n> * 复杂排序的子过程\n> * 有序度敏感算法\n\n### 1. 选择排序（选择型）\n\n![202002070942](/assets/202002070942.gif)\n\n**核心思想**：\n\n* 每一轮选择“当前最小值”\n* 直接放入最终位置\n\n**哲学代价**：\n\n* 交换次数少\n* 不关心已有顺序 → 不稳定\n\n---\n\n### 2. 插入排序（插入型）\n\n![202002070926](/assets/202002070926.gif)\n\n**核心思想**：\n\n* 假设前缀有序\n* 将新元素插入正确位置\n\n**本质优势**：\n\n* 对逆序度敏感\n* 近乎有序时接近 O(n)\n\n---\n\n### 3. 冒泡排序（交换型）\n\n![202002081000](/assets/202002081000.gif)\n\n**核心思想**：\n\n* 相邻比较\n* 将最大（最小）值逐步“冒”到边界\n\n**本质问题**：\n\n* 只能消除局部逆序\n* 信息利用率低\n\n---\n\n## 五、插入思想的跃迁：希尔排序\n\n![202002081040](/assets/202002081040.gif)\n\n**本质创新**：\n\n> 用“间隔插入”提前消除远距离逆序。\n\n* 插入排序的加速版\n* 通过增量序列逐步逼近完全有序\n\n**代价**：\n\n* 理论复杂度难以精确分析\n* 不稳定\n\n---\n\n## 六、分治范式的两种极端\n\n### 1. 归并排序（稳定 + 空间换时间）\n\n![202002081126](/assets/202002081126.gif)\n\n**本质模型**：\n\n* 分解问题规模\n* 合并局部有序结构\n\n**哲学取舍**：\n\n* 用 O(n) 空间换取稳定的 O(nlogn)\n\n#### 外部归并排序\n\n![202279133543](/assets/202279133543.webp)\n\n> 面向磁盘与 IO 的排序范式。\n\n---\n\n### 2. 快速排序（局部性最优解）\n\n![202002081411](/assets/202002081411.gif)\n\n**本质模型**：\n\n* 通过 partition 建立局部有序\n* 递归放大局部优势\n\n**风险**：\n\n* 极端情况下退化为 O(n²)\n\n#### 双路 / 三路快排\n\n> 本质是：**控制等值元素导致的结构退化**。\n\n---\n\n## 七、突破比较下界：线性排序\n\n### 1. 桶排序（分布假设）\n\n```mermaid\nstateDiagram-v2\n1 2 3 4 5 6 7 8 9\n1 --> [1,3]\n2 --> [1,3]\n3 --> [1,3]\n4 --> [4,6]\n5 --> [4,6]\n6 --> [4,6]\n7 --> [7,9]\n8 --> [7,9]\n9 --> [7,9]\n```\n\n**本质前提**：\n\n* 数据分布近似均匀\n\n---\n\n### 2. 计数排序（值到位置的映射）\n\n**核心思想**：\n\n* 用下标直接表示“位置”\n* 完全消除比较\n\n**约束**：\n\n* 非负整数\n* 范围有限\n\n---\n\n### 3. 基数排序（位分解）\n\n```text\nhke          iba        hac         hac\niba          hac        iba         hke\nhzg  ->      hke  ->    hke    ->   hzg\nikf          ikf        ikf         iba\nhac          hzg        hzg         ikf\n```\n\n**本质模型**：\n\n> 将复杂比较，分解为多轮稳定的简单排序。\n\n---\n\n## 八、特殊排序的认知定位\n\n### 猴子排序 / 睡眠排序\n\n> 不是工程算法，而是：\n\n* 概率\n* 并发\n* 随机性思想的极端展示\n\n---\n\n## 九、洗牌算法（排序的对偶问题）\n\n### Fisher-Yates / Knuth-Durstenfeld\n\n> 排序：消除不确定性\n> 洗牌：制造不确定性\n\n二者在概率模型上是对偶问题。\n\n---\n\n## 十、工程选型决策模型\n\n| 场景   | 推荐算法    | 原因    |\n| ---- | ------- | ----- |\n| 小规模  | 插入排序    | 常数低   |\n| 近乎有序 | 插入 / 希尔 | 逆序少   |\n| 稳定要求 | 归并 / 计数 | 顺序保持  |\n| 内存受限 | 堆排序     | 原地    |\n| 海量数据 | 外部归并    | IO 友好 |\n\n---\n\n## 结语\n\n> **排序算法不是技巧集合，而是工程世界中\"秩序建立\"的思想样本。**\n\n理解排序，本质是在理解：\n\n* 信息如何被逐步确认\n* 系统如何在约束下达成有序\n* 工程设计中的权衡哲学\n\n## 关联内容（自动生成）\n\n- [/算法与数据结构/算法策略.md](/算法与数据结构/算法策略.md) 排序算法体现了多种算法策略，如分治策略（归并排序、快速排序）、贪心策略（选择排序）等\n- [/算法与数据结构/查找.md](/算法与数据结构/查找.md) 排序与查找密切相关，有序数据可以使用二分查找等高效算法\n- [/中间件/数据库/数据库.md](/中间件/数据库/数据库.md) 数据库中的外部排序归并算法是处理大规模数据排序的重要方法\n- [/中间件/数据库/redis/数据结构.md](/中间件/数据库/redis/数据结构.md) Redis中的有序集合等数据结构与排序算法有密切关系\n- [/操作系统/内存管理.md](/操作系统/内存管理.md) 操作系统中的页面置换算法（如LRU、FIFO等）与排序算法在思想上有相似之处\n- [/计算机网络/链路层.md](/计算机网络/链路层.md) 链路层协议中使用的各种算法与排序算法一样，都需要考虑时间复杂度和效率\n- [/算法与数据结构/基本数据结构.md](/算法与数据结构/基本数据结构.md) 排序算法通常作用于基本数据结构（如数组、链表）之上，理解数据结构是理解排序算法的基础\n- [/算法与数据结构/图.md](/算法与数据结构/图.md) 图算法中的拓扑排序是排序思想在图结构上的应用\n- [/中间件/数据库/索引.md](/中间件/数据库/索引.md) 数据库索引的构建和维护与排序算法密切相关，B+树等结构依赖于有序性\n","metadata":"tags: ['算法', '数据结构与算法']","hasMoreCommit":true,"totalCommits":18,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2026-01-08T11:52:55+08:00","author":"MY","message":"doc(java-collections): 重构文档","hash":"e0203004013ac1a831e58f218e6acaca027ed080"},{"date":"2025-12-29T10:35:07+08:00","author":"MY","message":"docs(algorithm): 重构排序算法文档并添加详细分类","hash":"b2855b3a269bb8e9f6442fc0307cc3387c150fe1"},{"date":"2024-02-07T14:41:52+08:00","author":"MY","message":"✏排序","hash":"9ed64c464da102d8345b1194ac5d4bc2cf4b5fe3"},{"date":"2024-02-04T18:54:31+08:00","author":"MY","message":"✏算法","hash":"6ca3803a2d09a54bb8a2b9f56b9c44e0677812b1"},{"date":"2022-08-26T18:08:50+08:00","author":"cjiping","message":"✏️修正归并排序错误","hash":"b7bd862f8d20fa7c5c90e99853c5b13822916283"},{"date":"2022-08-15T13:50:45+08:00","author":"cjiping","message":"✏️算法","hash":"651b1ce80df8b7183bf00af1f209c99db754a5ef"},{"date":"2022-07-13T14:35:09+08:00","author":"cjiping","message":"✏️更新 洗牌算法","hash":"601b190609bec0347491efc2f12b315f87e3515b"},{"date":"2022-07-09T15:26:49+08:00","author":"MY","message":"✏️更新 算法","hash":"2d8ca900074aa66c48b668e03cc082547eae7449"},{"date":"2020-08-05T08:55:06+08:00","author":"MY","message":"✏更新 排序算法","hash":"05b392a49747d4dd22100207460659d12476500e"}],"createTime":"2019-11-29T21:18:06+08:00"}