{"name":"排序","id":"算法与数据结构-排序","content":"# 排序\n\nO(N^2)的排序算法是其他算法的基础，编码简单，可以作为子过程，用于改进复杂的排序算法\n\n对于相等的元素，在排序后，相对位置没有发生改变\n\n排序算法   | 平均时间复杂度  | 最坏时间复杂度  | 最好时间复杂度  | 空间复杂度    | 稳定性\n------ | -------- | -------- | -------- | -------- | ---\n冒泡排序   | O(n²)    | O(n²)    | O(n)     | O(1)     | 稳定\n直接选择排序 | O(n²)    | O(n²)    | O(n)     | O(1)     | 不稳定\n直接插入排序 | O(n²)    | O(n²)    | O(n)     | O(1)     | 稳定\n快速排序   | O(nlogn) | O(n²)    | O(nlogn) | O(nlogn) | 不稳定\n堆排序    | O(nlogn) | O(nlogn) | O(nlogn) | O(1)     | 不稳定\n希尔排序   | O(nlogn) | O(ns)    | O(n)     | O(1)     | 不稳定\n归并排序   | O(nlogn) | O(nlogn) | O(nlogn) | O(n)     | 稳定\n桶排序   | O(n+k)   | O(n+k)   | $O(n^2)$   | O(n+k)   | 稳定\n计数排序   | O(n+k)   | O(n+k)   | O(n+k)   | O(n+k)   | 稳定\n基数排序   | `O(N*M)` | O`(N*M)` | O(N*M)   | O(M)     | 稳定\n\n分析排序算法的执行效率\n\n- 最好情况、最坏情况、平均情况时间复杂度\n- 对于规模较小的数据，时间复杂度的系数、常数 、低阶等也需要考虑\n- 分析比较次数和交换次数\n- 排序算法的稳定性也是需要考虑的一点，对于相同的值，经过稳定的排序算法，它们的相对位置不会发生变化\n\n$$\n\\text{有序度}=\\sum_{i<j}\\delta(A[i]<A[j])\\\\\n\\delta(A[i]<A[j])=\\begin{cases}1,&\\text{if}A[i]<A[j]\\\\0,&\\text{otherwise}\\end{cases}\n$$\n\n完全有序的数组的有序度叫作满有序度，逆序度 = 满有序度 - 有序度。排序的过程就是一种增加有序度，减少逆序度的过程\n\n## 选择排序\n\n![202002070942](/assets/202002070942.gif)\n\n每一轮循环找到数组中最小的元素，第一次找到的最小元素将它与第一个元素交换位置，第二次找到的最小元素交换将它与第二个位置交换，以此类推\n\n```java\nfor (int i = 0; i < arr.length; i++) {\n    // 寻找[i,n)里的最小值\n    int min = i;\n    for (int j = i + 1; j < arr.length; j++) {\n        if (less(arr[j],arr[min])) {\n            min = j;\n        }\n    }\n    swap(arr, i, min);\n}\n```\n\n## 插入排序\n\n![202002070926](/assets/202002070926.gif)\n\n插入排序是从后往前扫描的\n\n第一次从后到前逐个扫描下标1-0的元素，如果发现后面一个比前面小，则两个交换位置，否则就开始下一次扫描\n\n第二次从后到前逐个扫描下标2-0的元素，如果发现后面一个比前面小，则两个交换位置 ，否则就开始下一次扫描\n\n依此类推\n\n- 插入排序对近乎有序的数组性能很强\n\n```java\nfor (int i = 1; i < a.length; i++) {\n    // 从右到左扫描，如果右值小于左值，则交换，否则跳出本轮循环\n    for (int j = i; j > 0; j--) {\n        if (less(a[j], a[j - 1])) {\n            swap(a, j, j - 1);\n        }else {\n            break;\n        }\n    }\n}\n\n// 改进后的插入排序\nfor (int i = 1; i < a.length; i++) {\n    var e = a[i];\n    int j;\n    for (j = i; j > 0 && greater(a[j - 1], e); j--) {\n        // 将\n        a[j]=a[j-1];\n    }\n    a[j]=e;\n}\n```\n\n## 冒泡排序\n\n![202002081000](/assets/202002081000.gif)\n\n第一次扫描下标为0的元素到最后一个元素\n\n第二次扫描下标为0的元素到倒数第二个元素\n\n每次扫描如果发现右边比左边小 则两个交换位置\n\n以此类推\n\n```java\nfor (int i = 1; i < a.length; i++) {\n    for (int j = 0; j < a.length - i; j++) {\n        if (less(a[i],a[j])){\n            swap(a,i,j);\n        }\n    }\n}\n// 改进的冒泡排序\nfor (int i = 1; i < a.length; i++) {\n    int lastSwap = 1;\n    for (int j = 0; j < a.length - i && j < lastSwap; j++) {\n        if (less(a[i], a[j])) {\n            swap(a, i, j);\n            // 记录最后一次交换的位置，该位置后的元素在下一轮扫描后不会被扫描\n            lastSwap = j;\n        }\n    }\n}\n```\n\n## 希尔排序\n\n![202002081040](/assets/202002081040.gif)\n\n希尔排序是将插入排序中的交换相邻元素改为交换不相邻元素\n\n- 选择一个增量序列t1，t2，…，tk\n- 按增量序列个数k，对序列进行k 趟排序\n\n```java\nint h = 1;\n// 计算增长序列，1,4，13,40...\nwhile (h < a.length / 3) {\n    h = 3 * h + 1;\n}\nwhile (h>=1){\n    for (int i = h; i < a.length; i++) {\n        // 对第i,i-h,i-2*h,i-3*h进行插入排序\n        var e = a[i];\n        int j;\n        for (j = i; j > h && less(a[j - h], e); j-=h) {\n            a[j]=a[j-h];\n        }\n        a[j]=e;\n    }\n    h/=3;\n}\n```\n\n## 归并排序\n\n![202002081126](/assets/202002081126.gif)\n\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列\n\n对两个有序子序列进行合并，得到一个更大的有序子序列，以此类推，直到只剩下一个序列\n\n- 但是一个缺点是需要额外的O(N)空间\n\n```java\nprivate void mergeSort(Comparable<?>[] a, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int mid = (l + r) / 2;\n    mergeSort(a, l, mid); // 对左边排序\n    mergeSort(a, mid + 1, r); // 对右边排序\n    merge(a, l, mid, r); // 对两个数组进行归并\n}\nprivate void merge(Comparable<?>[] a, int l, int mid, int r) {\n    // 开辟一块新空间给l-r之间的元素\n    Comparable<?>[] aux = new Comparable<?>[r - l + 1];\n    for (int i = l; i <= r; i++) {\n        aux[i - l] = a[i];\n    }\n\n    int i = l, j = mid + 1;\n    // 对l到r之间的元素进行扫描，将它们放到指定位置\n    for (int k = l; k <= r; k++) {\n        if (i > mid) { // 如果左指针已经跑过了mid，那此时让右指针去跑\n            a[k] = aux[j - l];\n            j++;\n        } else if (j > r) { // 如果右指针已经跑完了，则此时让左指针去跑\n            a[k] = aux[i - l];\n            i++;\n        } else if (less(aux[i - l], aux[j - l])) { // 否则就比较左右两指针谁的值比较小，谁小就把谁的值复制到结果里，然后该指针往后移动\n            a[k] = aux[i - l];\n            i++;\n        } else {\n            a[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n```\n\n### 优化\n\n当mid+1位置的元素大于mid位置的元素时，就没有必要进行归并了\n\n```java\nif (greater(a[mid],a[mid+1])){\n    merge(a, l, mid, r);\n}\n```\n\n也可以当被归并排序的数组数量小于某一数量级时，使用其他排序算法，来提高性能\n\n### 自底向上的归并排序\n\n```java\n// 每次归并的数组大小依次为1 2 4 ...\nfor (int sz = 1; sz <= a.length; sz += sz) {\n    for (int i = 0; i < a.length; i += sz + sz) {\n        // 归并a[i...i+size-1] 与 a[i+size...i+2*size-1]\n        if (i + sz < a.length) { // 只有左数组长度小于整个排序数组长度使（代表目前没有右数组），才进行归并（否则数组就是有序的了）\n            merge(a, i, i + sz - 1, min(i + sz + sz - 1, a.length - 1));\n        }\n    }\n}\n```\n\n### 外部归并排序\n\n对于大数据量，超过内存容量的数据，归并排序可以利用外存来进行排序\n\n![202279133543](/assets/202279133543.webp)\n\n归并的层数越多，需要进行的IO次数也就越多，可以通过增加每次同时的归并文件数量，比如每次不是两辆归并，而是五五归并，减少归并层数以此来减少IO\n\n## 快速排序\n\n![202002081411](/assets/202002081411.gif)\n\n选定一个元素，将比该元素小的元素放其左边，比它大的放在其右边，并递归地对它左右两边的子序列进行排序\n\n- 快速排序在最差的情况下，会退化为O(N^2)\n\n```java\nprivate void quickSort(Comparable<?>[] a, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int p = partition(a, l, r);\n    quickSort(a, l, p - 1);\n    quickSort(a, p + 1, r);\n}\n\n/**\n * 返回一个p，使得a[l...p-1] < a[p] 并且 a[p+1...r] > a[p]\n */\nprivate int partition(Comparable<?>[] a, int l, int r) {\n    var v = a[l];\n    int j = l;\n    // 从左到右扫描（一）\n    for (int i = l + 1; i <= r; i++) {\n        //如果扫描的元素小于v，则将该元素跟大数组的第一个元素交换，同时，小数组的位置扩张1（二）\n        if (less(a[i], v)) {\n            swap(a, j + 1, i);\n            j++;\n        }\n    }\n    // 最后，将v与小数组的最后一个元素交换位置（三）\n    swap(a, l, j);\n    return j;\n}\n```\n\n**一**\n\n![批注 2020-02-08 134532](/assets/批注%202020-02-08%20134532.png)\n\n**二**\n\n![批注 2020-02-08 134637](/assets/批注%202020-02-08%20134637.png)\n\n**三**\n\n![批注 2020-02-08 134920](/assets/批注%202020-02-08%20134920.png)\n\n### 优化\n\n当数组里有大量相同的元素，快速排序的时间复杂度为退化到N^2,解决方法是在两侧使用双指针向中间扫描\n\n![批注 2020-02-08 142132](/assets/批注%202020-02-08%20142132.png)\n\n- 双路快速排序\n\n```java\nprivate int partition(Comparable<?>[] a, int l, int r) {\n    var v = a[l];\n    // i:a[l+1...i] <=v  j:[j...r] >=v\n    int i = l + 1, j = r;\n    while (true) {\n        while (i <= r && less(a[i], v)) i++;\n        while (j >= l + 1 && greater(a[j], v)) j--;\n        if (i > j) {\n            break;\n        } else {\n            swap(a, i, j);\n            i++;j--;\n        }\n    }\n    swap(a,l,j);\n    return j;\n}\n```\n\n- 三路快速排序\n\n```java\nprivate void quickSort(Comparable[] a, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n\n    // partition\n    var v = a[l];\n\n    int lt = l; // a[l+1...lt] < v\n    int gt = r + 1; // a[gt...r] > v\n    int i = l + 1; // a[lt+1...i) == v\n    while (i < gt) {\n        if (a[i].compareTo(v) < 0) {\n            swap(a, i, lt + 1);\n            lt++;\n            i++;\n        } else if (a[i].compareTo(v) > 0) {\n            swap(a, i, gt - 1);\n            gt--;\n        }else {\n            i++;\n        }\n    }\n    swap(a,i,lt);\n\n    quickSort(a, l, lt - 1);\n    quickSort(a, gt, r);\n}\n```\n\n归并排序与快速排序两个算法都使用了分治算法\n\n## 桶排序\n\n将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的\n\n```mermaid\nstateDiagram-v2\n    1 2 3 4 5 6 7 8 9\n    1 --> [1,3]\n    2 --> [1,3]\n    3 --> [1,3]\n    4 --> [4,6]\n    5 --> [4,6]\n    6 --> [4,6]\n    7 --> [7,9]\n    8 --> [7,9]\n    9 --> [7,9]\n```\n\n同排序对数据的分布是有要求的，如果数据在各个桶内分布不均匀，桶内数据排序的时间复杂度就不是常量级\n\n## 计数排序\n\n当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，就可以把数据划分成 k 个桶\n\n统计待排序数组中每个元素出现的次数，然后根据每个元素出现的次数将其放置到输出数组的正确位置上，从而实现排序\n\n```js\n[2 5 3 0 2 3 0 3] => [2,0,2,3,0,1] // 0出现了2次\n[2,0,2,3,0,1] => [2,2,4,7,7,8] // 小于等于1的有两个 小于等于5的有8个\n// 从后往前扫描 [2 5 3 0 2 3 0 3]\n1: [0,0,0,0,0,0,0,3,0] // 小于等于3的有7个，所以把第一个3放在下标6，并把小于等于3的数量-1\n2: [0,0,0,0,0,0,0,3,0] // 小于等于0的有2个，所以把第一个0放在下标1\n3: [0,0,0,0,0,0,3,3,0] // 小于等于3的有6个, 所以把第二个3放在下标5\n...\n```\n\n计数排序只能用在数据范围不大的场景中，而且计数排序只能给非负整数排序\n\n## 基数排序\n\n将待排序的元素按照个位、十位、百位等位数进行排序，从最低位开始，依次对每一位进行计数排序或桶排序\n\n```js\nhke          iba        hac         hac\niba          hac        iba         hke\nhzg  ->      hke  ->    hke    ->   hzg\nikf          ikf        ikf         iba\nhac          hzg        hzg         ikf\n```\n\n基数排序需要可以分割出独立的“位”来比较，而且位之间有递进的关系，每一位的数据范围不能太大，要可以用线性排序算法来排序\n\n## 猴子排序\n\n```py\ndef is_sorted(arr):\n    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\ndef monkey_sort(arr):\n    while not is_sorted(arr):\n        random.shuffle(arr)\n```\n\n## 睡眠排序\n\n```py\ndef sleep_sort(arr):\n    def worker(num):\n        time.sleep(num)\n        print(num)\n\n    threads = []\n    for num in arr:\n        t = threading.Thread(target=worker, args=(num,))\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n```\n\n## 洗牌算法\n\n### Fisher-Yates Shuffle\n\n每次选择的时候从剩余可选的元素中随机选择一个\n\n```cpp\n\nvoid Fisher_Yates_Shuffle(vector<int>& arr,vector<int>& res) {\n     int k;\n     int n = arr.size();\n     for (int i=0;i<n;i++) {\n       k=rand()%arr.size();\n       res.push_back(arr[k]);\n       arr.erase(arr.begin()+k);\n     }\n}\n```\n\n- 整体的时间复杂度是 O(n^2)，空间复杂度是O(n)\n\n### Knuth-Durstenfeld Shuffle\n\n第 i 位元素和第 i～n-1 位元素中的任意一个元素交换\n\n```cpp\nvoid shuffle(vector<int>& arr) {\n    for (int i = 0; i < n; i++) {\n        int tmp;\n        int target = i + rand() % (n - i);\n        tmp = arr[i];\n        arr[i] = arr[target];\n        arr[target] = tmp;\n    }\n}\n```\n","metadata":"tags: ['算法']","hasMoreCommit":true,"totalCommits":15,"commitList":[{"date":"2024-02-07T14:41:52+08:00","author":"MY","message":"✏排序","hash":"9ed64c464da102d8345b1194ac5d4bc2cf4b5fe3"},{"date":"2024-02-04T18:54:31+08:00","author":"MY","message":"✏算法","hash":"6ca3803a2d09a54bb8a2b9f56b9c44e0677812b1"},{"date":"2022-08-26T18:08:50+08:00","author":"cjiping","message":"✏️修正归并排序错误","hash":"b7bd862f8d20fa7c5c90e99853c5b13822916283"},{"date":"2022-08-15T13:50:45+08:00","author":"cjiping","message":"✏️算法","hash":"651b1ce80df8b7183bf00af1f209c99db754a5ef"},{"date":"2022-07-13T14:35:09+08:00","author":"cjiping","message":"✏️更新 洗牌算法","hash":"601b190609bec0347491efc2f12b315f87e3515b"},{"date":"2022-07-09T15:26:49+08:00","author":"MY","message":"✏️更新 算法","hash":"2d8ca900074aa66c48b668e03cc082547eae7449"},{"date":"2020-08-05T08:55:06+08:00","author":"MY","message":"✏更新 排序算法","hash":"05b392a49747d4dd22100207460659d12476500e"},{"date":"2020-02-09T13:57:16+08:00","author":"MY","message":"增加排序算法的稳定性","hash":"524a2c94ae3e381c9a615065ce4c7cb59e63b0ee"},{"date":"2020-02-08T15:23:49+08:00","author":"MY","message":"更新快速排序","hash":"e932ef898bacb0a2c093dbbb85449eb77c6be5d0"},{"date":"2020-02-08T12:05:34+08:00","author":"MY","message":"更新归并排序","hash":"6d60b86e828569a7d6e9c90dbc0ab534a6a147f0"}],"createTime":"2019-11-29T21:18:06+08:00"}