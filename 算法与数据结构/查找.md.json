{"name":"查找","id":"算法与数据结构-查找","content":"# 查找\n\n## 顺序查找\n\n按照顺序一个个比较，直到序列末尾\n\n```c\nint seq_search(int array[], int n, int key)\n{\n    int i;\n    for(i = 0; i < n; i++)\n    {\n        if(key == array[i])\n        {\n            return i;   //查找成功\n        }   \n    }\n    return -1;          //查找失败\n}\n```\n\n## 二分查找\n\n**通过对一个有序数组中对元素依次比较，从而能实现对数级别时间复杂度的查找**\n\n![二分查找](/assets/屏幕截图%202022-07-09%20134232.png)\n\n根据左右指针计算出一个mid指针 如果mid指针处的元素等于目标值 则要查找的目标就是在这里\n\n否则如果mid处的指针比目标值大 则右指针等于mid-1 否则左指针等于mid+1\n\n然后重复上述操作 直到左指针大于右指针\n\n```java\nint l = 0, r = a.length - 1;\nwhile (l <= r) {\n    int mid = l + (r - l) / 2;\n    if (a[mid].equals(target)) {\n        return mid;\n    }\n    \n    if (less(target, a[mid])) {// 要查找的元素在左边\n        r = mid - 1;\n    } else if (greater(target, a[mid])) { // 要查找的元素在右边\n        l = mid + 1;\n    }\n}\nreturn -1;\n```\n\n- 二分查找依赖于顺序表结构\n- 二分查找针对有序数据\n- 二分查找依赖于一整块内存的随机访问，对于过大无法在内存中分配空间的数据也不适合\n\n这个算法在快速定位BUG的时候也挺好用，一分为二，确定问题在前端还是后端，再继续划分，确定问题在系统哪一层\n\n## 时间轮\n\n### round时间轮\n\n![2022616155327](/assets/2022616155327.png)\n\n时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 2+3=5 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 (2+12)%8=6 个 slot\n\n怎么区分每个任务是否需要立即执行，还是需要等待下一圈 round，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round=0，需要立即执行；第二个任务 round=1，需要等待 18=8s 后执行；第三个任务 round=2，需要等待 28=8s 后执行。所以当时针转动到对应 slot 时，只执行 round=0 的任务\n\n### 分层时间轮\n\n![2022616155817](/assets/2022616155817.png)\n\n当上层的时间轮转完一圈时，下层的定时器就要增加一个刻度\n\n假设我们的任务需要在每天的 7:30:20 秒执行一次。任务首先添加于小时级别时钟轮的第 7 号刻度上，当其轮询线程访问到第 7 号刻度时，就将此任务转移到分钟级别时钟轮的第 30 号刻度上。当分钟级别的时钟轮线程访问到第 30 号刻度，就将此任务转移到秒级别时钟轮的第 20 号刻度上。当秒级别时钟轮线程访问到第 20 号刻度时，最终会将任务交给异步线程负责执行\n\n## bitmap\n\n位图通过数组下标来定位数据，所以访问效率非常高\n\n```js\n1存在 => 010000\n2存在 => 001000\n1,2都存在 => 011000\n```\n\n## 布隆过滤器\n\n![布隆过滤器](/assets/2022712144645.webp)\n\n一串数据通过n个散列函数将一个位图的n位设置为1，当要查询时，对数据进行散列 判断对应的n位是否都为1 若都为1, 则就是可能存在\n\n所以布隆过滤器也没有足够的信息可以删除指定的key，为了应对缓存数据过期，可以采用定期重建的方法，重建完保持两个过滤器的双写，一段时间后，就把全部请求都给到较新的这个过滤器上，清除老的过滤器\n\n## 布谷鸟过滤器\n\n- 布谷鸟哈希：使用两个哈希函数对一个key进行哈希，得到桶中的两个位置，如果有空位，key就放在空位里，否则就要随机踢掉一个元素，踢出的元素再计算哈希找到相应的存储位置\n\n![2022817204730](/assets/2022817204730.jpg)\n\n哈希表的基本单位称为条目（entry）。 每个条目存储一个指纹（fingerprint），指纹指的是使用一个哈希函数生成的n位比特位\n\n相比布隆过滤器，布谷鸟过滤器可以通过从哈希表删除相应的指纹删除插入的项，由于哈希的特性，是存在误删的可能的，同时，只要不发生桶溢出，在查询的时候就不会出现假阳\n\n## 索引\n\n### 功能性需求\n\n- 索引的数据是格式化数据还是非格式化数据\n- 索引的数据是静态数据还是动态数据\n- 索引存储在内存还是硬盘\n- 单值查找还是区间查找\n- 单条件查找还是多条件组合查找\n\n### 非功能性需求\n\n- 对存储空间的消耗不能过大\n- 考虑索引查询效率的同时，还要考虑索引的维护成本\n\n### 索引常用数据结构\n\n1. 散列表\n2. 红黑树\n3. B+树\n4. 跳表\n5. 布隆过滤器\n","metadata":"tags: ['算法']","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2024-02-27T20:07:27+08:00","author":"MY","message":"✏算法","hash":"8a6529c0b37f98855cb1857f560564cc6401fd7b"},{"date":"2024-02-22T19:29:07+08:00","author":"MY","message":"📦算法与数据结构","hash":"a43c1f5ba155151373c1c4acad9c95803f6ca65a"},{"date":"2024-02-21T19:16:03+08:00","author":"MY","message":"✏查找","hash":"31129e7113453bdc123670f04658b145a3927aea"},{"date":"2024-02-20T19:15:31+08:00","author":"MY","message":"✏查找","hash":"03ecf112bbc77ebde7f8d3b54d923f5a82cff6fc"},{"date":"2023-03-09T09:41:00Z","author":"My","message":"🛠替换在线图片","hash":"0c8b08bc22fbe482ba02da2f1fcad211441d3c23"},{"date":"2022-07-13T14:09:29+08:00","author":"cjiping","message":"✏️更新 定时算法","hash":"9e2f23d2d92e2e8257b36b252f33c3674d3e8889"},{"date":"2022-07-09T15:26:49+08:00","author":"MY","message":"✏️更新 算法","hash":"2d8ca900074aa66c48b668e03cc082547eae7449"},{"date":"2022-07-08T17:45:19+08:00","author":"cjiping","message":"✏️更新 数据结构","hash":"167b36bdc37603af417a45def3bb166a9a639982"},{"date":"2022-06-16T17:48:10+08:00","author":"cjiping","message":"✏️更新 时钟轮算法","hash":"3828c7ca3d3480aba76febbec2ae16a63cadfea7"},{"date":"2020-08-05T09:16:04+08:00","author":"MY","message":"✏更新 查找算法","hash":"6b940c7519abce7e3becf78e3d08af48c845f5ef"}],"createTime":"2019-12-02T21:11:00+08:00"}