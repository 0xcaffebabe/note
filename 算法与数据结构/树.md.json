{"name":"树","id":"算法与数据结构-树","content":"# 树\n\n## 二叉查找树\n\n- 擅长数据的查找\n- 高效\n\n**特点**\n\n每个结点的键值大于左孩子，小于右孩子\n\n每个孩子又是二叉查找树\n\n**二分查找树不一定是完全二叉树**\n\n对于任何节点：\n\n- 左子树上所有节点都小于它\n- 右子树所有节点都大于它\n\n### 插入\n\n```java\nif (root == null) {\n    count++;\n    return new Node(key, value); // 当前节点为null，则创建一个节点返回\n}\nif (key.equals(root.key)) { //　当前节点等于要插入的节点，则直接覆盖\n    root.value = value;\n} else if (less(key, root.key)) { //　当前节点比要插入的大，则向当前节点的左子树插入\n    root.left = insert(root.left, key, value);\n} else if (greater(key, root.key)) {  //　当前节点比要插入的小，则向当前节点的右子树插入\n    root.right = insert(root.right, key, value);\n}\n```\n\n### 查找\n\n原理同插入，根据左子树比父节点小，右子树比父节点大的条件\n\n```java\nif (root == null){\n    return null;\n}\nif (key.equals(root.key)){\n    return root.value;\n}else if(less(key,root.key)){\n    return search(root.left,key);\n}else {\n    return search(root.right,key);\n}\n```\n\n**floor与ceil**\n\n- floor：是最接近key值且**小于**key的节点\n- ceil：是最接近key值且**大于**key的节点\n\n\n### 遍历\n\n- 前序遍历\n\n先访问当前节点，再递归访问左右子树\n\n```java\nif (root != null){\n    consumer.accept(root.key,root.value);\n    preOrder(root.left,consumer);\n    preOrder(root.right,consumer);\n}\n```\n\n- 中序遍历\n\n先递归访问左子树，再访问自身，再递归访问右子树\n\n```java\nif (root != null){\n    preOrder(root.left,consumer);\n    consumer.accept(root.key,root.value);\n    preOrder(root.right,consumer);\n}\n```\n\n- 后序遍历\n\n先递归访问左右子树，在访问自身\n\n```java\nif (root != null){\n    preOrder(root.left,consumer);\n    preOrder(root.right,consumer);\n    consumer.accept(root.key,root.value);\n}\n```\n\n- 广度优先遍历(层序)\n\n```java\nQueue<Node> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\n    var node = queue.remove();\n    consumer.accept(node.key,node.value);\n    if (node.left != null){\n        queue.add(node.left);\n    }\n    if (node.right != null){\n        queue.add(node.right);\n    }\n}\n```\n\n### 删除\n\n分为三种情况\n\n- 删除叶子节点\n  - 直接解除父节点对其的引用即可\n\n- 删除只有一个子节点的\n  - 将父节点指向其子节点\n\n```java\nprivate Node removeMax(Node node) {\n    \n    if (node.right == null) {\n        // 代表当前节点就是最大节点，所以返回当前节点的左子树给父节点\n        count--;\n        return node.left;\n    }\n    // 将删除的节点的左子树作为父节点的右子树\n    node.right = removeMax(node.right);\n    return node;\n}\n```\n\n- 删除有两个子节点的\n\n**Hubbard Deletion**\n\n 使用被删除节点右子树中的最小节点来代替被删除节点\n\n### 局限性\n\n- 同样的数据会对应不同的查找树\n- 查找树随着数据的不断增加或插入容易失衡，退化成链表\n\n## 平衡二叉树\n\n- 树及其子树的左右高度差不能超过1\n- 空树及只有根节点的树也是平衡二叉树\n\n## AVL树\n\n在增加和删除节点时通过旋转来保持平衡\n\n右旋：以某个节点为中心 将它沉入当前右子节点的位置 然后让当前左子节点作为新树的根\n\n![屏幕截图 2020-09-22 120018](/assets/屏幕截图%202020-09-22%20120018.png)\n\n左旋：\n\n![屏幕截图 2020-09-22 120118](/assets/屏幕截图%202020-09-22%20120118.png)\n\n## 2-3查找树\n\n![20227816630](/assets/20227816630.webp)\n\n### 搜索\n\n搜索的过程和二叉树并没有太多的区别，只是遇到 3 节点的时候，多判断一次是否介于 a、b 之间\n\n### 插入\n\n> 2-3树之所以完美平衡，关键在于插入时的维护\n\n![插入的时候节点分裂](/assets/20227816920.webp)\n\n### 删除\n\n## 红黑树\n\n红黑树，正是采用标准的二叉查找树节点附着上额外的颜色信息来表示 2-3 树的实现，每一个红色节点都和它的父亲节点一起，构成了一个 3 节点的模拟，通过旋转操作完成 2-3 节点的合并和分裂，从而在不改变二叉树节点结构的前提下，保证二叉树的有序性和平衡性\n\n红黑树不追求左右子树高度差不超过1，而是保证从根节点到叶尾的最长路径不超过最短路径的2倍，高度近似 log2n，是近似平衡的，插入、删除、查找操作的时间复杂度都是 O(logn)\n\n其他约束条件：\n\n- 节点只能是红色或者黑色\n- 根节点必须是黑色\n- NIL(Nothing in leaf)节点都是黑色\n- 相连的两个节点不能都是红色\n- 根节点到叶子节点的所有路径黑色节点数量都相同\n\n红黑树的任何旋转至多3次就能完成\n\n这些约束，都是为了保证每一颗红黑树和 2-3 Tree 是一一对应的\n\n![20227816326](/assets/20227816326.webp)\n\n### 基本操作\n\n#### 旋转\n\n左旋：本质上就是将某个 3 节点从以较小的键为根转移成较大的键为根\n\n![202278164648](/assets/202278164648.webp)\n\n#### 反色\n\n![](/assets/20233916912.png)\n\n### 插入\n\n新插入的节点均设为红色\n\n#### 黑节点插入\n\n![202278164949](/assets/202278164949.webp)\n\n#### 红节点插入\n\n![202278165136](/assets/202278165136.webp)\n\n![20227816521](/assets/20227816521.webp)\n\n![颜色反转](/assets/202278165232.webp)\n\n### 删除\n\n## 堆\n\n> 可被应用优先级队列\n\n### 堆的存储\n\n#### 二叉堆\n\n- 是一棵完全二叉树\n- 每个节点和其子节点都有一样的偏序关系，要么大于要么小于\n\n大顶堆就要求堆中所有节点的值，一定大于其左右子树中的任何一个节点的值,小顶堆就正好相反\n\n优先级队列适合用大顶堆实现，这样每次只需要从顶部取出元素即可获得优先级最高的元素\n\n- [PriorityQueue](/编程语言/JAVA/JAVA并发编程/并发集合.md#PriorityQueue)\n\n#### 用数组存储二叉堆\n\n```mermaid\nstateDiagram-v2\n  62 --> 41\n  62 --> 30\n  41 --> 28\n  41 --> 16\n  30 --> 22\n  30 --> 13\n  28 --> 19\n  28 --> 17\n  16 --> 15\n```\n\n```\n[62,41,30,28,16,22,13,19,17,15]\n```\n\n#### 操作\n\n- shift up\n\n新加入的元素与其父元素判断，是否比父元素大，如果是，交换两个元素，以此类推，直到小于其父亲\n\n```java\nwhile (less(data,i/2,i)) {\n    swap(data,i/2,i);\n    i/=2;\n}\n```\n\n- shift down\n\n只能取出根节点的元素，取出后，使用堆中的最后一个元素填补空缺\n\n填补后，跟左右两个孩子比较，哪个孩子大就跟谁交换...以此类推，直至自己比两个孩子都大\n\n```java\nwhile (2 * k <= count) {\n    int j =2*k;\n    // 确定要跟左子树比较还是跟右子树\n    if (j+1<=count && greater(data,j+1,j)){\n        // 右子树\n        j++;\n    }\n    // 如果自己大于要比较的子树，则停止\n    if (greaterThan(data,k,j)){\n        break;\n    }\n    swap(data,k,j);\n    k=j;\n}\n```\n\n- 删除\n\n将根节点删除后，我们把二叉堆中最后的元素提到根节点的位置，这样又可以保证新的二叉树是一颗满二叉树了，然后要做的比较 + 交换\n\n### 堆排序\n\n```java\nMaxHeap<Comparable<?>> heap = new MaxHeap<>(a.length+1);\nfor (int i = 0; i < a.length; i++) {\n    heap.insert(a[i]);\n}\nfor (int i = 0; i < a.length; i++) {\n    a[i]=heap.remove();\n}\n```\n\n### Heapify\n\n堆化：将数组转为堆\n\n对于一棵完全二叉树，其最后一个非叶子节点是元素个数除二取整\n\n所以要把一个数组堆化，只需要对其非叶子结点进行shift down\n\n```java\nfor (int i = 0; i < a.length; i++) {\n    data[i + 1] = a[i];\n}\ncount = a.length;\n// 对其非叶子结点进行shift down\nfor (int i = count / 2; i >= 1; i--) {\n    shiftDown(i);\n}\n```\n\n### 原地堆排序\n\n```java\nint n = a.length;\n// 先将整个数组构造成一个最大堆\nfor (int i = (n - 2) / 2; i >= 0; i--) {\n    shiftDown(a, n, i);\n}\n// 将堆中的第一大元素移到末尾，再次构造最大堆(排除末尾排好序的元素)\n// 然后下一次循环再将第一大元素移到倒数第二个...以此类推，直至只剩一个元素\nfor (int i = n - 1; i > 0; i--) {\n    swap(a, 0, i);\n    shiftDown(a, i, 0);\n}\n```\n\n### 索引堆\n\n- 引入一个index数组，在增删改查的时候，提供一个index\n- 索引堆根据这个index找到数据在data中的位置\n\n\n## 并查集\n\n并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题\n\n- 连接问题\n\n### find\n\n- find操作返回该节点连接的节点\n\n```java\nint find(int p) {\n    return data[p];\n}\n```\n\n另外一种实现，通过判断两个节点是否拥有同样的祖先来判断是否相连\n\n```java\nwhile (p != parent[p]) {\n    p = parent[p];\n}\nreturn p;\n```\n\n### isConnected\n\n- 判断两个节点是否连接在一起的（判断这两个节点是否连接了同一个节点）\n\n```java\nboolean isConnected(int p, int q) {\n    return find(p) == find(q);\n}\n```\n\n### union\n\n- 连接两个节点（将一个节点指向另外一个节点）\n\n```java\nint pid = find(p);\nint qid = find(q);\nif (pid == qid){\n    return;\n}\nfor (int i = 0; i < count; i++) {\n    if (data[i]==pid){\n        data[i]=qid;\n    }\n}\n```\n\n使用另外一种实现的union\n\n```java\nint qRoot = find(p);\nint pRoot = find(q);\nif (qRoot == pRoot){\n    return;\n}\nparent[pRoot]=qRoot;\n```\n\n基于size的优化，维护一个size数组，代表以i为根的集合的元素个数\n\n```java\nif (sz[pRoot]<sz[qRoot]){        \n    parent[pRoot] = qRoot;\n    sz[qRoot]+=sz[pRoot];\n}else {\n    parent[qRoot] = pRoot;\n    sz[qRoot]+=sz[pRoot];\n}\n```\n\n使用rank来决定谁连接谁\n\n```java\nif (rank[pRoot] < rank[qRoot]) {\n    parent[pRoot] = qRoot;\n} else if ((rank[pRoot] > rank[qRoot])) {\n    parent[qRoot] = pRoot;\n} else {\n    parent[pRoot] = qRoot;\n    rank[qRoot] += 1;\n}\n```\n\n### 路径压缩\n\n- find\n\n```java\nwhile (p != parent[p]) {\n    parent[p]=parent[parent[p]];\n    p = parent[p];\n}\nreturn p;\n```\n\n","metadata":"tags: ['数据结构']","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2024-02-22T19:29:07+08:00","author":"MY","message":"📦算法与数据结构","hash":"a43c1f5ba155151373c1c4acad9c95803f6ca65a"},{"date":"2022-07-08T17:45:19+08:00","author":"cjiping","message":"✏️更新 数据结构","hash":"167b36bdc37603af417a45def3bb166a9a639982"},{"date":"2020-09-22T12:17:20+08:00","author":"MY","message":"➕增加 树","hash":"b5aa6d1e98b5247469bd2381bb4dc3aad1bfb7ba"}],"createTime":"2020-09-22T12:17:20+08:00"}