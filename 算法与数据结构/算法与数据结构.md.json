{"name":"算法与数据结构","id":"算法与数据结构-算法与数据结构","content":"# 算法与数据结构\n\n## 算法\n\n- 有穷性\n- 确定性\n- 可行性\n- 输入输出\n\n### 好的算法\n\n#### 正确性\n\n> 循环不变式\n\n在排序算法中，每一轮循环做的操作就是一轮不变式，通过证明三条性质来确定算法是正确的\n\n- 初始化：第一次迭代前，为真\n- 保持：如果迭代之前为真，迭代之后也为真\n- 终止时，停止归纳\n\n#### 易读性\n#### 健壮性\n#### 高效性\n#### 低存储性\n\n### 分析算法\n\n对于复杂度的分析，一般分析的都是在最坏情况下的复杂度\n\n需要分析复杂度的原因在于不同的算法对于不同量级的数据，所需要的时间与空间会相差很多\n\n复杂度的衡量单位是**增长量级**，也就是时间或空间的增长率\n\n#### 时间复杂度\n\n- 常数：1\n- 线性：n\n- 多项式：n^2 n^3\n- 指数：2^n n!\n- 对数：logn\n\n可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)\n\n时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题\n\n分析方法：\n\n- 加法法则：总复杂度等于量级最大的那段代码的复杂度\n  - 当代码的复杂度由多个数据的规模来决定，表示为$O(n_1+_2+...+n_n)$\n- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n最好时间复杂度：最理想的情况下，执行这段代码的时间复杂度\n\n最坏时间复杂度：最糟糕的情况下，执行这段代码的时间复杂度\n\n平均时间复杂度：了解输入的概率分布是关键，对算法在所有可能输入上的性能进行平均分析\n\n均摊时间复杂度：一些操作可能会花费较长时间，但它们并不经常发生，因此这些操作的成本可以分摊到其他较为常见的操作上\n\n##### 递归树\n\n对于使用分治策略的算法，可以使用一棵树描述其时间复杂度\n\n```mermaid\nstateDiagram-v2\n  n --> 1(2/n)\n  n --> 2(2/n)\n  1(2/n) --> 1(4/n)\n  1(2/n) --> 2(4/n)\n  2(2/n) --> 3(4/n)\n  2(2/n) --> 4(4/n)\n```\n\n只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)\n\n### 设计算法\n\n- [算法策略](/算法与数据结构/算法策略.md)\n\n#### 空间复杂度","metadata":"tags: ['数据结构', '算法']","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2024-02-22T19:29:07+08:00","author":"MY","message":"📦算法与数据结构","hash":"a43c1f5ba155151373c1c4acad9c95803f6ca65a"},{"date":"2024-01-31T18:40:33+08:00","author":"MY","message":"✏算法","hash":"0dee756afa47ced5c7657efd069c78f60e7f5912"},{"date":"2022-03-25T18:27:53+08:00","author":"MY","message":"✏️更新 算法","hash":"5e42591ca27238a6a336f5832507bf0fe33cb07a"},{"date":"2020-07-07T13:02:08+08:00","author":"MY","message":"✏更新 算法","hash":"77ec8987f5aa273273aa594bafc22d228b83c40c"}],"createTime":"2020-07-07T13:02:08+08:00"}