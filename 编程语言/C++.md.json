{"name":"C++","id":"编程语言-C++","content":"# C++\n\n## 生命周期\n\n- 编码\n- 预处理：目的是文字替换，用到的就是各种预处理指令，比如 #include、#define、#if 等\n- 编译\n- 链接\n- 运行\n\n### 预处理阶段编程\n\n```cpp\n#include <iostream> // 可以包含任意的文件，只是编译器无法识别\n// 避免头文件被多次包含\n#ifndef _XXX_H_INCLUDED_\n#define _XXX_H_INCLUDED_\n\n...    // 头文件内容\n\n#endif // _XXX_H_INCLUDED_\n\n#ifdef AUTH_PWD                  // 检查是否已经有宏定义\n#  undef AUTH_PWD                // 取消宏定义\n#endif                           // 宏定义检查结束\n#define AUTH_PWD \"xxx\"           // 重新宏定义\n\n// 条件编译\n#elif (NGX_LINUX)\n#  include <ngx_linux.h>\n\n#endif\n```\n\n### 编译阶段编程\n\n属性：编译阶段的“标签”，用来标记变量、函数或者类\n\n```cpp\n[[deprecated(\"过时\")]] // c++14 or later\n//[[gnu::deprecated]] // c+11 or later\nint old_func()\n{\n    //[[gnu::deprecated(\"I hate this\")]]\n    int value = 0;\n    return value;\n}\n\nint main() {\n  old_func();\n  return 1;\n}\n```\n\n静态断言：在编译阶段计算常数和类型，如果断言失败就会导致编译错误\n\n```cpp\nstatic_assert(1 != 1, \"1 is 1\");\n```\n\n## RAII\n\nRAII（Resource Acquisition Is Initialization）通过对象的生命周期来控制资源的分配和释放。RAII的核心思想是将资源的获取与对象的初始化绑定在一起，将资源的释放与对象的销毁绑定在一起\n\n```cpp\nstd::mutex mtx;\n    {\n        std::lock_guard<std::mutex> lock(mtx); // 构造函数中加锁\n        // 临界区代码\n    }\n```\n\n## 面向对象\n\n```cpp\n#include <iostream>\n\nclass Animal {\n  private:\n    int age = 0;\n  public:\n    friend class Dog;\n    // 构造函数\n    Animal() = default; // 明确告诉编译器，使用默认实现\n    // 析构函数\n    ~Animal() {\n      std::cout << \"~Animal\\n\" << std::endl;\n    }\n    void test() {\n      std::cout << \"Animal\\n\";\n    }\n    virtual void test1() {\n      std::cout << \"Animal\\n\";\n    }\n};\n\n// 继承\nclass Dog: public Animal {\nprivate:\n  int name = 0;\npublic:\n  Dog() = default;\n  Dog(int name) {\n    this->name = name;\n  }\n  void test() {\n    std::cout << \"Dog\\n\";\n  }\n\n  // 方法覆写\n  void test1() override {\n    std::cout << \"Dog\\n\";\n  }\n\n  void test2(const Animal& a) {\n    // 访问友元类的私有数据\n    a.age;\n  }\n\n  // 运算符重载\n  Dog operator+(const Dog & dog) {\n    std::cout << \"two dog plus\\n\";\n    return Dog(2);\n  }\n};\n\nint main() {\n  Animal* a = new Dog();\n  a->test(); // Animal\n  a->test1(); // Dog\n\n  Animal b = Dog();\n  b.test1(); // Animal\n\n  Dog c;\n  Dog d;\n  Dog e = c + d;\n  \n}\n```\n\n## 变量\n\n### 自动类型推导\n\n- auto 只能用在初始化语句中\n- auto 总是推导出“值类型”，绝不会是“引用”\n- auto 可以附加上 const、volatile、*、& 这样的类型修饰符，得到新的类型\n\n```cpp\nauto        x = 10L;    // auto推导为long，x是long\n\nauto&       x1 = x;      // auto推导为long，x1是long&\nauto*       x2 = &x;    // auto推导为long，x2是long*\nconst auto& x3 = x;        // auto推导为long，x3是const long&\nauto        x4 = &x3;    // auto推导为const long*，x4是const long*\n\n// c++14后 auto也能用在函数返回值中\nauto f() {\n  return 1;\n}\n```\n\ndecltype 的形式很像函数，后面的圆括号里就是可用于计算类型的表达式（和 sizeof 有点类似），其他方面就和 auto 一样了，也能加上 const、*、& 来修饰\n\n```cpp\nvoid (*signal(int signo, void (*func)(int)))(int);\n// 使用decltype可以轻松得到函数指针类型\nusing sig_func_ptr_t = decltype(&signal);\n\n// 获取复杂类型\nstd::set s = {1,2,3};\nusing iterator_type = decltype(s.cbegin());\niterator_type iterator = s.cbegin();\n```\n\n### 初始化\n\n```cpp\n// 列表初始化\n// 编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 initializer_list。只需要声明一个接受 initializer_list 的构造函数即可使用\nvector<int> v{1, 2, 3, 4, 5};\n```\n\n### const/volatile/mutable\n\nconst\n\n- 它是一个类型修饰符，可以给任何对象附加上“只读”属性，保证安全\n- 它可以修饰引用和指针，“const &”可以引用任何类型，是函数入口参数的最佳类型\n- 它还可以修饰成员函数，表示函数是“只读”的，const 对象只能调用 const 成员函数\n\nvolatile\n\n- 表示变量可能会被“不被察觉”地修改，禁止编译器优化，每次使用时，都要去内存中读\n\nmutable\n\n- 对于一些特殊的变量，给它加上 mutable 修饰，解除 const 的限制，让任何成员函数都可以操作它\n\n```cpp\nclass A {\n  public:\n    int a = 1;\n    mutable int b = 2;\n    void test() {\n      a = 2;\n    }\n    void test1() const {\n      // a = 2; 不行\n      b = 2;\n    }\n};\n\nint main() {\n  const A a = A();\n  // a.test(); 无法调用\n  a.test1();\n  return 1;\n}\n```\n\n### 智能指针\n\n智能指针是代理模式的具体应用，它使用 RAII 技术代理了裸指针，能够自动释放内存，无需程序员干预\n\nunique_ptr：\n\nunique_ptr 是一个对象。不要对它调用 delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存，它也没有定义加减运算，不能随意移动指针地址，也不能通过拷贝赋值，要通过 move 语义进行指针的所有权转移\n\n```cpp\nclass A {\npublic:\n  ~A() {\n    cout << \"~A\";\n  }\n};\n\nint main() {\n  {\n    unique_ptr<A> p1(new A());\n    // auto p2 = p1; ERROR\n    auto p2 = move(p1); // 要通过 move 进行指针所有权转移\n  }\n  cout << \"exit\";\n  return 1;\n}\n```\n\nshared_ptr：\n\n其所有权是可以被安全共享的，其内部有个引用计数，会导致循环引用的问题。如果发生拷贝赋值——也就是共享的时候，引用计数就增加，而发生析构销毁的时候，引用计数就减少。只有当引用计数减少到 0，内存就会被回收\n\n```cpp\nshared_ptr<A> p3(new A());\nauto p4 = p3;\n```\n\nweak_ptr：\n\n只观察指针，不会增加引用计数（弱引用），但在需要的时候，可以调用成员函数 lock()，获取 shared_ptr（强引用）\n\n## 异常\n\n```mermaid\nstateDiagram-v2\n  direction BT\n  bad_alloc --> expcetion\n  runtime_error --> expcetion\n  logic_error --> expcetion\n  bad_cast --> expcetion\n  range_error --> runtime_error\n  overflow_error --> runtime_error\n  invalid_argument --> runtime_error\n  length_error --> runtime_error\n\n```\n\n```cpp\ntry {\n    throw runtime_error(\"runtime_error\");\n  }catch(const exception& e) {\n    cout << e.what();\n  }catch(const runtime_error& e) { // 只会按照顺序匹配，而不会根据异常继承树匹配最佳\n    cout << e.what();\n  }\n\n// noexcept 告知编译器该函数不会抛异常，可以做一些优化，但如果真的发生异常，程序直接崩掉\nint f() noexcept {\n  throw runtime_error(\"runtime_error\");\n}\n```\n\n### 异常安全\n\n当代码抛出异常时，程序的状态仍然保持一致，不会导致资源泄漏或数据损坏\n\n基本保证：即使发生异常，程序中的所有对象仍然处于有效状态，且不发生资源泄漏。程序的状态可能会改变，但不会有未定义行为\n\n强保证：操作失败并抛出异常，程序状态将保持不变。操作要么成功，要么在失败时不会对程序的状态产生影响\n\n无异常保证：操作保证不会抛出任何异常\n\n## lambda\n\n```cpp\nint n = 1;\n// = 捕获外层变量，值类型。 &捕获外层变量，引用类型\nauto f1 = [=](const int& a, const int& b) {\n  return a + b + n;\n};\n```\n\n## 标准库\n\n### 字符串\n\n字面量后缀：\n\n明确地表示它是 string 字符串类型，而不是 C 字符串\n\n```cpp\nusing namespace std::literals::string_literals; //必须打开名字空间\nauto str = \"hello\"s;\n```\n\n原始字符串：\n\n```cpp\nauto s = R\"(\\n123\\n)\"; // 输出\\n123\\n\n```\n\n字符串转换函数：\n\n```cpp\nusing namespace std;\ncout << s;\ncout << stoi(\"123\");\ncout << stol(\"123\");\ncout << stod(\"123.0\");\n```\n\n字符串视图：内部只保存一个指针和长度，无论是拷贝，还是修改，都非常廉价\n\n```cpp\nauto view = new string_view(\"aaa\")\n```\n\n### 容器\n\n```cpp\n// 动态数组\nvector<int> v(2);\nv.emplace_back(3);\n// 队列\ndeque<int> d;\nd.emplace_back(4);\n// 集合\nset s = {7, 3, 9};\n// 散列表\nunordered_map<int, int> map;\nmap.emplace(1,2);\n```\n\n迭代器：\n\n容器一般都会提供 begin()、end() 成员函数，调用它们就可以得到表示两个端点的迭代器。迭代器和指针类似，可以前进和后退，但不能假设它一定支持“++”“--”操作符\n\n```cpp\nfor(auto it = v.begin(); it != v.end(); it++) {\n  cout << *it;\n}\n// 更加通用的迭代器操作\nfor(auto it = v.begin(); it != v.end(); advance(it, distance(it, next(it)))) {\n  cout << *it;\n}\n```\n\n```mermaid\ngraph TD\n    A[Iterator<br>支持 ++ 和 *] --> B[InputIterator<br>用 * 读取]\n    A --> C[OutputIterator<br>用 * 输出]\n    B --> D[ForwardIterator<br>可反复读取]\n    D --> E[BidirectionalIterator<br>支持 --]\n    E --> F[RandomAccessIterator<br>支持跳跃和比较]\n    F --> G[ContiguousIterator<br>存储连续]\n```\n\n### 线程\n\n```cpp\nstatic once_flag flag;        // 全局的初始化标志\nthread_local int n = 0; // 线程本地变量\natomic<int> at = {0}; // 原子变量\n\nthread t1([&](){\n  n += 10;\n  cout << \"t1, \" << n;\n  at++;\n  // 只会被调用一次\n  call_once(flag, []{ cout << \"Hello, once\" << endl; });\n  cout << \"t1, \" << this_thread::get_id() << endl;\n});\nthread t2([](){\n  n += 20;\n  cout << \"t2, \" << n;\n  // 只会被调用一次\n  call_once(flag, []{ cout << \"Hello, once\" << endl; });\n  cout << \"t2, \" << this_thread::get_id() << endl;\n});\n\nt1.join();\nt2.join();\n// 异步执行代码块返回future\nauto f = async([](){cout << \"async\" << endl;});\nf.wait();\n```\n\n## 模板\n\n### 函数模板\n\n允许编写与类型无关的函数。可以使用模板参数来指定函数中的参数和返回值类型。编译器会在使用函数模板时根据传递的参数推导出具体的类型，并生成对应的函数\n\n```cpp\ntemplate <typename T>\nT add(T a, T b) {\n    return a + b;\n}\n```\n\n### 类模板\n\n允许定义一个通用的类，类似于函数模板，但它是针对类的。可以定义一个类，其中的成员变量、成员函数的类型可以通过模板参数来指定\n\n```cpp\ntemplate <typename T>\nclass Box {\nprivate:\n    T value;\npublic:\n    Box(T val) : value(val) {}\n    void setValue(T val) { value = val; }\n    T getValue() const { return value; }\n};\n\n// 使用\nBox<int> intBox(10);\n```\n\n### 元编程\n\n使用模板机制在编译期进行计算和逻辑操作，而不是在运行时执行\n\n```cpp\ntemplate<int N>\nstruct Factorial {\n    static const int value = N * Factorial<N - 1>::value;\n};\n\ntemplate<>\nstruct Factorial<0> {\n    static const int value = 1;\n};\n\n// 直接编译为常量 120\nstd::cout << Factorial<5>::value;\n```\n","metadata":"tags: ['编程语言']","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2024-08-08T20:04:56+08:00","author":"MY","message":"✏C++","hash":"15ac8557095b73cc4c1249f4df25914bec5bad0d"},{"date":"2024-08-07T19:57:53+08:00","author":"MY","message":"✏C++","hash":"fc3f4dde42fa5f5be70b6c6ebdfb98626b74e2e3"},{"date":"2024-03-29T17:20:15+08:00","author":"MY","message":"✏C++","hash":"a0c8ed721bc945b4ed9c5336ed7d5261c749ce61"},{"date":"2024-03-28T19:39:33+08:00","author":"MY","message":"✏C++","hash":"12206fb815f3789ac1fe29b0024c846d0ddbfc9d"},{"date":"2024-03-27T19:50:55+08:00","author":"MY","message":"✏C++","hash":"abc80273139818d97e678d2d4ad32eefbcaa0b5b"},{"date":"2024-03-26T20:10:06+08:00","author":"MY","message":"✏C++","hash":"5e2d35025cf9aea1218a0f7dc5e4561a94819e9e"},{"date":"2024-03-25T19:59:07+08:00","author":"MY","message":"➕C++","hash":"c89bf396ce9be454801cdfc07a35425d3e44a414"}],"createTime":"2024-03-25T19:59:07+08:00"}