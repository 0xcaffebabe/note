{"name":"C","id":"编程语言-C","content":"# C语言\n\nC 语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。\n\nC 语言是一种广泛使用的计算机语言，它与 Java 编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。\n\n当前最新的C语言标准为 C11 ，在它之前的C语言标准为 C99\n\n## 类型运算符与表达式\n\n### 变量\n\n> 变量名的开头必须是字母或下划线，不能是数字\n\n> 变量名中的字母是区分大小写的\n\n> 变量名绝对不可以是C语言关键字\n\n> 变量名中不能有空格\n\nC语法形式|数据存放位置|说明\n-|-|-\nint x=10;static int y =10;|.data|初始化的全局变量或静态变量\nvoid foo(){int x=10;}|寄存器、栈|局部变量\nregister int x =10;|寄存器、栈|被register关键字修饰的变量\ncalloc(256);|堆|申请的堆内存\nint x =0;static int y;|.bss|初始值为0的全局或静态变量\nfoo(\"Hello,Geektime!\");|.rodata|内联的长字符串\nfoo(100);|.text|内联的数字值\n\n### 数据类型及长度\n\n类型             | 存储大小  | 值范围\n-------------- | ----- | -------------------------------------------\nchar           | 1字节   | -128到127或0到255\nunsigned char  | 1字节   | 0到255\nsigned char    | 1字节   | -128到127\nint            | 2或4字节 | -32,768到32,767或-2,147,483,648到2,147,483,647，取决于平台架构\nunsigned int   | 2或4字节 | 0到65,535或0到4,294,967,295\nshort          | 2字节   | -32,768到32,767\nunsigned short | 2字节   | 0到65,535\nlong           | 4字节   | -2,147 ,483,648到2,147,483,647\nunsigned long  | 4字节   | 0到4,294,967,295\n\n在 C 语言中，整型变量本身还需区分它们的“符号性（signedness）”，符号性上的区别有利于程序对某些特定的场景需求进行优化\n\n### 常量\n\n1. 字符常量：用单引号括起来的单个字符，是一种整型常量\n2. 常量表达式：在编译时就能被完全计算的表达式，包括基本的算术表达式、逻辑表达式等\n3. 枚举常量\n\n使用 const 关键字修饰的变量定义语句，无法在后续的程序中修改其对应或指针指向的值。因此，我们更倾向于称它们为只读变量\n\n在 C 语言中，像是数组长度定义、switch，都只能使用常量表达式，而不能使用只读变量\n\n### 声明\n\n### 算术运算符\n\n名称          | 运算符号 | 举例\n----------- | ---- | ------------\n加法运算符       | +    | 2+10=12\n减法运算符       | -    | 10-3=7\n乘法运算符       | *    | 2*10=20\n除法运算符       | /    | 30/10=3\n求余运算符(模运算符) | %    | 23%7=2\n自增运算符       | ++   | int a =1;a++\n自减运算符       | --   | int a =1;a--\n\n### 关系运算符与逻辑运算符\n\n符号   | 意义   | 举例     | 结果\n---- | ---- | ------ | --\n`>`  | 大于   | 10>5   | 1\n`>=` | 大于等于 | 10>=10 | 1\n`<`  | 小于   | 10<5   | 0\n`<=` | 小于等于 | 10<=10 | 1\n==   | 等于   | 10==5  | 0\n!=   | 不等于  | 10!=5  | 1\n\n符号 | 意义  | 举例   | 结果\n-- | --- | ---- | ---\n&& | 逻辑与 | 0&&1 | 0\n`  || `    | 逻辑或 | 0` || `1 | 1\n!  | 逻辑非 | !0   | 1\n\n#### 类型转换\n\n- 自动转换\n- 强制转换\n\n## 函数与程序结构\n\n### 函数的基本知识\n\n- 函数的定义形式\n\n```c\n返回值类型 函数名（参数声明表）{\n    声明和语句\n}\n```\n\n### 函数调用\n\n当一个函数被调用时，传递给它的实际参数应该按照怎样的顺序进行求值，这在 C 标准中并没有被明确规定,当运行使用不同编译器编译得到的二进制可执行文件时，可能会得到不同的计算结果\n\n```c\nint n = 1; \nprintf(\"%d %d %d\", n++, n++, n++);\n```\n\n### 外部变量\n\n### 作用域规则\n\n### 头文件\n\n### 静态变量\n\n```c\nstatic int a;\n```\n\n### 寄存器变量\n\n```c\nregister int x;\n```\n\nregister变量将放在机器的寄存器中\n\n### 程序块结构\n\n### 初始化\n\n外部变量和静态变量都将被初始化为0\n\n### 递归\n\n### C预处理器\n\n- 文件包含\n\n  ```c\n  #include \"文件名\"\n  #include <文件名>\n  ```\n\n- 宏替换\n\n  ```c\n  #define a b\n  ```\n\n  不会替换字符串中的内容\n\n  - 带参数的宏\n  - `#undef`\n  - 双井号嵌套\n\n- 条件包含\n  ```c\n  #ifndef HDR\n  #define HDR\n  #endif\n  ```\n\n### 可变参数\n\n```c\n#include <stdio.h>\n#include <stdarg.h>\nvoid print_sum(int count, ...) {\n  int sum = 0;\n  va_list ap;\n  va_start(ap, count); \n  for (int i = 0; i < count; ++i)\n    sum += va_arg(ap, int);\n  va_end(ap);\n  printf(\"%d\\n\", sum);\n}\nint main(void) {\n  print_sum(4, 1, 2, 3, 4);\n  return 0;\n}\n```\n\n可变参数是通过编译器在编译时，将参数的值拷贝到栈内存中，并通过 va_list 结构体来对这块栈内存进行访问\n\n### 入口函数\n\n在 main 函数之前，还有一个符号名为 _start 的入口，在类 unix 系统中，_start 函数会初始化栈帧、准备 main 函数调用所需的参数\n\n## 流程控制\n\n### goto\n\ngoto 是通过汇编指令 jmp 实现的，这种方式下的执行流程转移仅能够发生在当前程序运行所在的某个具体函数中。相对地，程序无法做到从某个函数体的执行中途，直接将其执行流转移到其他函数的内部，称之为本地跳转\n\n```c\nL1:\nif (n == 1) goto L1;\n```\n\n```nasm\n.L2:\n  cmp     DWORD PTR [rbp-4], 1\n  jne     .L3\n  jmp     .L2\n```\n\n对应的有非本地跳转，其可以在一个函数内部跳转到另外一个函数内部去，非本地跳转的原理是通过保存恢复函数的调用上下文来实现的\n\n## 指针\n\n### 指针与地址\n\n```c\np = &c; // p为指向c的指针\ny = *p; // 现在y的值的c的值\n```\n\n取地址符是通过汇编指令 lea 来实现的，而从指针中读取数据，是通过 mov 命令来实现的。\n\n```nasm\nlea     rax, [rbp-16]\nmov     QWORD PTR [rbp-8], rax\n\nmov     rax, QWORD PTR [rbp-8]\nmov     eax, DWORD PTR [rax]\nmov     DWORD PTR [rbp-12], eax\n```\n\n### 指针与函数参数\n\n```c\nvoid swap(int *x,int *y){\n    int tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n```\n\n### 指针与数组\n\n数组本质也是一个指针\n\n但是指针是一个变量，数组名不是一个变量\n\n### 地址算术运算\n\n当对指针进行加法、减法、递增、递减运算时，编译器实际上是以当前指针所指向值对应的某个固定长度为单位，对指针中存放的地址值进行相应调整的\n\n- 相同类型指针之间的赋值运算\n- 同整数间的加减法运算\n- 指向相同数组的两个指针减法或比较运算\n- 将指针赋值为0\n\n### 字符串与指针\n```c\nvoid reverse(char *s,int n){\n    if (n<0){\n        return;\n    }\n    putchar(*(s+n));\n    reverse(s,--n);\n}\n```\n\n### 指针数组以及指向指针的指针\n\n```c\nchar *sa[20];\n```\n\n```c\nint main(){\n    int x;\n    int *xp = &x;\n    int **xpp = &xp;\n\n    **xpp=15;\n    printf(\"%d\",x);\n}\n```\n\n### 多维数组\n```c\nint a[i][j];\n```\n\n### 指针数组的初始化\n\n### 指针与多维数组\n\n```c\nchar *s[]={\"123\",\"321\",\"1111\"};\n```\n\n### 命令行参数\n\n```c\nint main(int argc,char *s[]){return 0;}\n```\n\n### 指向函数的指针\n\n```c\nint fun(int a) {\n  return a+6;\n}\nvoid fun1(int (*f)(int)) {\n  printf(\"%d \\n\", (*f)(48))\n}\nint main(int args, char *args[]) {\n  fun1(&fun);\n  return 0;\n}\n```\n\n### 复杂声明\n\n## 结构\n\n### 基本知识\n\n```c\nstruct{\n    int x;\n    int y;\n} point;\n\nstruct poinit p;\np.x=1;\n```\n\n### 结构与函数\n\n- 结构指针\n\n  ```c\n  struct point *pp;\n  (*pp).x=5;\n  y = pp->x;\n  ```\n\n### 结构数组\n\n```c\nstruct poinit ps[20];\n```\n\n### 结构指针\n\n为了内存读取效率，成员字段在栈内存中都满足自然对齐的要求，编译器会插入额外的“填充字节”，来动态调整结构对象中各个字段对应数据的起始位置\n\n```c\nstruct Foo {\n  char *p;  // 8 bytes.\n  char c;  // 1 bytes.\n  // (padding): 7 bytes.\n};\n```\n\n\n\n### 自引用结构\n\n```c\nstruct{\n    int x;\n    int y;\n    struct point *p;\n} poinit;\n```\n\n### 表查找\n\n### 类型定义\n\n```c\ntypedef char* String\nString s = \"123\";\n```\n\n### 联合\n\n```c\nunion ut{\n    char a;\n    int b;\n    long c;\n}u;\n\nu.c=1L;\nu.b=2;\n```\n\n在该结构内的所有数据字段，都将会联合起来共享同一块内存区域\n\n```nasm\nmov     QWORD PTR [rbp-8], 1\nmov     DWORD PTR [rbp-8], 2\n```\n\n### 位字段\n\n## 字符串\n\n```c\nchar strA[] = \"Hello!\";  \nchar* strB = \"Hello!\";\nstrA[1] = 'c'; // normal\nstrB[1] = 'c'; // Segmentation fault\n```\n\n使用数组和指针形式定义的字符串，其底层的数据引用方式会有所区别。其中数组方式会将字符串数据从 .rodata 中拷贝到其他位置（比如栈内存），因此修改这些数据不会改变存在于原始 .rodata 中的副本。而使用常量指针形式定义的数组，该指针会直接引用位于 .rodata 中的字符串数据\n\n## 多线程\n\n```c\n// C11 引入的标准库\n#include <threads.h>\n#include <stdio.h>\nint run(void *arg) {\n  thrd_t id = thrd_current();  // 返回该函数运行所在线程的标识符；\n  printf((const char*) arg, id);\n  return thrd_success;\n}\nint main(void) {\n  thrd_t thread;\n  int result;\n  // 创建一个线程；\n  thrd_create(&thread, run, \"Hello C11 thread with id: %lu.\\n\");\n  if (thrd_join(thread, &result) == thrd_success) {\n    // 等待其他线程退出；\n    printf(\"Thread returns %d at the end.\\n\", result);  \n  }  \n  return 0;\n}\n```\n\n### 原子操作\n\n- C11 提供的名为 stdatomic.h 的头文件\n\n```c\n_Atomic long counter = 0;  // 定义一个原子类型全局变量，用来记录线程的累加值；\n\natomic_fetch_add_explicit(&counter, 1, memory_order_relaxed);  // 使用原子加法操作；\n```\n\n函数名|功能描述\n-|-\natomic_flag_test_and_set|将一个atomic_flag的值置为真，并返回旧值\natomic_flag_clear|将一个atomic_flag的值设为假\natomic_init|初始化一个已经存在的原子对象\natomic is lock free|检测指定对象是否是lock-free的\natomic_exchange|原子地交换两个值\natomic_compare_exchange_weak|比较并原子地交换两个值（允许伪失败）\natomic_compare_exchange_strong|比较并原子地交换两个值\natomic_signal_fence|在线程和信号处理程序之间建立内存栅栏\natomic_thread_fence|在线程之间建立内存栅栏\n\n### 条件变量\n\n```c\ncnd_t cond;  // 定义一个条件变量；\nint done = 0;\n\n// 等待\nmtx_lock(&mutex); \nwhile (done == 0) {\n  cnd_wait(&cond, &mutex);  // 让当前线程进入等待队列；\n}\nmtx_unlock(&mutex);\n\n// 通知\nmtx_lock(&mutex); \ndone = 1;\ncnd_signal(&cond);  // 通知等待中的线程；\nmtx_unlock(&mutex); \n```\n\n### 线程本地变量\n\n```c\n_Thread_local int counter = 0;\n```\n\n\n## 输入与输出\n\n### 标准输入输出\n\n- getchar\n- putchar\n\n### 格式化输出-printf\n\n字符   | 参数类型;输出形式\n---- | ------------------------------------------------------------\nd,i  | int类型;十进制数\no    | int类型;无符号八进制数(没有前导0 )\nx, X | int类型;无符号十六进制数(没有前导0x或0X ), 10~15分别用abcdef或ABCDEF表示\nu    | int类型;无符号十进制数\nc    | int类型;单个字符\ns    | char *类型;顺序打印字符串中的字符，直到遇到'\\0'或已打印了由精度指定的字符数为止\nf    | double类型;十进制小数[- ] mdddddd,其中d的个数由精度指定(默认值为6 )\ne, E | double类型; [-]mdddd e +xx或[ - ]mddddd E土比，其中d的个数由精度指定(默认值为6 )\ng，G  | double类型;如果指数小于-4或大于等于精度，则用各e或8E格式输出，否则用8f格式输出。尾部的0和小数点不打印\nP    | void *类型;指针(取决于具体实现)\n%    | 不转换参数;打印一个百分号%\n\n### 变长参数表\n\n```c\nvoid pr(int a,...){\n  va_ list ap;\n  int i;\n  va_ start(ap,a);\n  \n  for(i=0;i<5;i++){\n    printf( \"%d\" ,va_ arg(ap,int));\n  }\n  va_ end(ap);\n}\nint main(int argc,char *args[]){\n  pr(1,2,3,4,5,6);\n}\n\n```\n\n### 格式化输入-scanf\n\n转换字符指定对输人字段的解释。对应的参数必须是指针，这也是C语言通过值调用语义所要求的\n\n字符 | 输人数据;参数类型\n-- | -----------------------------------------------------------------------------\nd  | 十进制整数; int*类型\ni  | 整数; int*类型，可以是八进制(以0开头)或十六进制(以0x或0x开头)\no  | 八进制整数(可以以0开头，也可以不以0开头) ; int *类型\nu  | 无符号十进制整数; unsigned int* 类型\nx  | 十六进制整数(可以0x或0X开头，也可以不以0x或0X开头) ; int *类型\nC  | 字符; char *类型， 将接下来的多个输人字符(默认为1个字符)存放到指定位置。该转换规范通常不跳过空白符。如果需要读人下一个非空白符，可以使用%1s\n\n### 文件访问\n\n```c\nint main(int argc,char *args[]){\n  FILE *fp;\n  FILE *fp1;\n  char c;\n  fp = fopen(\" . /reverse1.c\" ,\"aw\");\n  fp1 = fopen(\"./reverse.c\",\"r\") ;\n  while((c=fgetc(fp1)) != EOF){\n    fputc(c,fp);\n  }\n  fputs(\"test\",fp);\n  fclose(fp);\n  fclose(fp1);\n}\n```\n\n### 错误处理\n\n- stdout\n- stderr\n\n### 行输入和行输出\n\n- fgets\n- fputs\n\n### 其他函数\n\n## UNIX系统接口\n\n### 文件描述符\n\n>内核（kernel）利用文件描述符（file descriptor）来访问文件。 文件描述符是非负整数。 打开现存文件或新建文件时，内核会返回一个文件描述符。 读写文件也需要使用文件描述符来指定待读写的文件。\n\n### 低级IO-read/write\n\n标准的 IO 一般会使用所在平台的低级 IO 接口来实现。而低级 IO 则通过调用操作系统内核提供的系统调用函数，来完成相应的 IO 操作\n\n在 x86-64 平台上，系统调用通过 syscall 指令来执行。而在基于该平台的 Unix 与类 Unix 系统上，系统调用函数的执行会使用寄存器 rdi、rsi、rdx、r10、r8、r9 来进行参数的传递，rax 寄存器则用于传递系统调用 ID，以及接收系统调用的返回值\n\n```nasm\n; SYS_getpid 调用\n.global __syscall\n.type __syscall,@function\n__syscall:\n  movq %rdi, %rax\n  movq %rsi, %rdi\n  movq %rdx, %rsi\n  movq %rcx, %rdx\n  movq %r8, %r10\n  movq %r9, %r8\n  movq 8(%rsp), %r9\n  syscall\n  ret\n```\n\n另外一种调用方式是通过软中断：\n\n```nasm\nextern sub\nglobal _start\nsection .text\n_start:\n  and   rsp,0xfffffffffffffff0\n  sub   rsp, 3\n  mov   esi, 2\n  mov   edi, 1\n  call  sub\n  # use \"int\" to invoke a system call.\n  mov   ebx, eax  \n  mov   eax, 1\n  int   0x80\n```\n\n在进行系统调用时，发生了特权级别的转换，为了通过隔离执行环境来保证内核安全，CPU 在进入内核态前，通常还会进行栈的切换，内核态使用的调用栈跟用户态使用的栈是不一样的。\n\n### open creat close unlink\n\n### 随机访问-lseek\n\n### 信号处理\n\n```c\nvoid sigHandler(int sig) {\n  printf(\"Signal %d catched!\\n\", sig);\n  exit(sig);\n}\n\nsignal(SIGFPE, sigHandler);\n```\n\n## 性能优化\n\n### 局部性原理利用高速缓存\n\n### 函数内联避免调用开销\n\n通过 inline 关键字建议编译器执行内联优化\n\n### restrict\n\n通过在指针变量上添加 restrict 关键字，可以告知编译器这个指针是唯一的访问数据，编译器就能做一些针对性的优化\n\n1. 消除多余的内存访问\n2. ...\n\n### 消除不必要的内存访问\n\n正常情况下，内存访问慢于寄存器访问，一种优化手段是可以给局部变量添加 register 关键字，这样变量访问就快了许多\n\n### 使用条件传送指令而非条件分支指令\n\n条件分支指令可能会受到 CPU 分支预测错误带来的惩罚\n\n条件传送指令一般会用于实现 C 语法中的三元运算符 ?:\n\n### 更高的编译优化等级\n\n优化标记|优化内容\n-|-\n-O0|编译器采用的默认优化选项，编译耗时最短\nO1|编译器会尝试减小代码体积，并优化程序运行效率，但不会进行需要大量时间的编译优化。相较于-O0，该选项将耗费更多的编译时间和内存\nO2|编译器会在-O1的基础上做进一步的代码优化，GCC将应用几乎所有支持的、非空间换时间类的编译优化。相较于-O1,该选项将耗费更多的编译时间和内存\nO3|编译器会在-O2的基础上做进一步的代码优化\nOs|编译器将在-0O2的基础上，更侧重于优化生成二进制文件的体积\nOfast|编译器会在-O3的基础上，再应用可能会违反C标准的更多优化策略\nOg|编译器将侧重优化程序的调试体验，该选项可以在保持快速编译和良好调试体验的同时，为代码应用合理的优化级别。对于需要支持调试的代码来说，它是比-O0更好的选择\n\n## ABI\n\n应用程序二进制接口（Application Binary Interface），ABI 将程序与操作系统、硬件平台之间紧密协作需要遵守的特定规则暴露了出来。这些规则指定了基于这个体系运行的二进制应用程序，应该如何在机器代码层面进行数据访问或函数调用等一系列操作\n\nABI 规范：\n\n- 函数调用规范\n- 处理器可以访问的数据类型其大小与对齐方式\n- 进程初始化细节（如栈和寄存器的状态变化）\n- 对象文件（如 .o）的基本结构\n- 程序载入和动态链接的细节\n- ……","metadata":"tags: ['编程语言']","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2024-04-23T19:55:20+08:00","author":"MY","message":"✏C","hash":"eea88b9ed672a6731bd54fc3df955adf6af00720"},{"date":"2024-04-19T19:39:23+08:00","author":"MY","message":"✏C","hash":"3e9ed31a4c6569892778cc5784ced472a085f8c8"},{"date":"2024-04-18T19:57:58+08:00","author":"MY","message":"✏C","hash":"768831c0911695fdad43e9f2c7a309a84681ce36"},{"date":"2024-04-17T19:46:39+08:00","author":"MY","message":"✏C","hash":"3aaa22140b04b80f2b53fa1aa8a6808c52ba3367"},{"date":"2024-04-16T19:27:15+08:00","author":"MY","message":"✏C","hash":"99952a8ec19fca0df0f83df82488445c09f39e33"},{"date":"2023-03-13T16:51:56+08:00","author":"MY","message":"✏C","hash":"e3305aeec2c375e6b51acdc4c72f2009b936846d"},{"date":"2022-04-19T11:08:17+08:00","author":"cjiping","message":"📦整理 C","hash":"c06812ee91532ec1d6e2118561bf33985a5eb900"}],"createTime":"2022-04-19T11:08:17+08:00"}