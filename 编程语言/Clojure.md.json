{"name":"Clojure","id":"编程语言-Clojure","content":"# Clojure\n\n- JVM Lisp方言\n\n## 基本运算与函数调用\n\n```clojure\n(println (- 1))\n(println (+ 1 1))\n(println (+ 1 1 1)) ; 使用一个运算符运算\n(println (+ 3.0 5)) ; 自动类型转换\n(println (= 1 1 1)) \n(println (* 10 10))\n(println (/ 6 3))\n(println (class (/ 6 3)))\n```\n\n## 字符与字符串\n\n```clojure\n(println \\a) ;; 字符\n(println (str 1 2 \\a)) ;; 转为字符串\n```\n\n## 布尔值与表达式\n\n```clojure\n(println (= 1 1))\n(if (= 1 1) (println \"hello world\"))\n```\n\n0 和 \"\" 都代表true\n\n## 数据结构\n\n- 列表\n\nClojure 列表是代码\n\n```clojure\n;(println (1,2,3)) ; 错误\n(println (list 1 2 3)) ; 生成一个列表\n; 列表操作\n(println (first (list 1 2 3)))\n(println (last (list 1 2 3)))\n(println (rest (list 1 2 3))) ; 除头元素\n```\n\n- 向量\n\n```clojure\n(println [1 2 3])\n(println (first [1 2 3]))\n(println (nth [1 2 3] 2))\n(println (last [1 2 3]))\n(println ([1 2 3] 2)) ; 向量也是一个函数 可以执行参数为2\n```\n\n- 集合\n\n```clojure\n(println #{1 2 3})\n(def s #{1 2 3}) ; 集合赋值\n(println (count s))\n(println (sort s))\n(println (sorted-set 3 1 2)) ; 创建一个有序集合\n(println s 2) ; 判断元素是否在集合中\n```\n\n- 映射表\n\n```clojure\n(def suffix {\"js\" \"javascript\", \"py\" \"python\", \"java\" \"java\"})\n(println (suffix \"js\"))\n(println (merge {\"js\" 1, \"java\" 1} { \"py\" 1, \"java\" 1})) ; 合并 重复直接覆盖\n(println (merge-with + {\"js\" 1, \"java\" 1} { \"py\" 1, \"java\" 1})) ; 合并 提供一个操作当重复时执行该操作\n(println (assoc {\"js\" 1} \"java\" 1)) ; 增加KV\n```\n\n## 函数定义\n\n```clojure\n(defn say [] (println \"hello world\")) ; 定义\n(say)\n```\n\n## 解构\n\n```clojure\n(defn center [[_ c _]] c)\n(println (center [1,2,3])) ; 2\n\n(println (let [[_ c _] [1 2 3]] c)) ;2\n```\n\n## 匿名函数\n\n```clojure\n; apply\n(defn kiss [man] (println \"kiss\" man))\n(apply kiss '(\"people\")) ; 调用指定函数使用指定参数\n\n; filter\n(defn gt2 [i] (> i 2))\n(println (filter gt2 [1 2 3])) ; 使用指定函数过滤元素\n```\n\n## 递归\n\n- 使用传统方式\n\n```clojure\n(defn size [v]\n  (if (empty? v)\n    0\n    (inc (size (rest v))))\n)\n(println (size [1 2 3])) \n```\n\n- 使用loop和recur\n\n```clojure\n(defn size1 [v]\n  (loop [l v, c 0]\n    (if (empty? l)\n      c\n      (recur (rest l) (inc c))\n    )\n  )\n)\n(println (size1 [1 2 3]))\n```\n\n## 序列\n\n一个与具体实现无关的抽象层\n\n```clojure\n; 测试\n(println (some nil? [1 2 3]))\n(println (every? number? [1 2 3]))\n\n; 修改\n(println (map (fn [x] (* x x)) [1 2 3 4]))\n(println (filter (fn [x] (> x 2)) [1 2 3 4]))\n\n; 列表解析\n(def people [\"蔡徐坤\" \"徐雪莉\" \"张无忌\"])\n(def object [\"篮球\" \"蛋糕\" \"游戏\"])\n(println (for [x people, y object] (str x \"喜欢\" y)))\n; 列表解析过滤\n(println (for [x people, y object, :when(= y \"篮球\")] (str x \"喜欢\" y)))\n\n; reduce\n(println (reduce + [1 2 3 4]))\n(println (reduce * [1 2 3 4]))\n\n; 排序\n(\n  println \n  (\n    sort-by (fn [x] (if (< x 0) (- x) x))\n    [-1 2 3 -2 -6 -7]\n  )\n)\n```\n\n## 延迟计算\n\n- 有穷序列\n\n```clojure\n(println (range 1 10)) ; [1,10)\n(println (range 10)) ; [0,10)\n```\n\n- 无穷序列\n\n```clojure\n(println (take 3 (repeat 100))) ; 从无限重复100的序列取出3个\n(println (take 5 (cycle [\"徐工\" \"张无忌\" \"低修\"]))) ; 从这个列表的无限循环取5个\n(println (take 5 (interpose \"和\" (cycle [\"徐工\" \"张无忌\" \"低修\"])))) ; 元素之间加入分隔符\n(defn sum [x] (+ x 1))\n(println (take 100 (iterate sum 0))) ; 使用自定义函数\n```\n\n## 协议\n\n- defrecord和protocol\n\n## 宏\n\n```clojure\n(defmacro unless [test body]\n  (list 'if(list 'not test) body)\n) ; 定义宏\n\n(unless (= 1 2) (println \"done\"))\n```\n\n## 并发\n\n### 引用与事务\n\n```clojure\n; 引用\n(def name (ref \"cxk\")) ; 定义\n(println @name) ; 使用\n(dosync (ref-set name \"jntm\")) ; 只能在事务(dosync)里面修改\n(println @name)\n```\n\n### 原子\n\n```clojure\n(def person (atom \"电影人\")) ; 定义\n(println person)\n(reset! person \"打工人\") ; 设置新原子\n(println person)\n```\n\n### 代理\n\n```clojure\n(defn calc [x] (* 2 2))\n(def proxy (agent 1))\n(send proxy calc) ; 让代理去调用函数\n(println @proxy) ; 这里读取会很快返回 即使calc函数阻塞\n```\n\n### future\n\n```clojure\n; future 基本跟代理一样\n(def result (future (Thread/sleep 1000) \"got it\"))\n(println @result) ; 只有结果返回才能获取 否则就阻塞住了\n```\n\n## 核心优势\n\n- 括号相比其他Lisp方言少\n- 庞大的Java生态系统支持\n- 限制了宏的部分能力\n- 并发\n- 延迟计算\n- 列表即代码\n\n## 不足\n\n- 语法\n  - 前缀表达式\n  - 括号带来的可读性问题\n- 学习曲线陡\n- 在JVM上 受到了一些限制\n","metadata":"","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2020-11-25T11:14:54+08:00","author":"cjiping","message":"✏更新 Clojure","hash":"8ae780b8ed807c0ac87031e8c7b4233be7bbef4a"},{"date":"2020-11-23T10:26:30+08:00","author":"MY","message":"✏更新 Clojure","hash":"a94769964c9eaeb40f6c519ec50f57ca31676835"},{"date":"2020-11-20T11:52:54+08:00","author":"MY","message":"➕增加 Clojure","hash":"5e2f37d3e03e4a38abf7dd3f213bc416d2186c20"}],"createTime":"2020-11-20T11:52:54+08:00"}