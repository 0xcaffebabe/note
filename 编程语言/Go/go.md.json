{"name":"go","id":"编程语言-Go-go","content":"# go\n\n- 静态类型、编译型\n- 支持两种范式\n- 特点\n  - 原生并发支持\n\n## 概念\n\n### package\n\n- 基本的分发单位、依赖关系的体现\n- 每个源码文件都必须声明package\n- 要生成可执行程序，必须要有main的package，并且还需要有main函数\n- 同一个路径下只能存在一个package\n\n### 源码文件\n\n- 命令源码文件、库源码文件\n- 测试源码文件\n\n## 命令行工具\n\n- go build 编译\n- go run 编译并运行\n- go get获取远程代码包\n\n## 语法\n\n- 注释\n\n```go\n// single row\n/*\nmulti row\n*/\n```\n\n- 基础结构\n\n```go\npackage main // 程序所属包\nimport \"fmt\" // 导入依赖包\nconst NAME = \"cxk\" // 常量定义\ntype myInt int // 一般类型声明\n// 结构体声明\ntype user struct { }\n// 接口声明\ntype UserService interface { }\n// 入口函数\nfunc main(){\n  var a = \"cxk\"\n  fmt.Println(a+NAME)\n}\n```\n\n### import\n\n- 不能导入源码中没有使用的package\n\n```go\n// 另外一种语法\nimport ( \n  \"fmt\"\n  \"time\"\n)\n```\n\n#### 原理\n\n- 如果一个main导入其他包,包将被顺序导入;\n- 如果导入的包中依赖其它包(包B) ,会首先导入B包,然后初始化B包中常量和变量,最后如果B包中有init ,会自动执行init() ;\n- 所有包导入完成后才会对main中常量和变量进行初始化,然后执行main中的init函数(如果存在) , 最后执行main函数;\n- 如果一个包被导入多次则该包只会被导入一次;\n\n![批注 2020-04-14 155821](/assets/批注%202020-04-14%20155821.png)\n\n#### 别名\n\n- 别名操作的含义是:将导入的包命名为另- -个容易记忆的别名;\n\n```go\nimport pk \"awesomeProject/pkg1\"\n\npk.F()\n```\n\n- 点(.)操作的含义是:点(.)标识的包导入后,调用该包中函数时可以省略前缀包名;\n\n```go\nimport . \"awesomeProject/pkg1\"\n\nF()\n```\n\n- 下划线(_ )操作的含义是:导入该包,但不导入整个包,而是执行该包中的init函数,因此无法通过包名来调用包中的其他函数。使用下划线(_ ) 操作往往是为了注册包里的引擎,让外部可以方便地使用;\n\n```go\nimport _ \"awesomeProject/pkg1\"\n```\n\n### 数据类型\n\n- 数值类型,字符串类型和布尔型;\n- 派生类型;\n\n```go\nvar i uint32 = 2\nfmt.Println(unsafe.Sizeof(i)) // 4\nvar i1 int = 2\nfmt.Println(unsafe.Sizeof(i1)) // 8\nvar i2 float32 = 1.0\nfmt.Println(unsafe.Sizeof(i2)) // 4\nvar i3 bool = true\nfmt.Println(unsafe.Sizeof(i3)) // 1\nvar i4 byte = 1\nfmt.Println(unsafe.Sizeof(i4)) // 1\n```\n\n![批注 2020-04-14 190812](/assets/批注%202020-04-14%20190812.png)\n\n## 变量\n\n- 变量的声明格式: var <变量名称> [变量类型]\n- 变量的赋值格式: <变量名称> = <值 ,表达式,函数等>\n- 声明和赋值同时进行: var <变量名称> [变量类型]= <值 ,表达式，函数等>\n- 分组声明格式:\n\n```go\nvar(\ni int\nj float32\nname string\n)\n```\n\n- 同一行声明多个变量和赋值\n\n```go\nvar a, b, c int = 1,2,3\n// 或者\nvar a,b,c = 1,2,3\n// 省略var\na,b,c := 1,2,3\n```\n\n- 全局变量的声明必须使用var关键词，局部变量则可以省略\n\n```go\nvar a=1\nfunc main(){\n\tb:=2\n\tfmt.Println(a,b)\n}\n```\n\n- 特殊变量下划线 ”_”\n\n```go\nvar _ = 2\n// 无法使用_\n```\n\n- Go中不存在隐式转换,类型转换必须是显式的;\n\n```go\nvar a =1\nvar b  = float32(a)\n```\n\n- 类型转换只能发生在两种兼容类型之间;\n\n- 大写字母开头的变量是可导出的,也就是其它包可以读取的,是公用变量;\n- 小写字母开头的就是不可导出的,是私有变量。\n\n```go\n// pkg1\nfunc F1(){}\n\nfunc f1(){}\n\n// main\nfunc main(){\n\tpkg1.F1()\n\t//pkg1.f1() 无法访问\n}\n```\n\n## 常量\n\n显式: const identifier [type] = value\n隐式: const identifier = value ( 通常叫无类型常量)\n\n```go\nconst name = \"cxk\"\nconst age int = 18\nconst (\n\thabbit1 = \"sing\"\n\thabbit2 = \"rap\"\n)\n```\n\n常量可以使用内置表达式定义,例如: len()，unsafe.Sizeof()等 ;\n常量范围目前只支持布尔型、数字型(整数型、浮点型和复数)和字符串型;\n\n### 特殊常量iota\n\n- iota在const关键字出现时将被重置为0\n- const中每新增一行常量 声明将使iota计数自增1次\n\n```go\nconst a = iota\nconst b = iota\n\nconst (\n\tc = iota\n\td = iota\n)\nfunc main(){\n\tfmt.Println(a,b) // 0 0\n\tfmt.Println(c,d) // 0 1\n}\n```\n\n- iota常见使用法:\n\n\n1)跳值使用法;\n\n```go\nconst (\n\tc = iota\n\t_ = iota\n\td = iota\n)\nfunc main(){\n\tfmt.Println(c,d) // 0 2\n}\n```\n\n2)插队使用法;\n\n```go\nconst (\n\tc = iota\n\td = 3\n\te = iota\n)\nfunc main(){\n\tfmt.Println(c,d,e) // 0 3 2\n}\n```\n\n3 )表达式隐式使用法;\n\n```go\nconst (\n\tc = iota *2\n\td // 没有指定值，默认会继承之前的表达式\n\te\n)\nfunc main(){\n\tfmt.Println(c,d,e) // 0 2 4\n}\n```\n\n4)单行使用法;\n\n```go\nconst (\n\ta ,b = iota,iota+3\n\tc,d\n)\nfunc main(){\n\tfmt.Println(a,b,c,d) // 0 3 1 4\n}\n```\n\n## 运算符\n\n```go\na := 1\nb := 2\na++ // ++运算符只能这样用\nprintln(a)\nb-- // --运算符只能这样用\nprintln(b)\n```\n\n## 控制语句\n\n- 条件控制\n\n```go\na := 0\nif a>=1 {\n\tprintln(\"true\")\n}else if a <= 0 {\n\tprintln(\"false\")\n}\n```\n\n- 选择语句\n\n```go\na := 10\nswitch a {\ncase 1:\n\t{\n\t\tprintln(\"1\")\n\t}\ncase 2:\n\t{\n\t\tprintln(\"2\")\n\t}\ndefault:\n\t{\n\t\tprintln(\"default\")\n\t}\n}\n```\n\n- 循环语句\n\n```go\n// 死循环\nfor {\n\tprintln(\"run\")\n\ttime.Sleep(1*time.Second)\n}\n// 经典for循环\nfor i:=1;i<10;i++ {\n\tprintln(\"run\",i)\n}\n// foreach\na := []string{\"cxk\", \"jntm\"}\nfor key, value := range a {\n\tprintln(key, value)\n}\n```\n\n- goto\n\n```go\nif true {\n\tgoto label2\n}else {\n\tgoto label1\n}\nlabel1:\n\tprintln(\"label1\")\nlabel2:\n\tprintln(\"label2\")\n```\n\n- break\n\n```go\na := []string{\"cxk\", \"jntm\"}\nfor key, value := range a {\n\tprintln(key, value)\n\tif key == 0 {\n\t\tbreak\n\t}\n}\n```\n\n## 内建方法\n\n### make\n\n```go\n// slice类似于数组\nslice := make([]string,3)\nslice[0] = \"cxk\"\nslice[1] = \"cxk2\"\nslice[2] = \"cxk3\"\nfor k,v := range slice {\n\tprintln(k,v)\n}\nprintln(\"---\")\n// map\naMap := make(map[string]string,3)\naMap[\"a\"]=\"1\"\naMap[\"b\"]=\"2\"\nfor k,v := range aMap {\n\tprintln(k,v)\n}\nprintln(\"---\")\n// channel 类似缓冲区\naChan := make(chan int,3)\nclose(aChan)\n```\n\n### new\n\n```go\n// 返回一个指针\naMap := new(map[string]string)\nfmt.Println(reflect.TypeOf(aMap)) // *map[string]string\n```\n\n### append & copy & delete\n\n```go\nslice :=make ([]string,2)\nslice[0]=\"1\"\nslice[1]=\"2\"\nslice = append(slice,\"3\")\nfmt.Println(slice) // 1 2 3\n```\n\n```go\nslice1 :=make ([]string,2)\nslice1[0]=\"1\"\nslice1[1]=\"2\"\nslice2 :=make([]string,2)\ncopy(slice2,slice1)\nfmt.Println(slice2) // 1 2\n```\n\n```go\naMap := make(map[string]string)\naMap[\"1\"]=\"a\"\naMap[\"2\"]=\"b\"\ndelete(aMap,\"1\")\nfmt.Println(aMap) // 2:b\n```\n\n### 异常\n\n```go\nfunc main() {\n\tdefer func() {\n\t\t// 异常处理\n\t\tmsg := recover()\n\t\tfmt.Println(\"msg:\",msg)\n\t}()\n\t// 抛出异常\n\tpanic(\"异常\")\n}\n```\n\n### len && cap && close\n\n```go\nslice := make([]int,3,5)\nprintln(len(slice)) // 3\nprintln(cap(slice)) // 5\n\naChan := make(chan int,1)\naChan <- 1\nclose(aChan)\n```\n\n## 结构体\n\n```go\n// 定义结构体\ntype Person struct {\n\tName string\n\tAge int\n}\nfunc main(){\n\tvar p Person // 声明结构体变量\n\tp.Age = 18 // 结构体成员赋值\n\tp1 := Person{Name: \"cxk\"} // 另外一种方式\n\tp2 := new(Person) // 返回一个Person指针\n\tp.Name = \"cxk\"\n\tfmt.Println(p)\n}\n```\n\n### 属性及函数\n\n- 两种作用域，大写开头为公开，小写开头为私有\n\n```go\n// 定义Person的一个公开成员方法\nfunc (p *Person)Say(){\n\tfmt.Println(\"person say\")\n}\n```\n\n### 组合\n\n```go\ntype Animal struct {\n\tType string\n}\ntype Dog struct {\n\tAnimal // 组合animal，Dog继承Animal的属性\n\tName string\n}\n```\n\n## 并发\n\n- 协程\n\n```go\nfunc main(){\n\tgo run()\n\tgo run()\n\ttime.Sleep(time.Second*5)\n}\nfunc run(){\n\tfor i:=1;i<10;i++ {\n\t\ttime.Sleep(time.Millisecond*2)\n\t\tprint(i)\n\t}\n\tprintln()\n}\n```\n\n- 协程通讯\n\n```go\nvar chanInt = make(chan int,10)\nfunc main(){\n\tgo send()\n\tgo receive()\n\ttime.Sleep(5*time.Second)\n}\n\nfunc send(){\n\tchanInt <- 1\n\tchanInt <- 2\n\tchanInt <- 3\n}\n\nfunc receive(){\n\tnum := <- chanInt\n\tfmt.Println(num)\n\tnum = <- chanInt\n\tfmt.Println(num)\n\tnum = <- chanInt\n\tfmt.Println(num)\n}\n```\n\n- 使用select\n\n```go\nvar chanInt = make(chan int,10)\nvar chan1 = make(chan int,10)\n\nfunc send(){\n\tfor i:=0;i<10;i++ {\n\t\tchanInt <- i\n\t\tchan1 <- i*i\n\t}\n}\n\nfunc receive(){\n\tfor {\n\t\tselect {\n\t\tcase num := <- chanInt:\n\t\t\tfmt.Println(num)\n\t\tcase num := <- chan1:\n\t\t\tfmt.Println(num)\n\t\t}\n\t}\n}\n```\n\nselect可以随机在多个channel中取数据\n\n- 同步\n\n```go\nfunc main(){\n\tmakeFood(10)\n\tgo eatFood(10)\n\twaitGroup.Wait()\n}\nvar waitGroup sync.WaitGroup\nfunc makeFood(i int){\n\tfor j:=0;j<i;j++ {\n\t\twaitGroup.Add(1)\n\t\tfmt.Println(\"make food\",j)\n\t}\n}\nfunc eatFood(i int){\n\tfor j:=0;j<i;j++ {\n\t\tfmt.Println(\"eat food\",j)\n\t\twaitGroup.Done() // countdown\n\t}\n}\n```\n\n## 指针\n\n```go\ni:=20\nvar pi *int=&i // pi指向i\nfmt.Println(*pi) // 读取pi所指向的内容\nfmt.Println(pi == nil) // 判断是否为空\n\na,b :=1,2\npa := [...]*int{&a,&b} // 指针数组(元素为指针的数组)\nfmt.Println(pa)\n\narr := [...]int{1,2,3}\nap := &arr // 数组指针（指向一个数组的指针）\nfmt.Println(ap)\n```\n\n## json\n\n- 序列化\n\n```go\nsetting := Setting{Menu:\"menu\",Count: 15}\nbyte,err:=json.Marshal(setting)\nif err!=nil {\n\tfmt.Println(err)\n}else {\n\tfmt.Println(string(byte))\n}\n```\n\n- tag\n\n```go\ntype Setting struct {\n\tMenu string `json:\"menu\"` // 指定序列后的字段名字\n\tCount int\n}\n```\n\n- 反序列化\n\n```go\nstr := \"{\\\"menu\\\":\\\"menu\\\",\\\"Count\\\":15}\\n\"\nvar setting Setting\nerr := json.Unmarshal([]byte(str),&setting)\nif err != nil {\n\tfmt.Println(err)\n}else {\n\tfmt.Println(setting)\n}\n```\n\n## module\n\n- 初始化项目\n\n```sh\ngo mod init\n```\n\n- 输出项目依赖\n\n```sh\ngo mod graph\n```","metadata":"","hasMoreCommit":true,"totalCommits":18,"commitList":[{"date":"2021-09-16T17:29:00+08:00","author":"cjiping","message":"✏更新 Go 函数方法和接口","hash":"ecf5173489120f8f712be243bdf6e5b9989b7372"},{"date":"2021-09-14T17:03:16+08:00","author":"cjiping","message":"➕新增 Go 数组字符串切片","hash":"3237de889ebcef31880a01582451069e99912742"},{"date":"2020-04-27T13:25:34+08:00","author":"MY","message":"增加 go module","hash":"e359dc972d414ff3db0b2cc948aae8892f59ada0"},{"date":"2020-04-24T14:21:37+08:00","author":"MY","message":"增加 go json","hash":"bfbcc3c4275b68bf809e1c8073c3814fa274b916"},{"date":"2020-04-23T15:58:56+08:00","author":"MY","message":"增加 go 指针","hash":"6cb54323eab417587432775921fd7f1ee190717e"},{"date":"2020-04-22T14:21:50+08:00","author":"MY","message":"增加 go 并发","hash":"aa6f78aa1768c12aae8b683d7e64d08cf66e4851"},{"date":"2020-04-21T13:50:09+08:00","author":"MY","message":"增加 go 接口","hash":"1afed3f86a2e1a69f7030da1f6a864ad2ff4347c"},{"date":"2020-04-21T13:32:57+08:00","author":"MY","message":"更新 go","hash":"3d015f55eed1cad2f06d5c9f9f37b385e4d31d69"},{"date":"2020-04-20T14:02:34+08:00","author":"MY","message":"增加 go 异常","hash":"dc6a7e1a199c099c667e71f3ae52f365cdd8a734"},{"date":"2020-04-20T13:53:16+08:00","author":"MY","message":"增加 go copy & delete & append","hash":"8224c7b30996ed4ea53cea18aafb157868e44409"}],"createTime":"2020-04-13T20:19:10+08:00"}