{"name":"内存模型","id":"编程语言-Go-内存模型","content":"# 内存模型\n\n- 面向并发\n\n## Goroutine\n\nGoroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度，且调度发生在用户态，所以Goroutine是一种比线程更加轻量的玩意\n\n## 原子操作\n\n- 锁实现\n\n```go\nvar ai struct {\n\tsync.Mutex\n\tvalue int\n}\n\nfunc main() {\n\tgo worker();\n\tgo worker();\n}\n\nfunc worker(){\n\tai.Lock();\n\tai.value += 1;\n\tai.Unlock();\n}\n```\n\n这种方式比较繁琐且效率低，标准库的sync/atomic包对原子操作提供了丰富的支持\n\n## 顺序一致性内存模型\n\n同JVM 在Go语言中 编译器也会进行乱序优化 \n\n但Go保证在同一个Goroutine中不会乱序\n\n## 基于Channel的通信\n\nChannel通信是在Goroutine之间进行同步的主要方法，无缓存的Channel上的发送操作总在对应的接收操作完成前发生\n\n```go\nvar done = make(chan bool)\nvar msg string\nfunc aGoroutine() {\n\tmsg = \"你好, 世界\"\n\tdone <- true\n}\n\nfunc main() {\n\tgo aGoroutine()\n\t<-done\n\tprintln(msg)\n}\n```\n","metadata":"","hasMoreCommit":false,"totalCommits":1,"commitList":[{"date":"2021-09-17T17:52:06+08:00","author":"cjiping","message":"➕增加 Go 内存模型","hash":"2bba18adaf03a02bab3fd6cfa462585c814b5890"}],"createTime":"2021-09-17T17:52:06+08:00"}