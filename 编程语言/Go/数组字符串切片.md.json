{"name":"数组字符串切片","id":"编程语言-Go-数组字符串切片","content":"# 数组 字符串 切片\n\n这三种数据类型，在底层原始数据有着相同的内存结构\n\n## 数组\n\n数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的，数组的长度是数组类型的组成部分，不同长度或不同类型的数据组成的数组都是不同的类型\n\n```go\nvar a [3]int                    // 定义长度为3的int型数组, 元素全部为0\nvar b = [...]int{1, 2, 3}       // 定义长度为3的int型数组, 元素为 1, 2, 3\nvar c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组, 元素为 0, 2, 3\nvar d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6\n```\n\n数组的传递是通过值而非引用，可以定义一个指向数组，但不同长度数组的指针的类型也都各不相同\n\n```go\nvar b = &a \n```\n\n### 迭代\n\n```go\nfor i, v := range a {\n\tfmt.Println(i, v)\n}\n```\n\n### 空数组\n\n长度为0的数组不会分配内存空间，可以用于强调某种特有类型的操作时避免分配额外的内存空间\n\n## 字符串\n\n字符串底层结构\n\n```go\ntype StringHeader struct {\n    Data uintptr\n    Len  int\n}\n```\n\n![2021914163350](/assets/2021914163350.png)\n\n### 字符串切片\n\n```go\nvar s = \"jntm\"\nfmt.Println(s[:2])\n```\n\n## 切片\n\n结构：\n\n```go\ntype SliceHeader struct {\n    Data uintptr\n    Len  int\n    Cap  int\n}\n```\n\n```go\nvar (\n    a []int               // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片\n    b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合\n    c = []int{1, 2, 3}    // 有3个元素的切片, len和cap都为3\n    d = c[:2]             // 有2个元素的切片, len为2, cap为3\n    e = c[0:2:cap(c)]     // 有2个元素的切片, len为2, cap为3\n    f = c[:0]             // 有0个元素的切片, len为0, cap为3\n    g = make([]int, 3)    // 有3个元素的切片, len和cap都为3\n    h = make([]int, 2, 3) // 有2个元素的切片, len为2, cap为3\n    i = make([]int, 0, 3) // 有0个元素的切片, len为0, cap为3\n)\n```\n\n### 添加元素\n\n```go\nc = append(c, 4)\n```\n","metadata":"","hasMoreCommit":false,"totalCommits":1,"commitList":[{"date":"2021-09-14T17:03:16+08:00","author":"cjiping","message":"➕新增 Go 数组字符串切片","hash":"3237de889ebcef31880a01582451069e99912742"}],"createTime":"2021-09-14T17:03:16+08:00"}