{"name":"HasKell","id":"编程语言-HasKell","content":"# HashKell\n\n## 编程环境\n\n- ghc是生成快速本底代码的优化编译器。\n- ghci是一个交互解析器和调试器。\n- runghc是一个以脚本形式(并不要首先编译)运行Haskell代码的程序\n\n## 基本操作\n\n- 登入解释器\n\n```sh\nghci\n```\n\n- 算术运算\n\n```sh\nPrelude> 2+2\n```\n\n- 逻辑运算\n\n```sh\nPrelude> True && False\n```\n\n不等于\n\n```sh\nPrelude> 1/=2\nTrue\n```\n\n```haskell\nif (5 /= 4) then \"got it\" else \"oh no\"\n```\n\n- 变量定义\n\n```sh\nPrelude> let name = \"cxk\"\nPrelude> name\n\"cxk\"\n```\n\n- 列表\n\n```sh\nPrelude> [\"1\",\"2\"]\n[\"1\",\"2\"]\n```\n\n列表中的项必须是相同类型\n\n列举\n\n```sh\nPrelude> [1..10]\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n列表相加\n\n```sh\nPrelude> [1..5] ++ [6..10]\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n增加元素到列表头\n\n```sh\nPrelude> 1 : [2..5]\n[1,2,3,4,5]\n```\n\n- 判断类型\n\n```sh\nPrelude> :type 'a'\n'a' :: Char\n```\n\n## 第一个Haskell程序\n\n```haskell\nmain = putStrLn \"hello world\"\n```\n\n```sh\nrunghc Helloworld.hs\n```\n\n## 类型系统\n\n- 强类型\n  - 不会进行自动转换\n- 静态\n  - 可以在编译期（而不是执行期）知道每个值和表达式的类型\n- 自动推导\n  - Haskell 编译器可以自动推断出程序中几乎所有表达式的类型\n\n函数与类型不可分离\n\n### 一些常用类型\n\n- Char\n  - 单个 Unicode 字符。\n- Bool\n  - 表示一个布尔逻辑值\n- Int\n  - 在 32 位机器里， Int 为 32 位宽，在 64 位机器里， Int 为 64 位宽\n- Integer\n  - 不限长度的带符号整数，在编写RSA加密，大数运算时很重要\n- Double\n  - 用于表示浮点数。长度由机器决定\n- 元组\n\n```haskell\n(1,\"cxk\")\n```\n\n```haskell\n:type (18, \"cxk\")\n```\n\n### 定义类型\n\n```haskell\ndata Person = Person String Int -- 定义一个新类型，= 后面的Person是构造函数\nlet man = Person \"cxk\" 1\n```\n\n- 类型别名\n\n```haskell\ntype Age = Int\n```\n\n- 代数类型\n\n```haskell\ndata Name = String String | String\nlet name = Name \"c\" \"xk\"\nlet name1 = Name \"cxk\"\n```\n\n- 枚举\n\n```haskell\ndata Color = Red | Blue | Yellow\n:type Red -- Red :: Color\n```\n\n### 参数化类型\n\n```haskell\n-- 定义一个带有泛型a参数的类型\ndata Optional a = Just a | Nothing\n```\n\n## 函数\n\n- 使用函数\n\n```haskell\n-- 调用compare函数 参数分别为1，2\ncompare 1 2\n-- 嵌套调用\nsqrt (sqrt 81)\n```\n\n- 函数类型\n\n```haskell\n:type sqrt\n-- sqrt :: Floating a => a -> a\n```\n\n纯度\n\n我们将带副作用的函数称为“不纯（impure）函数”，而将不带副作用的函数称为“纯（pure）函数”。\n\n- 函数定义\n\n```haskell\nadd :: (Int, Int) -> Int\nadd (x,y) = x+y\n```\n\n**非柯里化函数**：当函数有多个参数，必须通过元组一次性传入，染回返回结果\n\n当函数有多个参数时，参数可以一个一个地依次输入，如果参数不足，将返回一个函数作为结果，这样的函数就是柯里化的函数。\n\n\n- 分支\n\n```haskell\nif age <= 18 then \"cxk\" else \"jntm\"\n-- 需要注意两个分支的返回值都需要是同类型\n```\n\n- 惰性求值\n\n```haskell\nisOdd (1+2)\n-- 1+2只有在真正需要时，才会被计算\n```\n\n- 多态\n\n```haskell\n:type last\n-- last :: [a] -> a\n-- 输入一个列表，这个列表的元素类型为a，返回一个类型为a的元素\n```\n\n**软件的大部分风险，都来自于与外部世界进行交互**\n\n## 模式匹配\n\n```haskell\n-- Haskell 允许将函数定义为一系列等式\n-- 执行函数时，会逐个进行匹配\nmyNot True = False\nmyNot False = True\n```","metadata":"","hasMoreCommit":false,"totalCommits":9,"commitList":[{"date":"2020-12-01T14:55:26+08:00","author":"cjiping","message":"➕增加 Linux网络虚拟化","hash":"d3fe15824511368a8614aefb8d8c730a550eaa00"},{"date":"2020-06-10T16:12:40+08:00","author":"MY","message":"更新 haskell","hash":"fd7d08f5656119c1380864896f3a16c957d950e9"},{"date":"2020-06-09T16:24:51+08:00","author":"MY","message":"更新 haskell","hash":"a847786eeddfa5e1c9b28b417a1f087f943de6e1"},{"date":"2020-06-08T16:49:56+08:00","author":"MY","message":"更新 haskell","hash":"2120e422b3be61516efd4ac8860665bac78eae0e"},{"date":"2020-06-05T16:49:12+08:00","author":"MY","message":"更新 haskell","hash":"5885f4b190b2547f1457a2a0b7c19f7ac66dfec6"},{"date":"2020-06-03T16:15:18+08:00","author":"MY","message":"更新 haskell","hash":"f25bf2f9f8afae8c82199d568579f516aa2dbc60"},{"date":"2020-06-01T15:42:34+08:00","author":"MY","message":"更新 haskell","hash":"ed5ab28ad6c0e9d2d766766391701b8e3c39a4d7"},{"date":"2020-05-30T15:09:48+08:00","author":"MY","message":"更新 Haskell","hash":"d44c617571a3b36e1831698b9208b03b0ef8e897"},{"date":"2020-05-29T21:30:56+08:00","author":"MY","message":"增加 Haskell","hash":"56221de87f0fa106c91c97a0512fb1814e5a913b"}],"createTime":"2020-05-29T21:30:56+08:00"}