{"name":"Disruptor","id":"编程语言-JAVA-JAVA并发编程-Disruptor","content":"# Disruptor\n\n## 设计方案\n\n- 环形数组结构\n  - 为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。\n\n![利用填充使缓存友好](/assets/20227721135.webp)\n\n环形数组也有能充分利用[局部性原理](/计算机系统/程序结构和执行/存储器层次结构.md#局部性), 可以一齐加载通过缓存行加载到CPU高速缓存，数据的遍历访问可以更有效地利用了 CPU 里面的多级[流水线](/计算机系统/程序结构和执行/处理器体系架构.md#流水线的通用原理)\n\n- 元素位置定位\n  - 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n- 无锁设计\n  - 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，通过CAS在该位置写入或者读取数据。\n\n**@Contended注解**：可以用于类级别的修饰，同时也可以用于字段级别的修饰，当应用于字段级别时，被注释的字段将和其他字段隔离开来，会被加载在独立的缓存行上，字段级别上，@Contended还支持一个“contention group”属性，同一group的字段们在内存上将是连续（64字节范围内）\n\n如果在类上应用该注解，将使整个字段块的两端都被填充，就跟Disruptor自己定义7个变量一样\n\n使用7个变量的原因在于：前后7个就是因为8个long正好64byte，这样cache line无论在哪个位置被加载，这64个byte在第一次加载到cache line\n\n填充cache line的手法是为了防止False Sharing：多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能\n\n## 开发\n\n- 定义Event - 队列中需要处理的元素\n- 定义Event工厂，用于填充队列\n\ndisruptor初始化的时候，会调用Event工厂，对ringBuffer进行内存的提前分配 GC产生频率会降低\n\n```java\npublic class StringEventFactory implements EventFactory<String> {\n    @Override\n    public String newInstance() {\n        return UUID.randomUUID().toString();\n    }\n}\n```\n\n- 定义EventHandler（消费者），处理容器中的元素\n\n```java\npublic class StringEventHandler implements EventHandler<String> {\n    @Override\n    public void onEvent(String s, long l, boolean b) throws Exception {\n        System.out.println(Thread.currentThread().getName() + \"handle \" + s);\n    }\n}\n```\n\n```java\nStringEventFactory eventFactory = new StringEventFactory();\nint bufferSize = 1024;\n\nDisruptor<String> disruptor =\n        new Disruptor<>(eventFactory, bufferSize, Executors.defaultThreadFactory());\ndisruptor.handleEventsWith(new StringEventHandler());\ndisruptor.start();\n\nRingBuffer<String> ringBuffer = disruptor.getRingBuffer();\nfor (int i = 0; i < 10; i++) {\n    ringBuffer.publishEvent((s, l) -> {});\n}\n```\n\n## 生产者线程模式\n\nProducerType有两种模式 Producer.MULTI和Producer.SINGLE\n\n默认是MULTI，表示在多线程模式下产生sequence\n\n如果确认是单线程生产者，那么可以指定SINGLE，效率会提升\n\n## 等待策略\n\n1，(常用）BlockingWaitStrategy：通过线程阻塞的方式，等待生产者唤醒，被唤醒后，再循环检查依赖的sequence是否已经消费。\n\n2，BusySpinWaitStrategy：线程一直自旋等待，可能比较耗cpu\n\n3，LiteBlockingWaitStrategy：线程阻塞等待生产者唤醒，与BlockingWaitStrategy相比，区别在signalNeeded.getAndSet,如果两个线程同时访问一个访问waitfor,一个访问signalAll时，可以减少lock加锁次数.\n\n4，LiteTimeoutBlockingWaitStrategy：与LiteBlockingWaitStrategy相比，设置了阻塞时间，超过时间后抛异常。\n\n5，PhasedBackoffWaitStrategy：根据时间参数和传入的等待策略来决定使用哪种等待策略\n\n6，TimeoutBlockingWaitStrategy：相对于BlockingWaitStrategy来说，设置了等待时间，超过后抛异常\n\n7，（常用）YieldingWaitStrategy：尝试100次，然后Thread.yield()让出cpu\n\n8，（常用）SleepingWaitStrategy : sleep\n\n## 消费者异常处理\n\n默认：disruptor.setDefaultExceptionHandler()\n\n覆盖：disruptor.handleExceptionFor().with()","metadata":"","hasMoreCommit":false,"totalCommits":2,"commitList":[{"date":"2022-07-07T21:53:14+08:00","author":"MY","message":"✏️更新 并发与底层","hash":"b99a8b8e7cd5b351f7553f7ab8d2d5b9b76f8a5b"},{"date":"2020-07-08T15:05:22+08:00","author":"MY","message":"✏更新 高并发编程","hash":"0d3181c331d769b1ca342793ee77f92001458080"}],"createTime":"2020-07-08T15:05:22+08:00"}