# JAVA内存模型(JMM)

## 线程安全

当多个线程同时操作某个对象时，这个对象始终都能表现出正确的行为，则称这个类是线程安全的

### 解决方法

- 内置锁
  - 同步方法
    - 静态：当前类的同步代码块
    - 非静态：当前对象的同步代码块
  - 同步代码块
- 显式锁

## 死锁

两个线程互相等待对方持有的锁而陷入无限等待状态

## ThreadLocal

>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本

```java
public class Main implements Runnable{
    private ThreadLocal<String> ts = new ThreadLocal<>();

    @Override
    public void run() {
        ts.set(Thread.currentThread().getName());
        System.out.println(ts.get());
    }
}
```

### 原理

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value);
    } else {
         createMap(t, value);
    }
}
```

## JAVA内存模型JMM

>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本

![批注 2020-03-12 195705](/assets/批注%202020-03-12%20195705.png)

### 内存间的交互操作

![202031219588](/assets/202031219588.png)

- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

### 三大特性

#### 原子性

JAVA内存模型保证了以上8种内存操作具有原子性

但是允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行

#### 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改

变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性

实现可见性的方式：

- 被volatile修饰的变量，它会保证修改的值会立即被更新到主存
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值

### 有序性

在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序

指令重排序：Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前

synchronized 也可以来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码

- 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性

### as-if-serial语义

as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变

## 先行发生原则

### 单一线程原则

一个线程内，在程序前面的操作先行发生于后面的操作

### 管程锁定规则

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作

### volatile 变量规则

一个 volatile 变量的写操作先行发生于后面对这个变量的读操作

### 线程启动规则

Thread 对象的 start() 方法调用先行发生于此线程的每一个动作

### 线程加入规则

Thread 对象的结束先行发生于 join() 方法返回

### 线程中断规则

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

### 对象终结规则

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始

### 传递性

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C