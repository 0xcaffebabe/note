{"name":"JAVA并发编程","id":"编程语言-JAVA-JAVA并发编程-JAVA并发编程","content":"# 并发编程\n\n- 并发：指两个或多个事件在同一个时间段内发生。\n- 并行：指两个或多个事件在同一时刻发生（同时发生）。\n\n[超线程](/计算机系统/程序结构和执行/处理器体系架构.md#超线程)：一个ALU对应多个PC\n\n并发程序的特点：\n\n- 线程之间相互制约的关系\n- 线程执行过程需要上下文切换　断断续续的\n- 并发数设置合理时(以CPU)　才会提高并发程序的性能\n\n## 线程间通信\n\n- 等待-唤醒机制\n\n```mermaid\nsequenceDiagram\n    生产者 ->> 同步对象: wait\n    消费者 ->> 同步对象: notify\n    同步对象 -->> 生产者: 继续执行\n```\n\n要注意，wait() notify() notifyAll()都需要在synchronized中\n\nwait() 会释放锁，sleep() 不会\n\n```java\nObject object = new Object();\n\nnew Thread(){\n    @Override\n    public void run() {\n        synchronized (object){\n            System.out.println(\"要5个包子\");\n            // 进入等待，这时候锁会被释放\n            try {\n                object.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"得到了5个包子\");\n        }\n    }\n}.start();\n\nnew Thread(){\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        synchronized (object){\n            System.out.println(\"包子生产完毕，告诉顾客\");\n            // 通知等待线程中的任意一个\n            object.notify();\n        }\n    }\n}.start();\n```\n\n- wait与notify一定要在线程同步中使用,并且是同一个锁的资源\n- 在调用sleep()方法的过程中，线程不会释放对象锁\n\n## 对象的共享\n\n- 发布: 使对象能在当前作用域之外使用\n- 逸出: 某个不该发布的对象被发布了\n\n如果this在构造器完成构造之前逸出，还没被构造完成的对象被别人使用，会发生什么问题？\n\n### 线程封闭\n\n> 某个对象只能在某个线程之内使用\n\n#### Ad-hoc线程封闭\n\n- 完全由程序保证对象不被逸出，很脆弱\n\n#### 栈封闭\n\n- 对象只能在局部（方法内）使用\n\n```java\npublic void process() {\n    Object obj = new Object();\n    // 对对象做些计算\n    int result = obj.process();\n    return result;\n}\n```\n\n#### [ThreadLocal](/编程语言/JAVA/JAVA并发编程/并发工具类.md#ThreadLocal)\n\n- 保证线程自己的数据封闭在本线程内\n\n```java\nprivate static ThreadLocal<Connection> holder = ThreadLocal.withInitial(() -> getConnection());\n```\n\n### 不变性\n\n> 不可变对象一定是线程安全的\n\n- 对象创建后其状态就不能修改\n- 对象的所有域都是final\n- 在对象创建的过程中this引用没有逸出\n\n### 安全发布\n\n在多线程环境下使用可变的对象，需要通过安全发布的方式并且需要通过锁来保护\n\n- 在静态初始化函数中初始化一个对象的引用（JVM同步机制保障）\n- 将对象的引用保存到volatile类型的域或者 Reference对象\n- 将对象的引用保存到正确初始化的对象的final域\n- 将对象的引用保存到由锁保护的域\n\n## 对象的组合\n\n- 如何构建线程安全的类？\n\n**依赖状态的操作**：某个操作包含有基于状态的先验操作\n\n```java\nif (a== 1){\n    a++;\n}\n```\n\n在并发编程中，由于其他线程也会修改状态，所以需要一些JUC中的基础类库来帮助我们在并发环境下执行基于依赖的操作\n\n在提供多线程API时，将是否线程安全文档化\n\n### 实例封闭\n\n- 监视器模式（客户端加锁），最简单的封闭机制\n\n> 将线程不安全的对象封装在某个进行良好并发控制的对象内\n\n```java\nprivate Object obj = new Object();\n...\nsynchronized(obj){\n    obj.xxx();\n}\n```\n\n### 线程安全委托\n\n> 线程不安全的对象将线程安全的职责委托给线程安全的对象\n\n```java\n// 线程安全的类\nprivate AtomicInteger coutner = new AtomicInteger();\n...\nvoid increase() {\n    counter.increase();\n}\n```\n\n这种方式要求委托方对被委托方的API调用不能出现复合操作，否则委托方仍需要采用一定的线程安全机制\n\n```java\nprivate AtomicInteger coutner1 = new AtomicInteger();\nprivate AtomicInteger coutner2 = new AtomicInteger();\n...\n// × 不安全\nvoid increase() {\n    coutner1.increase();\n    coutner2.increase();\n}\n```\n\n## 取消与关闭\n\n一个可取消的任务必须拥有取消策略\n\n```java\nwhile(runnable) {\n    // do something\n}\n```\n\n使用中断来取消是最合理的方式，线程中断是线程之间协作的一种手段，中断是取消的一种语义实现，所以这要求你自己的线程必须决定如何响应中断\n\n除非知道某个线程的中断策略，否则不要中断该线程\n\n```java\n// thread1\nwhile(!isInterrupted()){\n    System.out.println(\"running\");\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        break;\n    }\n}\nSystem.out.println(\"my thread done\");\n\n// main thread\nthread1.interrupt();\n```\n\nJVM 在线程阻塞状态时若发生中断，会抛出一个中断异常，在非阻塞情况下，就需要检查中断状态来判断是否发生中断\n\n### 使用Future取消\n\n```java\nFuture<Double> future = service.submit(() -> {\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return Math.random();\n});\ntry {\n    Double ret = future.get(3, TimeUnit.SECONDS);\n    System.out.println(\"result\"+ret);\n} catch (ExecutionException | TimeoutException e) {\n    e.printStackTrace();\n}finally {\n    future.cancel(true);\n    System.out.println(\"task cancel\");\n}\n```\n\n### 处理不可中断的阻塞\n\n由于如IO等的资源一旦阻塞就无法进行中断，所以可对其做关闭处理来模拟中断\n\n### 停止基于线程的服务\n\n基于生产者消费者的队列模式，要求消费者等待生产者完全关闭后，才能安全结束\n\n- 使用ExecutorService的生命周期管理方法\n- 毒药对象\n  - 本质上就是一个flag，当队列读取到这个毒药时，就会停止相关操作 这要求生产与消费者数量都要是已知的 因为只有接收到确定数量的毒药对象 才能判断是否所有生产者都停止了\n\n### 处理非正常的线程终止\n\n```java\nthread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        System.out.println(t + \"something happen\" + e);\n    }\n});\n\nnew Thread(){\n    @Override\n    public void run() {\n        throw new RuntimeException(\"aaaa\");\n    }\n}.start();\n```\n\n### JVM关闭钩子\n\n```java\nRuntime.getRuntime().addShutdownHook(new Thread(){\n    @Override\n    public void run() {\n        System.out.println(\"jvm shutdown\");\n    }\n});\n```\n\n## 性能与伸缩性\n\n### 引入线程的开销\n\n- 上下文切换：切换浪费的CPU周期、重新加载线程重新载入数据的开销\n- 内存同步：使用如 synchronized 的机制，线程之间竞争带来的开销\n- 阻塞：IO操作或者竞争失败的线程可能会陷入阻塞等待被唤醒\n\n### 如何减少锁的竞争\n\n锁的请求频率越快 持有锁时间越长 竞争越激烈\n\n- 缩小锁的范围（快进快出）\n  - 缩小synchronized关键字包围的代码块\n- 减小锁的粒度\n  - 不同的操作使用不同的锁\n- 分段锁 对集合元素进行平均拆分 使用 N 个锁 使一个锁保护 1/N 个元素\n- 避免热点\n- 替代独占锁\n  - 采取读写锁\n\n## 并发程序测试\n\n### 正确性测试\n\n- 验证在不变性条件下后验条件是不是正确的\n\n传统的单元测试只能在线程串行的情况运行\n\n阻塞行为的测试：一个阻塞方法调用后线程应该等待到直至该线程被中断，抛出InterruptExpcetion\n\n安全性测试：检查在并发情况下，极易发生错误的一些属性\n\n资源管理测试：如测试对资源的限制是否真正起作用了\n\n使用回调帮助测试：对于一些并发类库，会在某些节点回调客户端代码，可以利用这些回调来验证后验条件\n\n加大线程切换以暴露错误：通过Thread.yield() 让步，产生更多的上下文切换，可能会更早暴露出错误\n\n### 性能测试\n\n使用场景选择 -> 多次执行场景 -> 衡量执行效率\n\n#### 性能测试陷阱\n\nJVM 的某些行为会导致性能测试测量不准\n\n- 垃圾回收STW\n- 动态编译（JIT）导致热点代码被本地编译\n- 编译优化\n- 竞争程度，竞争的激烈程度应贴合真实场景\n\n## 锁优化\n\n### 自旋锁与自适应自旋\n\n是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态\n\n自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，如果等待时间比较短，自旋还是很划算的\n\n自旋超过一定的阈值就不会再继续重试，自适应自旋则代表这个阈值不是固定的，会根据性能监控情况动态调整\n\n### 锁消除\n\n对于被检测出不可能存在竞争的共享数据的锁进行消除\n\n### 锁细化\n\n尽力缩小锁的作用范围\n\n### 锁粗化\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗\n\n如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部\n\n```java\nsynchronized(obj){\n    //...\n}\nsynchronized(obj){\n    //...\n}\nsynchronized(obj){\n    //...\n}\n```\n\n```java\nsynchronized(obj){\n    //...\n    //..\n    //...\n}\n```\n\n### 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销\n\n### 偏向锁\n\n偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要\n\n## 同步工具类设计\n\n### 状态依赖性管理\n\n```java\n// 可阻塞的状态依赖操作结构\n获取锁\nwhile(前置条件不满足) {\n    释放锁\n    等待至前置条件满足\n    如果超时或者被interrupt则失败\n}\n执行动作\n释放锁\n```\n\n#### 调用者处理失败\n\n简单地将失败传递给调用者：只是将处理失败的职责从服务代码转移到客户代码\n\n```java\nsynchroized void put() {\n    if (full) throw Excetion\n    putVal()\n}\n```\n\n#### 自旋阻塞\n\n这种方式的问题在于如果线程一进入休眠，条件马上变为真，此时会浪费大量的时间在休眠上\n\n```java\nvoid put(){\n    while(true) {\n        synchroized(this) {\n            if (full) {\n                Thread.sleep(1999);\n                continue;\n            }\n            putVal()\n            return;\n        }\n    }\n}\n```\n\n#### 条件队列\n\n```java\nsynchroized void put() {\n    // wait会释放锁\n    // 当从wait中恢复，也就是被唤醒了，此时又获得了这把锁\n    // 等待的这个条件必须在变真时，以某种形式发出通知 否则死锁\n    while(full) wait(); // 即使被唤醒了 也不代表前置条件为真了 所以wait必须在一个循环中\n    doPut();\n    notifyAll();\n}\n```\n\n### 显式Condtion\n\n这种方式相较于条件队列拥有更多的功能：可中断不可中断等待、基于时限的等待、公平等待\n\n```java\nnotFull = lock.newCondtion();\nnotEmpty = lock.newCondtion();\n...\nvoid put(){\n    lock.lock();\n    while(full) notFull.await();\n    putVal();\n    notEmpty.singnal();\n    lock.unlock(); // 应该使用finally释放\n}\n```\n\n## 并发编程良好实践\n\n- 给线程起名字\n- 缩小同步范围\n- 多用同步工具少用原始的wait,notify\n- 使用阻塞队列\n- 多用 ConcurrentHashMap 而不是 Hashtable\n- 使用栈封闭以及不变性保证线程安全\n- 使用线程池\n","metadata":"","hasMoreCommit":true,"totalCommits":40,"commitList":[{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2023-11-24T11:45:52+08:00","author":"MY","message":"📦清理大图","hash":"e3ff900ed2a2e49e9f3bd316935fe853796f7e52"},{"date":"2022-06-29T21:37:26+08:00","author":"MY","message":"✏️更新 处理器体系结构","hash":"66bdeb6527dc0ce151b74584d9fece22a8846dac"},{"date":"2022-04-19T15:48:50+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"646d648582446fdbede6731a900b4fe174238fc8"},{"date":"2022-03-17T16:51:46+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"7f46c93d6f16638d4ab48bc691902682d024b430"},{"date":"2022-03-16T17:11:49+08:00","author":"cjiping","message":"✏️更新 JAVA 并发编程","hash":"1c82a1f8cf61fee93f518eedcc38c0190ad11c56"},{"date":"2022-03-15T16:34:46+08:00","author":"cjiping","message":"✏️更新 死锁","hash":"dd32213c87de1c47eb03ce3f218c8fc99d827b48"},{"date":"2022-03-10T16:50:11+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"ba23eb355d62e76d011370f5ba776dc643636c9b"},{"date":"2022-03-09T17:46:16+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"05cdd8647ade510badf68feae84d459e83c2b943"},{"date":"2022-03-07T17:09:32+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"3d361de7e12a3d7d557679ad523bcaecd04421c7"}],"createTime":"2019-09-16T09:09:52+08:00"}