{"name":"JAVA并发编程","id":"编程语言-JAVA-JAVA并发编程-JAVA并发编程","content":"# Java 并发编程\n\n## 一、并发编程的本质问题（第一性原理层）\n\n并发编程并不是关于“多线程”，而是关于**在不确定时序下，对共享状态的控制问题**。\n\n### 1. 并发的三个永恒问题\n\n所有并发 Bug，本质上都可以归结为以下三类之一：\n\n1. **可见性（Visibility）**\n   一个线程对状态的修改，是否能被其他线程观察到。\n\n2. **原子性（Atomicity）**\n   一个操作是否不可被中断、不可被拆分。\n\n3. **有序性（Ordering）**\n   程序执行顺序在不同线程观察下是否一致。\n\n> 这三者是跨语言、跨平台、跨时代的并发本质问题。\n\n---\n\n## 二、并发控制的核心思想（跨语言稳定层）\n\n这一层不依赖 Java，也不依赖 JVM，而是并发系统设计的通用思想。\n\n### 2.1 不共享是最高级的并发安全\n\n并发问题的根源在于**共享**，因此：\n\n> **不共享 = 天然线程安全**\n\n#### 线程封闭（Thread Confinement）\n\n* 对象只在单一线程内使用\n* 不需要任何同步机制\n\n常见形式：\n\n* 栈封闭（方法内对象）\n* 任务私有对象\n\n> 封闭是一种“架构选择”，不是语法技巧。\n\n---\n\n### 2.2 只读共享：不变性（Immutability）\n\n如果共享不可避免，下一优先级是：\n\n> **共享但不可变**\n\n不变对象的并发安全来自其数学属性，而非同步机制。\n\n不变性的三个条件：\n\n* 状态创建后不可修改\n* 所有字段为 final\n* 构造期间 this 不逸出\n\n> 不变性是并发世界中最强的确定性来源。\n\n---\n\n### 2.3 受控共享：同步与协作\n\n当对象既需要共享，又必须可变：\n\n> 并发的核心任务 = **协调对状态的访问顺序**\n\n这引出了同步、锁、条件等待等机制。\n\n---\n\n## 三、对象共享与发布模型（并发设计主线）\n\n### 3.1 对象生命周期视角\n\n并发安全问题，本质是**对象生命周期与线程生命周期不一致**。\n\n关键问题：\n\n* 对象何时创建？\n* 何时对其他线程可见？\n* 由谁负责修改？\n\n---\n\n### 3.2 发布与逸出\n\n* **发布**：对象从私有域进入共享域\n* **逸出**：对象在未准备好时被发布\n\n构造期间逸出是最危险的并发错误之一。\n\n---\n\n### 3.3 安全发布（Safe Publication）\n\n安全发布不是“是否加锁”，而是**建立可见性与有序性保证**。\n\n通用安全发布策略：\n\n* 静态初始化\n* final 字段语义\n* volatile / 原子引用\n* 锁保护的发布\n\n> 没有安全发布，线程安全无从谈起。\n\n---\n\n## 四、并发类的设计模式（架构层）\n\n### 4.1 实例封闭（Instance Confinement）\n\n将线程不安全对象封装在一个受控的并发边界内。\n\n* 并发策略集中\n* 对外暴露安全接口\n\n这是最常见、也是最稳健的并发类设计方式。\n\n---\n\n### 4.2 线程安全委托（Delegation）\n\n将并发安全责任交给更底层的线程安全组件。\n\n前提：\n\n* 不引入新的复合状态依赖\n\n> 委托失败，往往源于“多个原子操作组合后不再原子”。\n\n---\n\n### 4.3 状态依赖操作\n\n并发系统中最复杂的不是互斥，而是：\n\n> **操作是否依赖于状态是否满足某个条件**\n\n这类操作需要：\n\n* 条件检查\n* 等待\n* 被唤醒后重新校验\n\n---\n\n## 五、等待、通知与协作机制\n\n### 5.1 等待-通知的本质模型\n\n等待不是“睡眠”，而是：\n\n> **在条件未满足时，主动让出执行权，并等待条件变化的通知**\n\n核心原则：\n\n* 等待必须释放锁\n* 被唤醒 ≠ 条件满足\n* 条件检查必须在循环中\n\n---\n\n### 5.2 条件队列与显式条件\n\n条件队列解决的是：\n\n* 多条件等待\n* 精准唤醒\n* 可中断 / 可超时\n\n它体现的是**状态机式并发设计思想**。\n\n---\n\n## 六、取消、关闭与线程生命周期管理\n\n### 6.1 取消不是强制终止\n\n并发系统中：\n\n> **取消是一种协作协议，而非控制命令**\n\n线程必须自行决定：\n\n* 是否响应取消\n* 如何清理资源\n\n---\n\n### 6.2 中断的语义\n\n中断不是异常，而是：\n\n> **一种跨线程的协作信号**\n\n设计原则：\n\n* 不知道中断策略，不要中断\n* 阻塞方法要么响应中断，要么明确不可中断\n\n---\n\n### 6.3 基于任务的取消\n\nFuture、Executor 的意义在于：\n\n* 将线程管理权从业务逻辑中剥离\n* 提供统一的生命周期控制\n\n---\n\n## 七、性能与伸缩性的并发视角\n\n### 7.1 并发的成本模型\n\n并发不是免费的：\n\n* 上下文切换\n* 同步开销\n* 阻塞等待\n\n> 并发的目标不是“线程更多”，而是“等待更少”。\n\n---\n\n### 7.2 锁竞争的本质\n\n竞争强度取决于：\n\n* 请求频率\n* 持锁时间\n\n优化方向：\n\n* 减少共享\n* 缩短临界区\n* 降低热点\n\n---\n\n## 八、JVM 层面的并发优化（实现细节层）\n\n> 本章属于**了解即可**，不应作为设计依据。\n\n* 偏向锁\n* 轻量级锁\n* 自旋与自适应自旋\n* 锁消除与锁粗化\n\n这些优化的前提是：\n\n> **你的并发设计本身是合理的**\n\n---\n\n## 九、并发程序的测试哲学\n\n### 9.1 并发测试的困难\n\n并发 Bug 是：\n\n* 时序相关的\n* 不可复现的\n* 概率性的\n\n---\n\n### 9.2 测试关注点\n\n* 正确性（不变性、后验条件）\n* 安全性（无越界、无破坏）\n* 活跃性（无死锁、无饥饿）\n* 性能特性（吞吐、延迟）\n\n---\n\n## 十、并发系统的工程哲学（长期稳定知识）\n\n* 并发不是为了快，而是为了**隐藏等待**\n* 不共享是最高级的线程安全\n* 锁是成本，不是能力\n* 中断是协议，不是异常\n* 并发 Bug 本质是**时间维度的 Bug**\n\n> 一个优秀的并发系统，应该让并发问题**难以出现，而不是容易修复**。\n\n## 关联内容（自动生成）\n\n- [/编程语言/JAVA/JAVA并发编程/基础概念.md](/编程语言/JAVA/JAVA并发编程/基础概念.md) 深入了解Java并发编程的基础概念，包括线程生命周期、并发问题等核心知识点\n- [/编程语言/JAVA/JAVA并发编程/线程.md](/编程语言/JAVA/JAVA并发编程/线程.md) 详细探讨Java中线程的创建、管理和控制机制，与本文档中的线程生命周期管理内容密切相关\n- [/编程语言/JAVA/JAVA并发编程/线程池.md](/编程语言/JAVA/JAVA并发编程/线程池.md) 线程池是实现高效并发的关键组件，提供了线程生命周期管理的高级抽象\n- [/编程语言/JAVA/JAVA并发编程/并发工具类.md](/编程语言/JAVA/JAVA并发编程/并发工具类.md) Java并发包提供了丰富的同步工具类，是实现本文档所述并发控制思想的具体手段\n- [/编程语言/JAVA/JAVA并发编程/并发集合.md](/编程语言/JAVA/JAVA并发编程/并发集合.md) 并发集合是线程安全的数据结构，体现了本文档中提到的实例封闭和线程安全委托设计模式\n- [/编程语言/JAVA/JVM/JAVA内存模型.md](/编程语言/JAVA/JVM/JAVA内存模型.md) Java内存模型定义了多线程环境下的内存访问规则，是理解可见性、原子性和有序性问题的基础\n- [/操作系统/进程与线程.md](/操作系统/进程与线程.md) 操作系统层面的进程与线程概念是理解Java并发编程模型的基础，有助于深入理解线程调度和同步机制\n- [/软件工程/架构/系统设计/高并发.md](/软件工程/架构/系统设计/高并发.md) 高并发系统设计涉及大量并发编程原理的应用，是本文档理论知识的实际应用场景\n- [/编程语言/并发模型.md](/编程语言/并发模型.md) 不同编程语言的并发模型比较，有助于理解Java并发编程模型的特点和优势\n- [/计算机网络/IO模型.md](/计算机网络/IO模型.md) IO模型与并发编程密切相关，特别是在处理高并发网络请求时，需要结合IO模型选择合适的并发策略\n","metadata":"tags: ['并发编程', '编程语言', '操作系统']","hasMoreCommit":true,"totalCommits":42,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2026-01-08T16:50:02+08:00","author":"MY","message":"docs(java): 重构Java并发编程文档结构并完善内容体系","hash":"4b6d89a04a6a81ed082d73bd4e30772492905b8a"},{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2023-11-24T11:45:52+08:00","author":"MY","message":"📦清理大图","hash":"e3ff900ed2a2e49e9f3bd316935fe853796f7e52"},{"date":"2022-06-29T21:37:26+08:00","author":"MY","message":"✏️更新 处理器体系结构","hash":"66bdeb6527dc0ce151b74584d9fece22a8846dac"},{"date":"2022-04-19T15:48:50+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"646d648582446fdbede6731a900b4fe174238fc8"},{"date":"2022-03-17T16:51:46+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"7f46c93d6f16638d4ab48bc691902682d024b430"},{"date":"2022-03-16T17:11:49+08:00","author":"cjiping","message":"✏️更新 JAVA 并发编程","hash":"1c82a1f8cf61fee93f518eedcc38c0190ad11c56"},{"date":"2022-03-15T16:34:46+08:00","author":"cjiping","message":"✏️更新 死锁","hash":"dd32213c87de1c47eb03ce3f218c8fc99d827b48"},{"date":"2022-03-10T16:50:11+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"ba23eb355d62e76d011370f5ba776dc643636c9b"}],"createTime":"2019-09-16T09:09:52+08:00"}