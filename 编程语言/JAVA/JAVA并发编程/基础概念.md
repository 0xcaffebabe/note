# 基础概念

## 进程与线程

进程是所有线程的集合，每一个线程是进程中的一条执行路径

## 线程分类

- 用户线程
  - 主线程
  - 子线程
- 守护线程
  - *守护线程当进程不存在或主线程停止，守护线程也会被停止*
  - GC线程

## 创建线程

### 继承Thread类

```java
class MyThread extends Thread{
    @Override
    public void run() {}
}
```

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈

![批注 2019-08-02 115159](/assets/批注%202019-08-02%20115159.png)

Thread类

- public String getName() :获取当前线程名称。
- public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
- public void run() :此线程要执行的任务在此处定义代码。
- public void yield():让出CPU，返回到就绪状态
- join：等待被调用join的线程执行完毕再继续运行
- public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
- public static Thread currentThread() :返回对当前正在执行的线程对象的引用

**InterruptedException**

调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞(sleep)、限期等待或者无限期等待(wait)状态，那么就会抛出 InterruptedException，从而提前结束该线程

**interrupted()**

在自定义线程执行任务使，可以使用这个方法作为一个flag，作为是否继续运行的依据

```java
while(interrupted()){
    // do
}
// end
```

### 实现Runnable接口

**实现Runnable接口比继承Thread类所具有的优势：**

- 适合多个相同的程序代码的线程去共享同一个资源。
- 可以避免java中的单继承的局限性。
- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

## 线程状态

![批注 2020-06-17 111804](/assets/批注%202020-06-17%20111804.png)

线程状态                | 导致状态发生条件
------------------- | -------------------------------------------------------------------------------------------------------------
NEW(新建)             | 线程刚被创建，但是并未启动。还没调用start方法。
Runnable(可运行)       | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。
Blocked(锁阻塞)        | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。
Waiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。
Teminated(被终止)      | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

## synchronized

使用了锁对象，这个锁对象一瞬间只能被一个线程所持有

```java
synchronized(this){ // 可以是任意一个对象
  // 需要同步操作的代码
}
```
```java
public synchronized void method(){ // 也可以同步静态方法，等同于上面的synchronize(this)
  // 可能会产生线程安全问题的代码   
}
```

synchronized是可重入锁

> 重入：某个线程试图获得一个已经由它持有的锁

程序执行过程中发生异常，锁会被释放

不能使用String常量，以及int long等原始类型

**synchronized底层**

JDK早期的 使用的重量级实现 也就说在 OS 层面
后来的进行了改进

synchronized实现过程

- java代码：synchronized
- 字节码： monitorenter monitorexit
- 执行过程中会进行锁升级
- lock comxchg

锁升级：

markword 记录这个线程ID （偏向锁）
如果线程争用，则升级为 自旋锁
10次以后，升级为重量级锁，也就是OS层面

执行时间短（加锁代码），线程数少，用自旋
执行时间长，线程数多，用系统锁

## volatile

- 保证线程可见性
  - MESI 缓存一致性协议
- 禁止指令重排序
  - DCL(double check lock) 单例

### 可见性

在没有同步的情况下，编译器或者处理器都会对一些上下文无关的指令进行**重排序**，这可能会导致一个线程修改了某一个数值，而另一个线程无法马上读取到修改后的数值

- 失效数据
- 非原子的64位操作

  > 在java当中，一个64位大小的数值可以被分为2个32位的操作

### 加锁与可见性

![](https://wiki.jikexueyuan.com/project/java-concurrency/images/synchronous.jpg)

之所以要在访问某个共享的可变变量时要求所有线程在锁上同步，就是为了确保读写可见性。 加锁的含义不局限与互斥行为，还包括内存可见性

volatile是比synchronized更为轻量级的同步机制，它无法进行互斥操作，但能保证内存可见性

- 典型用法

```java
voatile boolean f;

while (f){
    // do something
}
```

## CAS

- AtomicInteger 等原子类的实现

![批注 2020-05-12 135356](/assets/批注%202020-05-12%20135356.png)

它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程进行自旋重复上述操作或者什么都不做。最后，CAS返回当前V的真实值

CAS是CPU原语支持

- ABA问题

如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过

解决方法：版本号

**AtomicStampedReference**

## unsafe类

直接操作JVM里的内存

**JDK9之后无法使用了**

- allocateMemory 直接分配内存
- freeMemory  释放内存
- compareAndSet CAS操作
