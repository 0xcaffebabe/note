{"name":"基础概念","id":"编程语言-JAVA-JAVA并发编程-基础概念","content":"# 基础概念\n\n## 线程安全\n\n> 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的\n\n线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。\n\nJAVA API 中存在线程安全问题的类：\n\n- StringBuffer\n- Vector\n- ...\n\n### 原子性\n\n```java\nif (condition){\n    a++; // 当此段代码运行在多线程的环境时，则会产生线程安全问题\n}\n```\n\n> 竞态条件(race condition): 多个进程（线程、协程）竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件\n\n当一个线程观察到一个变量的值时，它并不是正确有效的，可能已在此之前就被其他线程修改过，基于失效的观察结果，就是大多数竞态条件的本质\n\n一种常见的竞态条件发生在单例构造模式中：\n\n```java\npublic static Object get(){\n\n    if (instance == null){\n        instance = new Object();\n    }\n    return instance;\n}\n```\n\n为了解决观察失效这个问题，也就是为了避免竞态条件，就需要对一组操作进行原子化，即不可分割。要不全做，要不就不做。这组操作称之为复合操作。\n\n- 复合操作：由一系列原子操作构成\n\n### 不可变\n\n不可变（无状态）的对象一定是线程安全的\n\n这种对象的接口一般需要精心设计 最简单的方式是所有成员变量设置为final\n\n### 绝对线程安全\n\n不管运行时环境如何，调用者都不需要任何额外的同步措施\n\n### 相对线程安全\n\n要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性\n\n### 线程兼容\n\n对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用\n\n### 线程对立\n\n指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码\n\n## 线程安全的实现\n\n### 互斥同步（加锁）\n\n- synchronized\n- Lock\n\n### 非阻塞同步\n\n- CAS\n\n### 无同步方案\n\n- 可重入代码：类似于函数式编程，不会产生副作用\n- 线程本地存储\n\n## synchronized\n\n使用了锁对象，这个锁对象一瞬间只能被一个线程所持有\n\n```java\nsynchronized(this){ // 可以是任意一个对象\n  // 需要同步操作的代码\n}\n```\n```java\npublic synchronized void method(){ // 也可以同步静态方法，等同于上面的synchronize(this)\n  // 可能会产生线程安全问题的代码   \n}\n```\n\nsynchronized是可重入锁\n\n> 重入：某个线程试图获得一个已经由它持有的锁\n\n程序执行过程中发生异常，锁会被释放\n\n不能使用String常量，以及int long等原始类型\n\n**synchronized底层**\n\nJDK早期的 使用的重量级实现 也就是在 OS 层面，后来的进行了改进\n\n### synchronized实现过程\n\n- java代码层面：synchronized\n- 字节码层面： **monitorenter monitorexit**\n- 执行过程中会进行锁升级\n- 汇编层面：lock comxchg\n\n任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向）\n\n```cpp\n/* JVM实现 中的 Monitor 结构 */\nObjectMonitor() {\n    _header       = NULL;\n    _count        = 0; // 记录个数\n    _waiters      = 0,\n    _recursions   = 0;\n    _object       = NULL;\n    _owner        = NULL;\n    _WaitSet      = NULL; // 处于wait状态的线程，会被加入到_WaitSet\n    _WaitSetLock  = 0 ;\n    _Responsible  = NULL ;\n    _succ         = NULL ;\n    _cxq          = NULL ;\n    FreeNext      = NULL ;\n    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表\n    _SpinFreq     = 0 ;\n    _SpinClock    = 0 ;\n    OwnerIsThread = 0 ;\n  }\n```\n\n1. MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁\n2. MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit\n\n当多个线程同时访问一段同步代码时：\n\n1. 首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；\n2. 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；\n3. 若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；\n\n![](/assets/2025116145913.webp)\n\n### 锁升级\n\n1. 在 markword 中记录记录获取锁的这个线程ID 此时是偏向锁。线程通过判断这个ID是否为自身来判断自己是不是获得了偏向锁。偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能，是JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现\n\n但如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘\n\n```sh\n# 关闭偏向锁\n-XX:UseBiasedLocking=false\n```\n\n2. 如果发现 markword 的不是自己的线程 ID 则升级为自旋锁\n3. 在自旋一定次数以后，不能获得锁，则升级为OS层面的重量级锁\n\n- 执行时间短（加锁代码），线程数少，用自旋\n- 执行时间长，线程数多，用系统锁\n\n### 锁降级\n\n锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级\n\n## 锁\n\n### 非阻塞同步\n\n互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步\n\n悲观的并发策略：认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁\n\n乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施\n\n### 悲观锁 乐观锁\n\n- 乐观锁\n\n总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现\n\n```sql\nupdate table set x=x+1, version=version+1 where id=${id} and version=${version};\n```\n\n- 悲观锁\n\n总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起\n\nsynchronized是悲观锁\n\n### 自旋锁\n\n> 线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待\n\n在JDK9之后新增了 Thread.onSpinWait()，这是针对短期等待的性能优化技术，没有任何行为上的保证，而是对 JVM 的一个暗示，JVM 可能会利用 CPU 的 pause 指令进一步提高性能\n\n```java\nclass EventHandler {\n  volatile boolean eventNotificationNotReceived;\n  void waitForEventAndHandleIt() {\n      while ( eventNotificationNotReceived ) {\n          java.lang.Thread.onSpinWait();\n      }\n      readAndProcessEvent();\n  }\n\n  void readAndProcessEvent() {\n      // Read event from some source and process it\n       . . .\n  }\n}\n```\n\n### 分布式锁\n\n- zookeeper与redis实现\n\n## volatile\n\n任何对被volatile关键字修饰的变量都会在主内存操作　不会操作副本\n\nvolatile变量操作时需要同步给内存变量　所以一定会使线程的执行速度变慢\n\n而锁机制通过读入副本　释放锁写入主内存来包装可见性\n\n- 保证线程可见性\n  - [MESI](/计算机系统/程序结构和执行/存储器层次结构.md#MESI) 缓存一致性协议\n  - 虽然 CPU 有一些机制来保证缓存一致性，但这种保证需要数据被写入主存才算对写入的完成，这能确保其他线程看到修改后的数据，但同时也增加了性能的负担，所以只有声明了 volatile 的变量才会保证可见性\n- 禁止指令重排序\n  - DCL(double check lock) 单例\n\n重排序的3种类型：\n\n1. 编译器重排\n2. 指令并行重排\n3. 内存系统重排\n\n### 可见性\n\n在没有同步的情况下，编译器或者处理器都会对一些上下文无关的指令进行**重排序**，这可能会导致一个线程修改了某一个数值，而另一个线程无法马上读取到修改后的数值\n\n- 失效数据\n- 非原子的64位操作\n\n  > 在java当中，一个64位大小的数值可以被分为2个32位的操作\n\n在Java内存结构中，既然堆是共享的，为什么在堆中会有内存不可见问题。现在计算机CPU为了高效，往往会在高速缓存区中缓存共享变量\n\n为什么要重排序？还是为了性能，流水线技术的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2\n\n### 加锁与可见性\n\n![](/assets/202339161714.png)\n\n之所以要在访问某个共享的可变变量时要求所有线程在锁上同步，就是为了确保读写可见性。 加锁的含义不局限与互斥行为，还包括内存可见性\n\nvolatile是比synchronized更为轻量级的同步机制，它无法进行互斥操作，但能保证内存可见性\n\n- 典型用法\n\n```java\nvolatile boolean f;\n\nwhile (f){\n    // do something\n}\n```\n\n## CAS\n\n- AtomicInteger 等原子类的实现\n\n```mermaid\nstateDiagram-v2\n  开始 --> 读取当前值E\n  读取当前值E --> 计算结果值V\n  计算结果值V --> 比较E和当前新值N\n  比较E和当前新值N --> 更新为新值V: 相等(存在ABA问题：其他线程修改数次后值和原值相同)\n  比较E和当前新值N --> 读取当前值E: 不相等(其他线程修改为不同值)\n  更新为新值V --> 结束\n```\n\n它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程进行自旋重复上述操作或者什么都不做。最后，CAS返回当前V的真实值\n\nCAS是CPU原语支持 Java 通过native方法调用汇编指令来实现\n\n```java\n// 模拟CAS实现\nint synchorized cas(int e, int n) {\n  int oldValue = value;\n  if (oldValue == e) value = n\n  return oldCount\n}\n```\n\n### ABA问题\n\n如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过\n\n解决方法：版本号\n\n在大多数情况下 ABA问题并不会影响到程序的正确性\n\n使用**AtomicStampedReference**实现\n\n### 自旋开销\n\nCAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。\n\n让JVM支持处理器的pause指令可以解决这个问题。\n\n在Java层，也可以通过手动yield线程或者sleep来解决\n\n### 非阻塞算法\n\n> 在某个算法内，一个线程的失败或挂起不会导致其他线程的失败或挂起\n\n## unsafe类\n\n直接操作JVM里的内存\n\n**JDK9之后无法使用了**\n\n- allocateMemory 直接分配内存\n- freeMemory  释放内存\n- compareAndSet CAS操作\n\n## Java 与协程\n\n- Java 内核线程的局限性\n\n内核线程1:1映射到Java上，当面对大量请求时，线程切换的成本开销远远大于计算本身的开销\n\n协程的主要优势是轻量，一个协程的实现特例被称之为纤程\n\n新并发模型下，一段使用纤程并发的代码会被分为两部分——执行过程（Continuation）和调度器（Scheduler）。执行过程主要用于维护执行现场，保护、恢复上下文状态，而调度器则负责编排所有要执行的代码的顺序\n","metadata":"","hasMoreCommit":true,"totalCommits":22,"commitList":[{"date":"2025-01-16T15:07:32+08:00","author":"MY","message":"📦JVM synchronized 的实现机制说明","hash":"dc6cb2becd843dee01d233c1454b2633a2fae4c3"},{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2024-04-18T19:57:58+08:00","author":"MY","message":"✏C","hash":"768831c0911695fdad43e9f2c7a309a84681ce36"},{"date":"2023-03-09T09:41:00Z","author":"My","message":"🛠替换在线图片","hash":"0c8b08bc22fbe482ba02da2f1fcad211441d3c23"},{"date":"2022-10-19T21:32:18+08:00","author":"MY","message":"✏️Java并发编程","hash":"5ec012b5f65756ede6a0402ff1eb8eba6b398a9e"},{"date":"2022-07-05T21:20:38+08:00","author":"MY","message":"✏️更新 存储器层次结构","hash":"5ef7020f0bef151a54c5ef31450ff9b94be176bf"},{"date":"2022-04-20T14:43:20+08:00","author":"cjiping","message":"✏️更新 CAS","hash":"d31b3f12d50d95b81edcbcaebdaaf8e71d129859"},{"date":"2022-04-20T14:14:15+08:00","author":"cjiping","message":"✏️更新 Java 并发编程","hash":"139a434842de21a31449bfbf45f1d75ea00bb70d"},{"date":"2022-03-03T16:37:20+08:00","author":"cjiping","message":"✏️更新 并发编程","hash":"67cd71314d45559707dabd49be9a05691da559a9"},{"date":"2021-09-09T16:04:56+08:00","author":"cjiping","message":"📦整理 Java 线程","hash":"38a99898a4b35a1db75c1e0e87df2defb5ce7525"}],"createTime":"2020-06-17T14:33:54+08:00"}