{"name":"并发工具类","id":"编程语言-JAVA-JAVA并发编程-并发工具类","content":"# JUC\n\nJ.U.C java.util.concurrent\n\n主要分为几个类簇：\n\n- 线程同步类　使进程间的协调更加容易　CountDownLatch CyclicBarrier等\n- 并发集合类\n- 线程管理类　线程池等\n- 锁相关类　\n\n## ReentrantLock\n\n- 语义同 synchronized 锁，可重入互斥锁\n- 构造器接受 fairness 的参数，fairness 是 ture 时，保证获得锁时的顺序，false 不保证\n\n轻量级锁与重量级锁:“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的\n\nReentrantLock 和synchronized 都是 可重入锁\n\n可重入 是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响\n\n```java\ntry {\n    lock.lock();\n    // do something\n} catch (Exception e){\n    e.printStackTrace();\n}finally {\n    lock.unlock();\n}\n```\n\n- 尝试加锁\n\n```java\nlock.tryLock() // 可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待\n```\n\n- 可打断的加锁\n\n```java\nlock.lockInterruptibly(); // 可以通过interrupt()打断\n```\n\n- 公平锁\n\n公平锁：每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁\n\n非公平锁：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关\n\n```java\nnew ReentrantLock(true); // true为公平锁\n```\n\n为什么需要非公平锁：在竞争激烈的情况下，唤醒等待线程的开销会很高，基本上是一种等待-获取-等待-获取的串行的局面，无法很好地利用并发性\n\n### synchronized vs ReentrantLock \n\n- synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的\n- 新版本java 两者性能大致相同\n- ReentrantLock 可中断，而 synchronized 不行\n- synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的\n- ReentrantLock 可以同时绑定多个 Condition 对象\n- synchronized 是基于代码块的方式 是由虚拟机自动帮开发人员释放锁 而 ReentrantLock 的加锁释放锁更加灵活但同时也更加危险\n\n应该优先选择synchronized:\n\n- synchronized的锁释放是自动的\n- jvm天生支持\n\n### 类层次结构\n\n```mermaid\nclassDiagram\n    Lock <|-- ReentrantLock\n    ReentrantLock *-- NonfairSync\n    ReentrantLock *-- Sync\n    ReentrantLock *-- FairSync\n    Sync <|-- NonfairSync\n    Sync <|-- FairSync\n```\n\n### 同步器\n\n- 非公平地获取锁\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    // 代表锁还没被获取\n    if (c == 0) {\n        // 设置状态标记获取锁\n        if (compareAndSetState(0, acquires)) {\n            // 标记获取锁的线程是当前线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 锁已经被获取了，并且获取锁的线程是当前线程\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        // 设置锁的状态+1\n        setState(nextc);\n        return true;\n    }\n    // 加入等待队列\n    return false;\n}\n```\n\n- 尝试释放锁\n\n```java\nprotected final boolean tryRelease(int releases) {\n    // 释放锁后线程持有的锁数\n    int c = getState() - releases;\n    // 当前的线程没有持有锁\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    // 锁释放完了\n    if (c == 0) {\n        // 可以让其他线程获取锁\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    // 如果锁没有释放完，设置state为当前线程持有的锁数\n    setState(c);\n    return free;\n}\n```\n\n### FairSync公平锁\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    // 锁没有被持有\n    if (c == 0) {\n        // 如果当前线程处于同步队列的头节点，则获取锁成功，否则等待\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 锁被当前线程持有，重入\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    // 锁被其他线程持有，等待\n    return false;\n}\n```\n\n### NonfairSync非公平锁\n\n这里的非公平锁tryAcquire实现就是上面同步器sync中的实现\n\n## ReentrantReadWriteLock\n\n当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞\n\n当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁\n\n```java\nclass Cache {\n    private Map<String, Object> cache = new HashMap<>();\n    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public void put(String key, Object value) {\n        ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();\n        writeLock.lock();\n        cache.put(key, value);\n        writeLock.unlock();\n    }\n\n    public Object get(String key) {\n        ReentrantReadWriteLock.ReadLock readLock = lock.readLock();\n        readLock.lock();\n        Object value = cache.get(key);\n        readLock.unlock();\n        return value;\n    }\n}\n```\n\n关于读写锁的一些问题：\n\n- 释放优先：当一个线程释放写锁时，那么应该优先选择下一个读线程还是写线程，还是最先发出操作的线程\n- 读线程插队：如果锁当前被一些读线程持有，但有一个写线程在等待，那么新到达的读线程是应该插队写线程还是老老实实排在写线程后面\n- 重入性：读取和写入的锁是否可重入\n- 降级：如果一个线程持有写锁，那么它能不能直接获取读锁\n- 升级：如果一个线程持有读锁，那么它能不能优先于其他正在等待的线程获取写锁\n\n## CountDownLatch(闭锁)\n\n> 确保某些活动直到其他活动都完成后才继续执行\n\n![202031219448](/assets/202031219448.png)\n\n其最大的作用不是为了加锁，而是通过计数达到等待的功能，主要有两种形式的等待：\n\n- 让一组线程在全部启动完成之后，再一起执行\n- 主线程等待另外一组线程都执行完成之后，再继续执行\n\n```java\nCountDownLatch latch = new CountDownLatch(5);\n\nfor (int i = 0; i < 5; i++) {\n    int finalI = i;\n    new Thread(()->{\n        Random random = new Random();\n        try {\n            Thread.sleep(random.nextInt(5000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"线程\"+ finalI +\"完成\");\n        lock.latch();\n    }).start();\n}\n\nlatch.await();\nSystem.out.println(\"all mission complete\");\n```\n\n### await\n\n```java\n// await方法的实现是获取共享锁，如果获得后就返回，否则就等待\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n// 这里sync判断能否获得锁的标志是state是否=0\nprotected int tryAcquireShared(int acquires) {\n    return (getState() == 0) ? 1 : -1;\n}\n```\n\n### countDown\n\n```java\n// countDown的实现就是释放一个锁\npublic void countDown() {\n    sync.releaseShared(1);\n}\n// sync判断能否释放锁的标志是 释放这次锁之后，锁的个数为0\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        int c = getState();\n        // 已经没有锁了\n        if (c == 0)\n            return false;\n        int nextc = c - 1;\n        if (compareAndSetState(c, nextc))\n            return nextc == 0;\n    }\n}\n```\n\n## CyclicBarrier（栅栏）\n\n>闭锁用于等待事件，而栅栏用于等待其他线程\n\n![2020312194816](/assets/2020312194816.png)\n\n```java\nCyclicBarrier barrier = new CyclicBarrier(5, () -> System.out.println(\"all thread run\"));\n// 调用await的线程会进行等待，直到第5个线程调用await，所有线程才会继续执行\nfor (int i = 0; i < 5; i++) {\n    new Thread(() -> {\n        Random rnd= new Random();\n        try {\n            Thread.sleep(rnd.nextInt(3000));\n            System.out.println(Thread.currentThread()+\"run\");\n            barrier.await();\n        } catch (InterruptedException | BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }).start();\n}\n```\n\n## phaser\n\n## Semaphore(信号量)\n\n> 用来控制使用资源的主体数量\n\n```java\nSemaphore semaphore = new Semaphore(5);\n// Semaphore semaphore = new Semaphore(5,true); 公平的信号量\n// 最多只有5个线程能同时运行\nfor (int i = 0; i < 10; i++) {\n    new Thread(()->{\n        Random rnd = new Random();\n\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread()+\"acquire lock\");\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            semaphore.release();\n        }\n    }).start();\n}\n```\n\n## Exchanger\n\n两个线程交换数据\n\n```java\nExchanger<String> exchanger = new Exchanger<>();\n\nnew Thread(()->{\n    try {\n        System.out.println(\"1st:\"+exchanger.exchange(\"1\"));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}).start();\nnew Thread(()->{\n    try {\n        System.out.println(\"2nd:\"+exchanger.exchange(\"2\"));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}).start();\n```\n\n## StampedLock\n\n先试着读，然后通过 validate 方法确认是否进入了写模式，如果没有进入，就成功避免了获取锁的开销\n\n```java\n\npublic class StampedSample {\n  private final StampedLock sl = new StampedLock();\n\n  void mutate() {\n      long stamp = sl.writeLock();\n      try {\n          write();\n      } finally {\n          sl.unlockWrite(stamp);\n      }\n  }\n\n  Data access() {\n      long stamp = sl.tryOptimisticRead();\n      Data data = read();\n      if (!sl.validate(stamp)) {\n          stamp = sl.readLock();\n          try {\n              data = read();\n          } finally {\n              sl.unlockRead(stamp);\n          }\n      }\n      return data;\n  }\n  // …\n}\n```\n\n## LockSupport\n\n```java\nvar t = new Thread(()->{\n    for (int i = 0; i < 10; i++) {\n        if (i == 5){\n            // 暂停线程\n            LockSupport.park();\n        }\n        System.out.println(i);\n    }\n});\nt.start();\nThread.sleep(3000);\n// 继续线程 可以在park之前调用\nLockSupport.unpark(t);\n```\n\n## VarHandle\n\n- 支持一些原子操作\n\n```java\npublic class Main {\n    int x = 8;\n    public static void main(String[] args) throws Exception{\n        Main main = new Main();\n        VarHandle varHandle = MethodHandles.lookup().findVarHandle(Main.class,\"x\",int.class);\n        varHandle.compareAndSet(main,8,9);\n        System.out.println(varHandle.get(main));\n    }\n}\n```\n\n## ThreadLocal\n\n供了一种方式，让在多线程环境下，每个线程都可以拥有自己独特的数据，并且可以在整个线程执行过程中，从上而下的传递\n\n```java\nThreadLocal<String> tl = new ThreadLocal<>();\nvar t1 = new Thread(()->{\n    tl.set(\"cxk\");\n    System.out.println(tl.get()); // \"cxk\"\n});\nvar t2 = new Thread(()->{\n    System.out.println(tl.get()); // null\n});\nt1.start();\nt1.join();\nt2.start();\n```\n\n使用ThreadLocal包装的对象只能在当前线程使用\n\n![截图录屏_选择区域_20200925150807](/assets/截图录屏_选择区域_20200925150807.png)\n\n原理: <https://ismy.wang/java/2019/05/10/%E5%88%9D%E6%8E%A2ThreadLocal.html>\n\nThreadLocal使用了弱引用防止内存泄漏\n\n注意：使用时，对象不再使用，必须手动remove，否则在使用线程池的情况下，线程如果没有被销毁，会产生内存泄漏\n\n### 属性\n\n```java\n// 表示当前ThreadLocal在全局map中的存放位置\nprivate final int threadLocalHashCode = nextHashCode();\n// 它的hashCode是通过一个原子整数不断递增的形式给出的，这样可以保证每台机器的每一个ThreadLocal都有唯一的hashCode\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\n// 用来存放各个ThreadLocal对应的数据\nstatic class ThreadLocalMap {\n    ...\n}\n```\n\n### set\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    // 获取当前线程的一个map\n    ThreadLocalMap map = getMap(t);\n    // 向map里面放数据（如果map为空，则创建map）\n    if (map != null) {\n        map.set(this, value);\n    } else {\n        // 这里创建map的时候，创建后会存入value\n        createMap(t, value);\n    }\n}\n// 也就是说每个线程都拥有一张map，这张map的可是ThreadLocal，这样当使用ThreadLocal存取数据时，就会通过ThreadLocal来在这张map上set/get数据\n```\n\n### get\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    // 获取map进行get\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n```\n\n### 应用\n\n```java\n// 获取当前的请求\nRequestContextHolder.getCurrentRquest();\n```\n\n### 副作用\n\n1. 线程池复用线程会导致ThreadLocal 也被重用　从而会导致脏数据的产生\n2. 如果使用static修饰ThreadLocal　这个时候弱引用就无法防止内存泄露了\n\n解决上面这些问题只需要使用的时候注意remove即可\n\n### InheritableThreadLocal\n\n使用 InheritableThreadLocal，可以在子线程中获取到父线程中的 ThreadLocal 变量\n\n其原理是子线程在初始化时，会去获取父线程的 ThreadLocalMap 来作为自己的 ThreadLocalMap\n\n### TransmittableThreadLocal\n\n在使用 TransmittableThreadLocal 时，它在将值保存到父类 InheritableThreadLocal 中的同时，会将当前的 TransmittableThreadLocal 实际进行存储，这样使用完成后，它自己就会维护一份所有用到的TransmittableThreadLocal 实例，不管它是用户信息的，还是其他信息的实例\n\n有了上面维护的信息，就可以借助Transmitter来对其中的数据进行操作，一般操作步骤如下\n\n- 主线程：调用Transmitter.capture，将当前主线程中的所有TransmittableThreadLocal和值进行快照保存(Map结构，结果要作为value进行存储，否则其他线程取不到TransmittableThreadLocal的value值)\n- 子线程：调用Transmitter.replay，用于将之前保存的所有TransmittableThreadLocal实例及其值重新设置一下（需要借助之前保存的map结构，因为TransmittableThreadLocal中的数据是线程隔离的），并将当前线程的所有TransmittableThreadLocal实例进行备份返回\n- 子线程：业务代码执行完毕之后调用Transmitter.restore，用于将之前备份的数据进行恢复，原理同replay方法\n\n```mermaid\nsequenceDiagram\n    participant Biz Code\n    participant Runnable\n    participant TtlRunnable\n    participant ThreadPool\n    participant TransmittableThreadLocal\n    participant Transmitter\n\n    Biz Code ->> TransmittableThreadLocal: createTtl()\n    Biz Code ->> TransmittableThreadLocal: setTtlValue()\n    Biz Code ->> Runnable: createBizTaskRunnable()\n    Biz Code ->> TtlRunnable: createTtlRunnableWrapper(Runnable)\n    TtlRunnable ->> Transmitter: captureAllTtlValues()\n    Transmitter ->> TransmittableThreadLocal: get()\n    Transmitter ->> TransmittableThreadLocal: copy(value:T)\n    Biz Code ->> ThreadPool: submitTtlRunnableToThreadPool()\n    ThreadPool ->> TtlRunnable: run()\n    TtlRunnable ->> TransmittableThreadLocal: beforeExecute()\n    TtlRunnable ->> Transmitter: replayCapturedTtlValues()\n    TtlRunnable ->> Runnable: run()\n    Runnable ->> TransmittableThreadLocal: useValueInTTL()\n    TtlRunnable ->> Transmitter: restoreTtlValuesBeforeReplay()\n    TtlRunnable ->> TransmittableThreadLocal: afterExecute()\n\n```\n\n## 锁的原理（AQS AbstractQueuedSynchronizer）\n\nAQS 是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现，比如我们在 lock 的时候，AQS 开放出 state 字段，让子类可以根据 state 字段来决定是否能够获得锁，对于获取不到锁的线程 AQS 会自动进行管理，无需子类锁关心\n\n![方法分层](/assets/202511691737.png)\n\nAQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。\n\n> CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。\n\n![独占模式下的流程](/assets/202511610958.png)\n![共享模式下的流程](/assets/2025116101420.png)\n\n### 整体架构\n\n![20202251401](/assets/20202251401.webp)\n\n### 属性\n\n```java\n// 这个状态用来判断是否可以获得锁，每次获得锁时+1，释放锁-1\n// 当子类继承AQS来实现锁时，要根据这个状态判断能否获得锁(为0才能获得)跟释放锁(为1才能释放)\nprivate volatile int state;\n\n// 同步队列的头与尾,底层是一个双向链表，用来阻塞获取不到锁的线程，并在适当时机释放这些线程\nprivate transient volatile Node head;\nprivate transient volatile Node tail;\n\n// 条件队列，管理获取不到锁的线程，但条件队列不直接和锁打交道，但常常和锁配合使用\npublic class ConditionObject implements Condition, java.io.Serializable {\n    // Condition 可以用来代替 Object 中相应的监控方法\n    // 它提供了一种线程协作方式，并且都有明确语义\n    \n    /** First node of condition queue. */\n    private transient Node firstWaiter;\n    /** Last node of condition queue. */\n    private transient Node lastWaiter;\n}\n\nstatic final class Node {\n    ...\n    volatile int waitStatus;\n    // 在共享锁中用来表示下一个等待线程，排它锁则用来表示当前节点是共享还是排它模式\n    Node nextWaiter;\n}\n```\n\n### 获取锁\n\n- 排它锁\n\n```java\n// 排它模式下，尝试获得锁\npublic final void acquire(int arg) {\n    // tryAcquire让子类实现的，思路一般是根据state的值决定是否能获取到锁\n    if (!tryAcquire(arg) &&\n        // 如果获取不到就调用addWaiter让线程进入同步队列，然后acquireQueued这个方法代表进入之后会阻塞，直到被唤醒获得锁\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        // 获取锁失败，打断自身\n        selfInterrupt();\n}\n// 追加到同步队列的队尾\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(mode);\n        \n    for (;;) {\n        Node oldTail = tail;\n        // 如果队尾不为空，就将node插入到队尾\n        if (oldTail != null) {\n            // 将原来队尾的node设置为新加入node的prev\n            node.setPrevRelaxed(oldTail);\n            // 原子方式将node设置为队尾\n            if (compareAndSetTail(oldTail, node)) {\n                oldTail.next = node;\n                return node;\n            }\n        // 队尾为空，需要初始化同步队列\n        } else {\n            initializeSyncQueue();\n        }\n    }\n}\n// 阻塞当前线程\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean interrupted = false;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            // 如果这个当前线程节点的前置节点是头节点，并且自己已经能获得锁了\n            if (p == head && tryAcquire(arg)) {\n                // 将自己设置为头节点\n                setHead(node);\n                p.next = null; // help GC\n                // 然后返回\n                return interrupted;\n            }\n            // 前一个节点状态为SIGNAL了，那么就阻塞自己(park)\n            if (shouldParkAfterFailedAcquire(p, node))\n                interrupted |= parkAndCheckInterrupt();\n        }\n    } catch (Throwable t) {\n        cancelAcquire(node);\n        if (interrupted)\n            selfInterrupt();\n        throw t;\n    }\n}\n```\n\n- 共享锁\n\n```java\npublic final void acquireShared(int arg) {\n    // 同样由子类实现\n    if (tryAcquireShared(arg) < 0)\n        // 里面的这个方法主要做的是不断自旋直到获取到锁，当获取到锁之后，会通知排在它后面的节点\n        doAcquireShared(arg);\n}\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);\n    boolean interrupted = false;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            // 当前节点的前置节点如果是头节点\n            if (p == head) {\n                // 尝试获取锁\n                int r = tryAcquireShared(arg);\n                // 获取锁成功\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node))\n                interrupted |= parkAndCheckInterrupt();\n        }\n    } catch (Throwable t) {\n        cancelAcquire(node);\n        throw t;\n    } finally {\n        if (interrupted)\n            selfInterrupt();\n    }\n}\n```\n\n### 释放锁\n\n- 排它锁\n\n```java\npublic final boolean release(int arg) {\n    // 同样留给子类实现判断是否能释放锁\n    if (tryRelease(arg)) {\n        Node h = head;\n        // 后面有一些等待唤醒的节点\n        if (h != null && h.waitStatus != 0)\n            // 从头开始唤醒等待锁的节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n- 共享锁\n\n```java\npublic final boolean releaseShared(int arg) {\n    // 基本跟上面一样\n    if (tryReleaseShared(arg)) {\n        // 唤醒后面的线程\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n\n### 条件队列\n\n- 入队列等待 await\n\n获得锁的线程，如果在碰到队列满或空的时候，就会阻塞住，这个阻塞就是用条件队列实现的，这个动作我们叫做入条件队列\n\n- 单个唤醒 signal\n\n之前队列满了，有了一些线程因为 take 操作而被阻塞进条件队列中，突然队列中的元素被线程 A 消费了，线程 A 就会调用 signal 方法，唤醒之前阻塞的线程\n","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2025-01-16T11:26:35+08:00","author":"MY","message":"📦AQS","hash":"00504fafc1113a39b1f62fbe29065cb755a3e699"},{"date":"2024-08-28T19:28:47+08:00","author":"MY","message":"✏并发工具类","hash":"6c22e5bbff176dc1fb35424a932b6b81d83018df"},{"date":"2024-06-05T14:47:56+08:00","author":"MY","message":"✏并发","hash":"7c6ef9e57ea5c46ce3933e394560d07213d85163"},{"date":"2022-10-19T21:32:18+08:00","author":"MY","message":"✏️Java并发编程","hash":"5ec012b5f65756ede6a0402ff1eb8eba6b398a9e"},{"date":"2022-04-18T16:44:54+08:00","author":"cjiping","message":"✏️更新 并发工具类","hash":"27706afe8d550424a937ed9973bc0ea796246272"},{"date":"2021-09-10T15:44:58+08:00","author":"cjiping","message":"📦整理 Java 并发工具类","hash":"f46e45c586d3c4fd71a48eeb86f687259ca00432"},{"date":"2021-09-09T16:04:56+08:00","author":"cjiping","message":"📦整理 Java 线程","hash":"38a99898a4b35a1db75c1e0e87df2defb5ce7525"},{"date":"2020-09-25T15:12:19+08:00","author":"0xcaffebabe","message":"✏更新 Java 并发编程 ThreadLocal","hash":"df8757284b174352df4ee22dcf927cc72e2a6527"},{"date":"2020-09-25T09:39:46+08:00","author":"0xcaffebabe","message":"✏更新 Java 并发编程","hash":"54d32ef65c048167e76f6d3c49420e88c0c691c6"},{"date":"2020-07-03T14:56:05+08:00","author":"MY","message":"更新 线程池","hash":"b3178e3d0305b3c1c4db3153cf534aa72fe14eeb"}],"createTime":"2020-06-23T16:24:52+08:00"}