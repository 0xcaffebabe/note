# 并发编程设计模式

## 单线程执行模式（Single Threaded Execution）

- 临界区

通过对代码块进行同步，使之同一时刻只能有一个线程执行，以此确保安全性

## 不可变模式（Immutable）

将对象的所有状态设计成无法变化就可以确保安全性。

达到这个目的的常用手段有final修饰类、变量以及不暴露相关修改状态的接口。

## 守卫暂停模式（Guarded Suspension）

通过让线程进行等待来保证对象实例的安全性

锁获取 阻塞队列等都是属于这种模式

等待可以通过Object.wait方法 获取也可以使用自旋锁的忙等待

## Balking

通过维护一个守护条件，当守护条件不满足时，将直接返回，后续的所有操作放弃

与守卫暂停模式的区别在守卫暂停会一直等待守护条件成立，而Balking当不成立时就放弃

在这两者之间可以存在一种等待一段时间放弃的做法，叫做超时

## 生产者-消费者模式（Prdocer-Consumer）

通过加入一个中间层，来消除数据生产者与获取者之间的速度差异带来的安全问题

## 读写锁模式（Read-Write Lock）

数据并发读写没有问题，但要想修改它只能有一个线程，并且没有其他线程进行读操作

适合读多写少的场景，可以有效提升性能

## 每消息一线程模式（Thread-Per-Message）

传统的socket编程就采用的这种方式 一个请求进来 开启一个新线程来处理

## 工作线程模式（Worker Thread）

为了解决没消息一线程频繁开启新新线程带来的开销，通过维护几个工作线程，请求一来直接交给这些工作线程来处理

线程池就属于该模式

## Future模式

持有一个引用 在等待结果时可以不进行阻塞

## 两阶段终结模式（Tow-Phase-Termination）

![屏幕截图 2021-04-02 102529](/assets/屏幕截图%202021-04-02%20102529.png)

通过检查线程中断状态以及自己设计的停止标志配合使用来达到清理与提升吞吐量的目的

检查标志可在进行长时间处理操作之前检查

## 线程特有存储模式（Thread-Specific Storage）

为每个线程分配属于线程自己的存储空间 避免竞争带来的数据安全问题

- 存储在线程外：ThreadLocal
- 存储在线程内：Thread成员变量

## 活跃对象模式（Active Object）

- Actor模式

会通过自己特有的线程在合适的时机消费外部接收到的额异步请求
