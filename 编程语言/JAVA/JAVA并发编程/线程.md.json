{"name":"线程","id":"编程语言-JAVA-JAVA并发编程-线程","content":"# 线程\n\n## 进程与线程\n\n进程是所有线程的集合，每一个线程是进程中的一条执行路径\n\n## 线程API之间的关系\n\n```mermaid\nclassDiagram\n    direction BT\n    FutureTask --|> RunnableFuture\n    RunnableAdapter --|> Callable\n    RunnableAdapter --|> Executors\n    RunnableFuture --|> Future\n    RunnableFuture --|> Runnable\n    Thread --|> Runnable\n```\n\n## 线程分类\n\n- 用户线程\n  - 主线程\n  - 子线程\n- 守护线程\n  - *守护线程当进程不存在或主线程停止，守护线程也会被停止*\n  - GC线程\n\nHotSpot的每一个Java线程都是直接映射到一个操作系统原生线程来实现的\n\n## 创建线程\n\n### 继承Thread类\n\n```java\nclass MyThread extends Thread{\n    @Override\n    public void run() {}\n}\n```\n\n多线程执行时，在栈内存中，每一个执行线程都有一片自己所属的[栈内存](/编程语言/JAVA/JVM/自动内存管理/内存结构.md)空间。进行方法的压栈和弹栈\n\n\nThread类\n\n- public String getName() :获取当前线程名称。\n- public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。\n- public void run() :此线程要执行的任务在此处定义代码。\n- public void yield():让出CPU，返回到就绪状态\n- join：等待被调用join的线程执行完毕再继续运行\n- public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。\n- public static Thread currentThread() :返回对当前正在执行的线程对象的引用\n\n**InterruptedException**\n\n调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞(sleep)、限期等待或者无限期等待(wait)状态，那么就会抛出 InterruptedException，从而提前结束该线程\n\n**interrupted()**\n\n在自定义线程执行任务使，可以使用这个方法作为一个flag，作为是否继续运行的依据\n\n```java\nwhile(interrupted()){\n    // do\n}\n// end\n```\n\n### 实现Runnable接口\n\n**实现Runnable接口比继承Thread类所具有的优势：**\n\n- 适合多个相同的程序代码的线程去共享同一个资源。\n- 可以避免java中的单继承的局限性。\n- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。\n- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。\n\n## Thread相关源码\n\n### 初始化\n\n```java\nprivate Thread(ThreadGroup g , Runnable target, String name,\n                   long stackSize, AccessControlContext acc,\n                   boolean inheritThreadLocals) {\n        if (name == null) {\n            throw new NullPointerException(\"name cannot be null\");\n        }\n\n        this.name = name;\n        // 当前线程作为这条线程的父线程\n        Thread parent = currentThread();\n        // 一些安全检查\n        SecurityManager security = System.getSecurityManager();\n        if (g == null) {\n           \n            if (security != null) {\n                g = security.getThreadGroup();\n            }\n\n            if (g == null) {\n                g = parent.getThreadGroup();\n            }\n        }\n\n        g.checkAccess();\n        // 权限检查\n        if (security != null) {\n            if (isCCLOverridden(getClass())) {\n                security.checkPermission(\n                        SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);\n            }\n        }\n\n        g.addUnstarted();\n        // 设置线程组\n        this.group = g;\n        // 继承父线程的一些属性，包括是否是守护线程、线程优先级等\n        this.daemon = parent.isDaemon();\n        this.priority = parent.getPriority();\n        if (security == null || isCCLOverridden(parent.getClass()))\n            this.contextClassLoader = parent.getContextClassLoader();\n        else\n            this.contextClassLoader = parent.contextClassLoader;\n        this.inheritedAccessControlContext =\n                acc != null ? acc : AccessController.getContext();\n        this.target = target;\n        // 设置线程优先级\n        setPriority(priority);\n        if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n            this.inheritableThreadLocals =\n                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n        // 设置线程栈大小\n        this.stackSize = stackSize;\n\n        /* Set thread ID */\n        this.tid = nextThreadID();\n    }\n```\n\n### 启动\n\n```java\npublic synchronized void start() {\n    // 线程并非NEW状态\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n    // 通知线程组加入自身\n    group.add(this);\n            \n    boolean started = false;\n    try {\n        // 调用native方法启动线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            // 如果启动失败，通知线程组启动失败\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n### join\n\njoin 的意思就是当前线程(currentThread)等待另一个线程(调用join的那个线程)执行完成之后，才能继续操作\n\n```java\npublic final synchronized void join(final long millis)\nthrows InterruptedException {\n    if (millis > 0) {\n        // 判断自身是否已执行完毕，\n        if (isAlive()) {\n            // 如果还未完毕等待一定的时间\n            final long startTime = System.nanoTime();\n            long delay = millis;\n            do {\n                wait(delay);\n            } while (isAlive() && (delay = millis -\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);\n        }\n    // 无限等待\n    } else if (millis == 0) {\n        // 原理就是自旋判断自身是否已经执行完毕\n        while (isAlive()) {\n            // 如果还未执行完毕，则进入wait\n            wait(0);\n        }\n    } else {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n}\n```\n\n## 线程调度\n\n- Java 使用的抢占式调度多线程系统\n\n可以通过Thread实例setPriority来调整优先级，不过此举总体而言不是一个稳定的调节手段\n\n## 线程状态\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    state RUNNABLE {\n        READY --> RUNNING: 线程被调度器选中\n        RUNNING --> READY: 线程被挂起/yield\n    }\n    NEW --> RUNNABLE: start()\n    RUNNABLE --> TERMINATERD: 运行结束或异常退出\n    RUNNABLE --> WAITING: Object.wait()/Thread,join()/LockSupport.park()\n    WAITING --> RUNNABLE: Object.notify()/Object.notifyAll()/LockSupport.unpark()\n    RUNNABLE --> BLOCKED: 阻塞IO/synchorized\n    BLOCKED --> RUNNABLE: 获得锁\n    RUNNABLE --> TIME_WAITING: Thread.sleep()/Object.wait()/LockSupport.parkUntil()\n    TIME_WAITING --> RUNNABLE: 超时/Object.notify()/Object.notifyAll()\n```\n\n线程状态                | 导致状态发生条件\n------------------- | -------------------------------------------------------------------------------------------------------------\nNEW(新建)             | 线程刚被创建，但是并未启动。还没调用start方法。\nRunnable(可运行)       | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。\nBlocked(锁阻塞)        | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。\nWaiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。\nTimed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。\nTeminated(被终止)      | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。\n\n## 虚拟线程\n\n在没有虚拟线程之前，创建平台线程是很耗费资源的一种操作，如果应用程序使用[每请求一线程](/编程语言/并发模型.md#每消息一线程模式（Thread-Per-Message）)这种风格的编程方式，并发一般到几百就上不去了，大量线程都阻塞浪费在等待 IO 上了\n\n虚拟线程可以让使用这种编程风格的代码变得更充分利用资源\n\n```java\ntry (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n    for (int i = 0; i < 10000; i++) {\n        executorService.execute(() -> {\n            try {\n                URLConnection urlConnection = new URL(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\").openConnection();\n                urlConnection.connect();\n                InputStream inputStream = urlConnection.getInputStream();\n                System.out.println(inputStream.readAllBytes().length);\n                inputStream.close();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n}\n```\n\n虚拟线程执行并不比平台线程快，同样都是执行代码，虚拟线程执行代码依托于平台线程（carrier），当虚拟线程碰到阻塞操作时，就会从平台线程上被卸载，此时 Java 的任务窃取调度器就会再选择一条新的虚拟线程安装到平台线程上进行调度，当阻塞操作完成，虚拟线程就可以提交到调度队列中，等待一下次被运行\n\n但遇到 Object.wait 、synchorized 代码块等，受限于操作系统，执行这些操作的虚拟线程还是会被阻塞\n\n由于虚拟线程的创建代价很小，所以不必对虚拟线程进行池化操作\n","metadata":"","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2024-11-01T17:09:50+08:00","author":"MY","message":"✏线程 API 之间的关系图","hash":"0f26bd0cb7ba25c89ec28aa1dd76c356ca3a1ccf"},{"date":"2023-09-20T17:13:50+08:00","author":"MY","message":"✏线程","hash":"15fea6ddb96ad6935376a992804262c53567cdf1"},{"date":"2022-10-19T21:32:18+08:00","author":"MY","message":"✏️Java并发编程","hash":"5ec012b5f65756ede6a0402ff1eb8eba6b398a9e"},{"date":"2022-03-09T17:46:16+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"05cdd8647ade510badf68feae84d459e83c2b943"},{"date":"2021-09-09T16:04:56+08:00","author":"cjiping","message":"📦整理 Java 线程","hash":"38a99898a4b35a1db75c1e0e87df2defb5ce7525"}],"createTime":"2021-09-09T16:04:56+08:00"}