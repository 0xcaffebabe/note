{"name":"线程","id":"编程语言-JAVA-JAVA并发编程-线程","content":"# Java 线程\n\n## 一、并发的第一性问题：为什么需要线程？\n\n在任何并发系统中，都必须回答三个根本问题：\n\n1. **执行单元是什么？**（谁在运行）\n2. **如何被调度？**（谁决定何时运行）\n3. **如何等待与协作？**（如何处理依赖与阻塞）\n\n### 1.1 执行单元的抽象\n\n> **线程 = 可被调度的最小执行上下文**\n\n一个线程本质上由以下要素构成：\n\n* 执行栈（方法调用与局部变量）\n* 程序计数器（当前执行位置）\n* 寄存器快照（CPU 上下文）\n* 阻塞 / 唤醒语义（等待条件）\n\n线程并不拥有资源，**资源属于进程**；线程只是共享资源上的执行路径。\n\n---\n\n## 二、进程与线程：资源与执行的分离\n\n### 2.1 进程的本质角色\n\n> **进程 = 资源容器**\n\n* 地址空间\n* 文件句柄\n* 网络连接\n* 安全上下文\n\n### 2.2 线程的本质角色\n\n> **线程 = 调度与执行的载体**\n\n同一进程内的线程：\n\n* 共享内存\n* 独立栈\n* 独立调度\n\n这正是 Java 并发模型选择“共享内存 + 线程”的根本原因。\n\n---\n\n## 三、Java 线程模型的设计哲学\n\n### 3.1 Java 为什么直接建模 Thread？\n\nJava 选择 Thread 作为一等公民，背后隐含了三条设计哲学：\n\n1. **拥抱操作系统调度**（而非自建调度器）\n2. **阻塞是合法且可表达的语义**\n3. **并发通过共享内存完成，而非消息复制**\n\n这决定了：\n\n* synchronized / wait / notify 的存在\n* Thread 与 OS 线程的一一映射（平台线程）\n\n### 3.2 平台线程模型（传统 Java）\n\n> **Java Thread ≈ OS Native Thread**\n\n特点：\n\n* 创建成本高\n* 阻塞即占用 OS 线程\n* 调度依赖内核\n\n这是 Java 并发长期以来的性能与伸缩性瓶颈。\n\n---\n\n## 四、线程的抽象层次结构（核心升维）\n\n### 4.1 抽象层（稳定、不变）\n\n* 执行上下文\n* 调度\n* 阻塞与唤醒\n\n### 4.2 JVM 实现层（相对稳定）\n\n* Thread 对象\n* 线程状态机\n* wait / park / interrupt\n\n### 4.3 工程使用层（易变）\n\n* Thread / Runnable / Callable\n* 线程池\n* 虚拟线程\n\n> **理解并发的关键，在于始终知道自己处在哪一层。**\n\n---\n\n## 五、Runnable / Callable / Thread：职责拆分模型\n\n### 5.1 核心思想：执行与调度解耦\n\n| 抽象                  | 职责          |\n| ------------------- | ----------- |\n| Runnable / Callable | 描述“要做什么”    |\n| Thread              | 描述“如何被调度执行” |\n\n这是一种典型的 **Command + Executor** 思想。\n\n### 5.2 为什么推荐 Runnable 而非继承 Thread\n\n* 解除继承限制\n* 支持任务复用\n* 天然适配线程池与调度器\n\n> **Thread 是执行载体，不应承载业务逻辑。**\n\n---\n\n## 六、线程生命周期与状态机（行为模型）\n\n### 6.1 状态机的本质意义\n\n线程状态并非 API 细节，而是：\n\n> **调度器与同步原语协作的结果**\n\n核心状态语义：\n\n* RUNNABLE：可被调度\n* BLOCKED：竞争锁失败\n* WAITING / TIMED_WAITING：主动让渡 CPU\n* TERMINATED：生命周期结束\n\n### 6.2 join / wait 的统一原理\n\n* join 本质：**当前线程在目标线程对象上 wait**\n* interrupt 本质：**协作式中断信号，而非强制终止**\n\n并发的安全性来自：\n\n> **约定 + 协作，而非抢占式控制**\n\n---\n\n## 七、线程调度的不可控性原则\n\n### 7.1 抢占式调度的现实\n\n* Java 使用抢占式调度\n* 优先级只是“调度建议”\n\n### 7.2 设计原则\n\n> **不要试图通过 Thread API 精确控制执行顺序**\n\n正确做法：\n\n* 使用同步原语表达依赖\n* 使用并发工具类表达约束\n\n---\n\n## 八、虚拟线程：并发模型的范式升级\n\n### 8.1 虚拟线程解决的根本问题\n\n> **阻塞语义 vs 资源利用率 的长期冲突**\n\n传统模型的问题不是“线程慢”，而是：\n\n* 阻塞 = 占用 OS 线程\n* OS 线程 = 稀缺资源\n\n### 8.2 虚拟线程的本质\n\n> **虚拟线程 = 用户态调度的执行上下文**\n\n关键特征：\n\n* 仍然保留阻塞语义\n* 阻塞时从平台线程卸载\n* 由 JVM 调度到 carrier thread\n\n### 8.3 虚拟线程在并发模型中的位置\n\n| 模型      | 核心思想        | 代价        |\n| ------- | ----------- | --------- |\n| 线程池     | 控制线程数量      | 编程复杂度     |\n| Reactor | 非阻塞 IO      | 心智负担      |\n| 虚拟线程    | 阻塞语义 + 协程调度 | JVM 实现复杂度 |\n\n> **虚拟线程降低了并发编程的门槛，而非替代所有模型。**\n\n---\n\n## 九、统一视角下的线程哲学\n\n### 9.1 Java 并发的核心信条\n\n* 阻塞是合法的\n* 中断是协作的\n* 顺序通过同步表达\n* 性能来自模型选择，而非 API 技巧\n\n### 9.2 面向未来的稳定认知\n\n* Thread 是执行抽象，不是业务模型\n* 并发能力 = 执行模型 × 调度策略 × 资源成本\n* 虚拟线程是 Java 并发的长期方向\n\n---\n\n## 十、总结\n\n> **线程不是并发的目的，而是并发的一种表达方式。**\n\n理解线程，最终是理解：\n\n* 执行\n* 调度\n* 阻塞\n* 协作\n\n## 关联内容（自动生成）\n\n- [/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md](/编程语言/JAVA/JAVA并发编程/JAVA并发编程.md) Java并发编程的整体概述，与线程作为执行单元的概念密切相关\n- [/编程语言/JAVA/JAVA并发编程/基础概念.md](/编程语言/JAVA/JAVA并发编程/基础概念.md) Java并发编程的基础概念，与线程的基本原理和设计哲学相关\n- [/编程语言/JAVA/JAVA并发编程/线程池.md](/编程语言/JAVA/JAVA并发编程/线程池.md) 线程池是对线程概念的实际应用，用于管理和复用线程资源\n- [/编程语言/JAVA/JAVA并发编程/并发工具类.md](/编程语言/JAVA/JAVA并发编程/并发工具类.md) 并发工具类提供了线程间协作的高级机制，与线程的阻塞和协作密切相关\n- [/编程语言/JAVA/JAVA并发编程/并发集合.md](/编程语言/JAVA/JAVA并发编程/并发集合.md) 并发集合是多线程环境下安全的数据结构，与线程安全和资源共享相关\n- [/编程语言/JAVA/JVM/JVM.md](/编程语言/JAVA/JVM/JVM.md) JVM是Java线程的运行环境，理解JVM有助于深入理解线程的执行机制\n- [/编程语言/JAVA/JAVA并发编程/Disruptor.md](/编程语言/JAVA/JAVA并发编程/Disruptor.md) Disruptor是高性能并发框架，展示了线程并发的高级应用\n- [/编程语言/并发模型.md](/编程语言/并发模型.md) 并发模型提供了多种并发实现方式，与Java线程模型形成对比和补充\n- [/操作系统/进程与线程.md](/操作系统/进程与线程.md) 操作系统层面的进程与线程概念，是理解Java线程的基础\n- [/编程语言/JAVA/JVM/JAVA内存模型.md](/编程语言/JAVA/JVM/JAVA内存模型.md) Java内存模型定义了线程间内存可见性规则，与线程协作密切相关\n\n","metadata":"tags: ['并发编程', '操作系统', '编程语言']","hasMoreCommit":false,"totalCommits":8,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2026-01-08T16:36:52+08:00","author":"MY","message":"docs(java-thread): 重构Java线程文档结构并完善内容","hash":"a7b0dfe9ed0806d1ad9f39f878bf79804c57d616"},{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2024-11-01T17:09:50+08:00","author":"MY","message":"✏线程 API 之间的关系图","hash":"0f26bd0cb7ba25c89ec28aa1dd76c356ca3a1ccf"},{"date":"2023-09-20T17:13:50+08:00","author":"MY","message":"✏线程","hash":"15fea6ddb96ad6935376a992804262c53567cdf1"},{"date":"2022-10-19T21:32:18+08:00","author":"MY","message":"✏️Java并发编程","hash":"5ec012b5f65756ede6a0402ff1eb8eba6b398a9e"},{"date":"2022-03-09T17:46:16+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"05cdd8647ade510badf68feae84d459e83c2b943"},{"date":"2021-09-09T16:04:56+08:00","author":"cjiping","message":"📦整理 Java 线程","hash":"38a99898a4b35a1db75c1e0e87df2defb5ce7525"}],"createTime":"2021-09-09T16:04:56+08:00"}