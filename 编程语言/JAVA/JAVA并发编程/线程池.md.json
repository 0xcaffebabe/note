{"name":"线程池","id":"编程语言-JAVA-JAVA并发编程-线程池","content":"# 线程池\n\n作用：\n\n- 线程复用　控制最大并发数\n- 实现任务缓存策略以及拒绝策略\n- 定期执行　周期执行\n- 隔离不同业务的线程执行环境\n\n解决了两个问题：\n\n1：通过减少任务间的调度开销 (主要是通过线程池中的线程被重复使用的方式)，来提高大量任务时的执行性能；\n2：提供了一种方式来管理线程和消费，维护基本数据统计等工作\n\n线程池决定了任务的执行策略：\n\n- 什么线程\n- 什么顺序\n- 多少任务执行\n- 多少任务等待\n- 如何放弃以及通知放弃\n- 任务执行前操作\n\n## Executor框架\n\n```java\npublic interface Executor {\n  void execute(Runnable command);\n}\n```\n\nExecutorService继承了Executor，增加了一些方法\n\n```java\npublic interface ExecutorService extends Executor {\n    // 平缓关闭\n    void shutdown();\n\n    // 粗暴关闭\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n}\n```\n\n### execute&submit\n\n使用这两个方法一定要注意，execute会将runnable交给worker去执行，出现异常会打印异常栈。\n\n而submit方法则会将runnable包装成一个ScheduledFutureTask 这个类会将异常吞掉，不会打印异常栈。\n\n## Callable\n\n- 拥有返回值\n\n## Future\n\n>用来执行一些较长时间的计算，通过get来获取结果（阻塞或者超时）\n\n用于异步获取执行结果或取消执行任务的场景\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(() -> {\n    int result = 0;\n    for (int i = 0; i < 100; i++) {\n        Thread.sleep(10);\n        result += i;\n    }\n    return result;\n});\nnew Thread(futureTask).start();\nSystem.out.println(futureTask.get());\n```\n\n```java\nFuture<String> future = pool.submit(() -> {\n    Thread.sleep(3000);\n    return \"java\";\n});\nString s = future.get();\n```\n\n### Future模式\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyFuture myFuture = new MyFuture();\n        // 在这里 main thread 可以做其他事情\n        // 下一行代码将阻塞直到结果可用\n        System.out.println(myFuture.getData());\n    }\n}\n\nclass MyFuture{\n    private volatile boolean FLAG = false;\n    private String data;\n\n    public MyFuture() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"future 任务开始 睡眠 3000ms\");\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"future 任务结束\");\n                setData(\"jntm\");\n            }\n        }).start();\n    }\n\n    private synchronized void setData(String data){\n        if (FLAG){\n            return;\n        }\n        this.data = data;\n        FLAG = true;\n        notify();\n    }\n\n    public synchronized String getData(){\n        while (!FLAG){\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return data;\n    }\n}\n```\n\n#### CompletableFuture\n\n使用观察者模式来实现\n\n有意思的是这个类跟Stream的终结流有点像，只有终点调用了取值的操作，整个调用链才会被执行\n\n某些方法可以传递一个线程池参数，当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool（CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程池可能成为瓶颈\n\n```java\n// 此处 cf1 跟 cf2并发\nCompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {\n    sleep(1000);\n    System.out.println(\"cf1\");\n    return \"cf1\";\n});\nCompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {\n    sleep(500);\n    System.out.println(\"cf2\");\n    return \"cf2\";\n});\n// cf3等待c1执行完毕\nCompletableFuture<String> cf3 = cf1.thenApply(result -> {\n    System.out.println(\"cf3\");\n    return \"cf3\";\n});\n// cf4 等待 cf1跟cf2执行完毕\nCompletableFuture<String> cf4 = cf1.thenCombine(cf2, (result1, result2) -> {\n    System.out.println(\"cf4\");\n    return \"cf4\";\n});\n// cf5等待cf2执行完毕\nCompletableFuture<String> cf5 = cf2.thenApply(result -> {\n    System.out.println(\"cf5\");\n    return \"cf5\";\n});\n// cf6等待 3 4 5执行完毕\nCompletableFuture<Void> cf6 = CompletableFuture.allOf(cf3, cf4, cf5);\nSystem.out.println(cf6.thenApply(v -> {\n    try {\n        return cf3.get() + cf4.get() + cf5.get();\n    } catch (InterruptedException | ExecutionException e) {\n        return null;\n    }\n}).get());\n```\n\n```mermaid\nstateDiagram-v2\n    [*] --> cf1\n    [*] --> cf2\n    cf1 --> cf3\n    cf1 --> cf4\n    cf2 --> cf4\n    cf2 --> cf5\n    cf3 --> cf6\n    cf4 --> cf6\n    cf5 --> cf6\n    cf6 --> [*]\n```\n\n异常处理\n\n```java\nCompletableFuture.completedFuture(\"\")\n    .exceptionally(e -> {\n        e.printStackTrace();\n        return \"\";\n    });\n```\n\nCompletableFuture在回调方法中对异常进行了包装。大部分异常会封装成CompletionException后抛出，真正的异常存储在cause属性中，因此如果调用链中经过了回调方法处理那么就需要用Throwable.getCause()方法提取真正的异常。但是，有些情况下会直接返回真正的异常\n\n### 初始化\n\n```java\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n    // 将runnable包装成callable，内部是通过适配器的方式来实现的\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n```java\nRunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\npublic T call() {\n    task.run();\n    return result;\n}\n```\n\n### get\n\n```java\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        // 这里会一直阻塞到任务完成\n        s = awaitDone(false, 0L);\n    return report(s);\n}\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    \n    long startTime = 0L;    // Special value 0L means not yet parked\n    WaitNode q = null;\n    boolean queued = false;\n    // 无限循环\n    for (;;) {\n        int s = state;\n        // 如果任务已经完成，返回\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // 还未完成，让线程调度器重新调度，防止占着不放\n        else if (s == COMPLETING)\n            Thread.yield();\n        // 线程被打断，抛出异常\n        else if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n        // 第一次运行，创建一些信息\n        else if (q == null) {\n            if (timed && nanos <= 0L)\n                return s;\n            q = new WaitNode();\n        }\n        else if (!queued)\n            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);\n        else if (timed) {\n            final long parkNanos;\n            if (startTime == 0L) { // first time\n                startTime = System.nanoTime();\n                if (startTime == 0L)\n                    startTime = 1L;\n                parkNanos = nanos;\n            } else {\n                long elapsed = System.nanoTime() - startTime;\n                if (elapsed >= nanos) {\n                    removeWaiter(q);\n                    return state;\n                }\n                parkNanos = nanos - elapsed;\n            }\n            // nanoTime may be slow; recheck before parking\n            if (state < COMPLETING)\n                LockSupport.parkNanos(this, parkNanos);\n        }\n        else\n            LockSupport.park(this);\n    }\n}\n```\n\n### run\n\n```java\npublic void run() {\n    // 状态不对\n    if (state != NEW ||\n        !RUNNER.compareAndSet(this, null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        // 状态正确时进入\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                // 执行主体\n                result = c.call();\n                // 标记执行完成\n                ran = true;\n            } catch (Throwable ex) {\n                // 标记失败\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        runner = null;\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n### cancel\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    // 状态不对\n    if (!(state == NEW && STATE.compareAndSet\n          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {\n            try {\n                // 通过设置中断位来停止线程\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                STATE.setRelease(this, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```\n\n## 线程池分类\n\n- ThreadPollExecutor\n- ForkJoinPool\n  - 分解汇总的任务\n  - 用很少的线程可以执行很多的任务(子任务) TPE做不到先执行子任务\n  - CPU密集型\n\n### ThreadPollExecutor\n\nExecutors：线程池工厂（**不推荐使用**）\n\n- newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这个线程池的最大线程数能达到整数的最大值\n- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。同样　线程最大数也是整数最大值\n- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n- newWorkSealingPool jdk8引入　使用多个队列来减少竞争\n\n这个线程工厂大部分都使用了无界队列　如果瞬间请求量大　很有可能造成oom\n\n队列在线程池中起的作用：\n\n请求数大于 coreSize 时，可以让任务在队列中排队，让线程池中的线程慢慢的消费请求，当线程消费完所有的线程后，会阻塞的从队列中拿数据，通过队列阻塞的功能，使线程不消亡\n\n#### 原理\n\n```mermaid\ngraph LR\n    提交任务 --> A{是否超过核心线程数}\n    A --> |N| 创建线程执行当前任务\n    A --> |Y| B{阻塞队列是否已满}\n    B --> |N| 将任务存储在队列中\n    B --> |Y| C{是否超过最大线程数}\n    C --> |N| 创建线程执行任务\n    C --> |Y| 执行拒绝策略\n```\n\n新建的线程会变成一个叫 worker 的角色，这个 worker 会通过一个 while 循环，不断地从阻塞队列中取数据并执行，如果没任务了并且线程池没设置让线程一直存活的话，这个 生命周期就会结束\n\n- 运行状态图\n\n```mermaid\nstateDiagram-v2\n    RUNNING --> SHUTDOWN: shutdown()\n    SHUTDOWN --> STOP: shutdownNow()\n    RUNNING --> STOP: shutdownNow()\n    STOP --> TIDYING: 队列为空\n    SHUTDOWN --> TIDYING: 队列为空\n    TIDYING --> TERMINATED: terminated\n```\n\n#### 生命周期\n\n- 管理方法\n\n调用shutdown方法，此时仍然可以接受新任务，但是新任务将不会被运行，待已运行的任务执行完毕，线程池就会被终止\n\n#### 自定义\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n  2/*实际运行线程数 （不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程）*/,\n  3/*最多允许创建的线程数*/,\n  0L /* 让线程存活的时间 0为永久 */,\n  TimeUnit.SECONDS,\n  new ArrayBlockingQueue<>(4)/*  线程池的内部队列 */,\n  Executors.defaultThreadFactory()/* 产生线程的方式 */,\n  new ThreadPoolExecutor.DiscardOldestPolicy() /* 线程池满时的拒绝策略 */\n  );\n```\n\n参数：\n\n1. corePoolSize 如果等于0 则任务执行结束后就会销毁所有线程　如果大于0　任务执行后这些线程不会被销毁\n2. maximumPoolSize 能最大同时容纳的线程数　如果任务数量大于这个数　那么剩下的任务就要被缓存在一个阻塞队列中\n3. keepAliveTime 表示线程池中的线程空闲时间　多于corePoolSize数量的部分线程会被销毁\n4. 时间单位\n5. workQUeue 缓存队列\n6. threadFactory 定义线程池线程的产生方式\n7. handler 任务拒绝策略\n\n值得注意的是，上述参数除了缓存队列，其他参数都是可以在运行时动态调整的。\n\n为了能达到动态调整队列长度的目的：可以通过实现自己的阻塞队列来实现。\n\n如何配置：\n\n- CPU密集型\n- IO密集型\n\n实际应用中 很难确定每个应用到底是CPU密集还是IO密集 不如通过动态调整线程池的方式 边调整边观察 进行负载测试 从而得到适合特定业务场景下的最佳配置\n\n自定义线程工厂：为线程指定有意义的名称和相应的序列号，方便出错排查\n\n定义好拒绝策略：宁愿抛出异常也不要使用 DiscardPolicy， 这个策略会静悄悄的抛弃任务\n\n线程池预热：\n\n- prestartCoreThread\n- prestartAllCoreThreads\n\n设置回收核心线程：\n\n- allowCoreThreadTimeOut\n\n##### 线程池的大小\n\n$N_{cpu}$ = CPU数量\n\n$U_{cpu}$ = 预期CPU使用率\n\n$W/C$ = 等待时间/计算时间\n\n最优大小等于 $N_{cpu} * U_{cpu} * (1 + W/C)$\n\n但这个公式过于理想，在生产环境中，等待时间与计算时间很难计算 更多地是靠场景根据经验来设置各个参数 或是根据监控来动态调整参数以观察效果\n\n##### 应用场景\n\n- coreSize == maxSize\n\n让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗\n\n- maxSize 无界 + SynchronousQueue\n\n当任务被消费时，才会返回，这样请求就能够知道当前请求是已经在被消费了，如果是其他的队列的话，我们只知道任务已经被提交成功了，但无法知道当前任务是在被消费中，还是正在队列中堆积\n\n比较消耗资源，大量请求到来时，我们会新建大量的线程来处理请求\n\n- maxSize 有界 + Queue 无界\n\n对实时性要求不大，但流量忽高忽低的场景下，可以使用这种方式\n\n当流量高峰时，大量的请求被阻塞在队列中，对于请求的实时性难以保证\n\n- maxSize 有界 + Queue 有界\n\n把队列从无界修改成有界，只要排队的任务在要求的时间内，能够完成任务即可\n\n- keepAliveTime 设置无穷大\n\n想要空闲的线程不被回收，我们可以设置 keepAliveTime 为无穷大值\n\n##### 线程池的公用和独立\n\n查询和写入不公用线程池，如果公用的话，当查询量很大时，写入的请求可能会到队列中去排队，无法及时被处理\n\n原则上来说，每个写入业务场景都独自使用自己的线程池，绝不共用，这样在业务治理、限流、熔断方面都比较容易\n多个查询业务场景是可以公用线程池的\n\n#### Wroker\n\n在线程池中，最小的执行单位就是 Worker\n\n```java\nprivate final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n{\n      \n\n        // 运行任务的线程\n        final Thread thread;\n        // 任务代码块\n        Runnable firstTask;\n        /** Per-thread task counter */\n        volatile long completedTasks;\n\n        Worker(Runnable firstTask) {\n            // 把自己作为一个代码块穿给线程\n            setState(-1); // inhibit interrupts until runWorker\n            this.firstTask = firstTask;\n            // 线程是通过线程工程创建的\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        public void run() {\n            // 这里就将任务的执行交给线程池了\n            runWorker(this);\n        }\n        ...\n}\n```\n\n#### 任务提交\n\n提交到线程池中的任务，务必要注意任务之间要没有依赖，否则很容易就会出现死锁问题\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // 如果工作线程数小于coreSize\n    if (workerCountOf(c) < corePoolSize) {\n        // 则直接创建worker执行\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 如果线程池状态正常，并且工作队列还能入队\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 线程池状态异常，尝试从队列移除任务\n        if (! isRunning(recheck) && remove(command))\n            // 移除成功就拒绝任务\n            reject(command);\n        // 工作线程为0\n        else if (workerCountOf(recheck) == 0)\n            // 直接创建worker执行\n            addWorker(null, false);\n    }\n    // 队列满了，如果线程数超过maxSize，拒绝任务\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\naddWorker 方法首先是执行了一堆校验，然后使用 new Worker (firstTask) 新建了 Worker，最后使用 t.start () 执行 Worker，所以 t.start () 会执行到 Worker 的 run 方法上,到runWorker 方法里\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    // 校验各种状态\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 把任务交给worker，此时要执行的任务就已经传入给worker里面的thread了\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int c = ctl.get();\n                // 检查线程池状态\n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.getState() != Thread.State.NEW)\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    workerAdded = true;\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 启动线程，执行worker\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 所以说在这里，在不断地取任务执行\n        // 如果要执行的task为空，则会去取一个task，取不到就阻塞\n        while (task != null || (task = getTask()) != null) {\n            // 锁住worker，防止一个任务多个线程执行\n            w.lock();\n            // 线程池stop了，让线程中断\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 执行前钩子函数\n                beforeExecute(wt, task);\n                try {\n                    // 执行真正的任务\n                    // 而执行这个任务的线程就是worker里面的thread\n                    task.run();\n                    // 执行后钩子函数\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    // 异常钩子函数\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n```java\nprivate Runnable getTask() {\n    // 如果设置了线程超时时间，超过一定时间没有任务，超出coreSize部分的线程会被回收\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        // 检查线程池状态\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n        // 如果线程数大于maxSize但是存活时间还没超过keepalive，则跳过后面取任务的部分\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        try {\n            // 超过keepAliveTime时间取不到数据就返回，此时线程不再运行，结束了，JVM会回收掉\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n#### 饱和策略\n\n线程池的构建最后参数定义了当缓存队列满了之后，要如何处置提交的任务\n\n- AbortPolicy：默认的饱和策略 抛出RejectedExecutionException\n- CallerRunsPolicy：回退到由提交者执行\n- DiscardPolicy：丢弃掉当前提交的任务\n- DiscardOldestPolicy：丢弃掉等待队列中最老的任务\n\n#### 线程工厂\n\n决定如何产生新线程，最常用来设置线程名称\n\n```java\npublic static final ThreadFactory SHORT_LIFE_POOL_THREAD_FACTORY = new ThreadFactory() {\n    private final AtomicInteger atomicInteger = new AtomicInteger();\n    @Override\n    public Thread newThread(Runnable r) {\n        return new Thread(r, \"short-life-thread-pool-\" + atomicInteger.incrementAndGet());\n    }\n};\n```\n\n### ForkJoinPool\n\nFork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架\n\n```mermaid\nstateDiagram-v2\n    大任务 --> 子任务1: fork\n    大任务 --> 子任务2: fork\n    大任务 --> 子任务3: fork\n    子任务1 --> 子任务1.1: fork\n    子任务1 --> 子任务1.2: fork\n    子任务3 --> 子任务3.1: fork\n    子任务3 --> 子任务3.2: fork\n    子任务1.1 --> 任务1结果: join\n    子任务1.2 --> 任务1结果: join\n    子任务3.1 --> 任务3结果: join\n    子任务3.2 --> 任务3结果: join\n    子任务2 --> 任务2结果\n    任务1结果 --> 大任务结果: join\n    任务2结果 --> 大任务结果: join\n    任务3结果 --> 大任务结果: join\n```\n\n- 工作窃取（work-stealing）：指某个线程从其他队列里窃取任务来执行\n\n#### 构造器\n\n```java\npublic ForkJoinPool() {...} // 创建一个拥有处理器数量的线程池\npublic ForkJoinPool(int parallelism){...} // 自定义并行度\n```\n\n#### 使用\n\n```java\nForkJoinPool pool = new ForkJoinPool();\npool.execute(...);\n```\n\nexecute 方法传递的任务有两个抽象子类：\n\n- RecursiveAction 无返回值任务\n- RecursiveTask 有返回值任务\n\n```java\nclass RaskDemo extends RecursiveAction {\n    /**\n     *  每个\"小任务\"最多只打印20个数\n     */\n    private static final int MAX = 20;\n\n    private int start;\n    private int end;\n\n    public RaskDemo(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected void compute() {\n        //当end-start的值小于MAX时，开始打印\n        if((end-start) < MAX) {\n            for(int i= start; i<end;i++) {\n                System.out.println(Thread.currentThread().getName()+\"i的值\"+i);\n            }\n        }else {\n            // 将大任务分解成两个小任务\n            int middle = (start + end) / 2;\n            RaskDemo left = new RaskDemo(start, middle);\n            RaskDemo right = new RaskDemo(middle, end);\n            left.fork();\n            right.fork();\n        }\n    }\n}\n```\n\n两个抽象子类的区别在于有返回值的任务在调用compute后最终会返回计算结果 无论是自己计算的 还是对子任务的合并\n\n## 案例\n\n### 线程池没有隔离导致任务饥饿\n\n之前在维护视图库平台的时候，排查过一个问题：\n\n视图库需要定期向上级平台定期发送一个 HTTP 保活请求，大概是几分钟一次，但通过日志以及数据库记录的保活请求发送时间发现，每次保活操作的执行都大大延迟了。\n\n通过静态代码审查发现是保活操作跟另外一个像上级平台发送订阅通知数据的操作共用了同一个线程池，后者是大量短而快的任务，这就导致了保活操作要在队列中排队一段时间才会执行，所以执行时间都延迟了。\n\n最后通过让保活操作自己单独使用线程池来解决问题。\n","metadata":"","hasMoreCommit":true,"totalCommits":17,"commitList":[{"date":"2024-11-19T15:26:31+08:00","author":"MY","message":"📦Java 并发编程","hash":"63d98d49e4151c9530896a7a8c1bd0cdc4d9a762"},{"date":"2023-11-30T14:48:11+08:00","author":"MY","message":"📦清理图片","hash":"695f949a5a0d58d3b126d4557bebdb2280772c33"},{"date":"2023-03-29T15:10:02+08:00","author":"MY","message":"✏线程池","hash":"fcdab0d06c4a99f8f5b707ff2a258dddc9ad43db"},{"date":"2022-05-27T15:48:54+08:00","author":"cjiping","message":"✏️更新 线程池","hash":"c56cf30a8e8e8b3db6079f6902cf6c3fff48a531"},{"date":"2022-03-12T12:17:40+08:00","author":"MY","message":"✏️更新 线程池","hash":"7c675238c25b89f250e00628a3fc59827ef8a678"},{"date":"2022-03-11T17:28:30+08:00","author":"cjiping","message":"✏️更新 线程池","hash":"3b718004f29b59d26df9ec69e3eb4aaafb9ed4a7"},{"date":"2022-03-10T16:50:11+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"ba23eb355d62e76d011370f5ba776dc643636c9b"},{"date":"2022-03-09T17:46:16+08:00","author":"cjiping","message":"✏️更新 JAVA并发编程","hash":"05cdd8647ade510badf68feae84d459e83c2b943"},{"date":"2021-10-14T21:40:52+08:00","author":"My","message":"✏️更新 线程池","hash":"cb7a7fd75d82d1bdd966b624ebe272e716c51764"},{"date":"2021-09-09T16:57:37+08:00","author":"cjiping","message":"✏更新 Java ForkJoinPool","hash":"30035340f1d2919020a222decca8f3c70399bbdd"}],"createTime":"2020-07-03T14:56:05+08:00"}