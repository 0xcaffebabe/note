# JAVA内存模型(JMM)

>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本

![批注 2020-03-12 195705](/assets/批注%202020-03-12%20195705.png)

## 硬件层数据一致性

现代CPU的数据一致性实现 = 缓存锁(MESI ...) + 总线锁

- 缓存行

![批注 2020-07-22 144020](/assets/批注%202020-07-22%20144020.png)

使用缓存行的对齐能够提高效率（disruptor）

## 乱序问题

CPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据（慢100倍）），去同时执行另一条指令，前提是，两条指令没有依赖关系

### 硬件级防乱序

X86

sfence:  store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。
lfence：load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。
mfence：modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成

>原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序

### JVM级防乱序(JSR133)

JVM内存屏障 屏障两边的指令不可以重排序

LoadLoad屏障:
对于这样的语句Load1; LoadLoad; Load2,
在Load2及后续读取操作要读取的数据被访问前，保证Loadi要读取的数据被读取完毕

StoreStore屏障:
对于这样的语句Store1; StoreStore; Store2,
在Store2及后续写入操作执行前，保证Store1的写 入操作对其它处理器可见。

LoadStore屏障:
对于这样的语句Load1; LoadStore; Store2,
在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。

StoreLoad屏障:对于这样的语句Store1; StoreLoad; Load2,
在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。

再低一层，虚拟机的实现是可以依赖于 lock 指令

### volatile的实现细节

- 字节码层面

ACC_VOLATILE 修饰符

- JVM层面

volatile内存区的读写 都加屏障

> StoreStoreBarrier
>
> volatile 写操作
>
> StoreLoadBarrier

> LoadLoadBarrier
>
> volatile 读操作
>
> LoadStoreBarrier

- 硬件/OS层面

内存屏障/Lock指令

### synchronized实现细节

- 字节码层面

ACC_SYNCHRONIZED

monitorenter monitorexit

- JVM层面

C C++ 调用了操作系统提供的同步机制

- OS和硬件层面

X86 : lock cmpxchg / xxx

## 内存间的交互操作

![202031219588](/assets/202031219588.png)

- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

## 三大特性

### 原子性

JAVA内存模型保证了以上8种内存操作具有原子性

但是允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行

### 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改

变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性

实现可见性的方式：

- 被volatile修饰的变量，它会保证修改的值会立即被更新到主存
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值

### 有序性

在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序

指令重排序：Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前

synchronized 也可以来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码

- 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性

## as-if-serial语义

as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变

## 先行发生原则

### 单一线程原则

一个线程内，在程序前面的操作先行发生于后面的操作

### 管程锁定规则

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作

### volatile 变量规则

一个 volatile 变量的写操作先行发生于后面对这个变量的读操作

### 线程启动规则

Thread 对象的 start() 方法调用先行发生于此线程的每一个动作

### 线程加入规则

Thread 对象的结束先行发生于 join() 方法返回

### 线程中断规则

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

### 对象终结规则

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始

### 传递性

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C