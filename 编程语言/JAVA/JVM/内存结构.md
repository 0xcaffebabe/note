# 内存结构

## 总体内存结构

![批注 2020-01-03 135700](/assets/批注%202020-01-03%20135700.png)
![批注 2020-07-29 083921](/assets/批注%202020-07-29%20083921.png)
![批注 2020-07-29 084922](/assets/批注%202020-07-29%20084922.png)
![截图录屏_选择区域_20200918152033](/assets/截图录屏_选择区域_20200918152033.png)

### 概览

![截图录屏_选择区域_20200918155103](/assets/截图录屏_选择区域_20200918155103.png)

### PC 程序计数器

用来存放执行指令的偏移量和行号指示器等

> 存放指令位置
>
> 虚拟机的运行，类似于这样的循环：

```c
while( not end ) {

​	取PC中的位置，找到对应位置的指令；
​	执行该指令；
​	PC ++;

}
```

Runtime Constant Pool

### Direct Memory

> JVM可以直接访问的内核空间的内存 (OS 管理的内存)
>
> NIO ， 提高效率，实现zero copy

### heap

- 共享，内存大户，存储所有的对象和数组
- -Xms(memory start) 初始堆值，-Xmx(memory max)最大堆值

### Method Area

1. Perm Space (<1.8)
   字符串常量位于PermSpace
   FGC不会清理
   大小启动的时候指定，不能变
2. Meta Space (>=1.8)
   字符串常量位于堆
   会触发FGC清理
   不设定的话，最大就是物理内存

### JVM Stack

每个线程私有

![截图录屏_选择区域_20200918153359](/assets/截图录屏_选择区域_20200918153359.png)

1. Frame - 每个方法对应一个栈帧
   1. Local Variable Table　局部变量表
      存放方法参数和局部变量的区域
   2. Operand Stack　操作栈
      各种指令往栈中写入或者读取信息
      对于long的处理（store and load），多数虚拟机的实现都是原子的
      jls 17.7，没必要加volatile
   3. Dynamic Linking　动态连接
      常量池中一个对当前方法的引用
      https://blog.csdn.net/qq_41813060/article/details/88379473 
      jvms 2.6.3
   4. return address　方法返回地址
      a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方

### Native Method Stack

为本地方法服务

## 对象内存布局

![批注 2020-05-11 111756](/assets/批注%202020-05-11%20111756.png)
![屏幕截图 2020-09-16 152736](/assets/屏幕截图%202020-09-16%20152736.png)

1. 对象头
   1. 对象本身运行时的数据 哈希吗 GC标记 锁信息等等
   2. 类元信息：指向Class的指针 
2. 实例数据：实例成员变量及所有可见的父类成员变量
3. 对齐填充

锁升级：无锁状态 -> 偏向锁 -> 自旋锁 -> 重量级锁

32位

![批注 2020-07-27 091839](/assets/批注%202020-07-27%20091839.png)

64位

![批注 2020-05-12 145237](/assets/批注%202020-05-12%20145237.png)

**Hotspot开启内存压缩的规则**

UseCompressedOopsClassPointers

UseCompressedOops

1. 4G以下，直接砍掉高32位
2. 4G - 32G，默认开启内存压缩 ClassPointers Oops
3. 32G，压缩无效，使用64位

## 对象定位

![批注 2020-05-11 134427](/assets/批注%202020-05-11%20134427.png)

## 对象实例化

### 字节码角度

```java
Object ref = new Object()
```

得到字节码:

```
stack=2, locals=2, args_size=1
   0: new           #2                  // class java/lang/Object
   3: dup
   4: invokespecial #1                  // Method java/lang/Object."<init>":()V
   7: astore_1
   8: return

```

new:

1. 如果类不存在　就先进行类加载
2. 为所有属性值分配内存
3. 对所有属性值进行０值初始化
4. 最后将指向实例对象的引用变量压入虚拟机栈顶

dup:

1. 在栈顶复制实例对象的引用变量
   1. 复制出来的这个变量用来作为句柄调用相关方法
   2. 早一点的那个变量则是用来赋值

invokespecial:

1. 通过上面dup复制的变量调用对象的`<init>` 方法

### 从执行步骤

1. 确认类信息是否存在于metaspace 否则使用类加载器加载类　并生成相关Class对象
2. 计算对象占用的内存空间(实例数据) 接下来在堆内存划分一块空间进行分配　为对象分配内存时　需要进行同步操作
3. 设定成员变量的默认值
4. 设置对象头　哈希吗　GC信息等等
5. 执行init方法　初始化成员变量　执行初始化代码块等等

## 查看堆内存使用情况

- 使用jstat命令

```shell
jstat -class pid # 查看加载的类
jstat -gc pid # 查看垃圾回收情况
```

## 内存分析

- jmap命令

```shell
jmap -histo pid # 查看所有对象
jmap -histo:live pid # 查看所有存活对象
jmap -dump:format=b,file=filename pid # 导出dump文件
```

- jhat分析dump文件
    - JDK9以后不再提供，被Visual VM代替

```shell
jhat filename
```

- mat分析

### 内存溢出定位与分析

- 添加运行参数

```java
java -Xmx8m -Xms8m -XX:+HeapDumpOnOutOfMemoryError
```

- 分析dump文件

### 分析线程执行情况

```shell
jstack pid
```

- 死锁

> 两个进程互相等待对方，一直阻塞下去

```text
Found one Java-level deadlock:
=============================
"Thread-0":
  waiting to lock monitor 0x000002292014eb00 (object 0x00000000ffea7640, a java.lang.Object),
  which is held by "Thread-1"
"Thread-1":
  waiting to lock monitor 0x000002292014ea00 (object 0x00000000ffea7630, a java.lang.Object),
  which is held by "Thread-0"

Java stack information for the threads listed above:
===================================================
"Thread-0":
        at Main.lambda$main$0(Main.java:24)
        - waiting to lock <0x00000000ffea7640> (a java.lang.Object)
        - locked <0x00000000ffea7630> (a java.lang.Object)
        at Main$$Lambda$14/0x0000000800ba4840.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)
"Thread-1":
        at Main.lambda$main$1(Main.java:37)
        - waiting to lock <0x00000000ffea7630> (a java.lang.Object)
        - locked <0x00000000ffea7640> (a java.lang.Object)
        at Main$$Lambda$15/0x0000000800ba4c40.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)

Found 1 deadlock.
```

## JMX

>MX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理
