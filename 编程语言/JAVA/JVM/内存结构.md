# 内存结构

## 内存管理

- 传统程序语言：由程序员手动内存管理
- 现代程序语言：自动内存管理

## 总体内存结构

![批注 2020-01-03 135700](/assets/批注%202020-01-03%20135700.png)
![批注 2020-07-29 083921](/assets/批注%202020-07-29%20083921.png)
![批注 2020-07-29 084922](/assets/批注%202020-07-29%20084922.png)

PC 程序计数器

> 存放指令位置
>
> 虚拟机的运行，类似于这样的循环：

```c
while( not end ) {

​	取PC中的位置，找到对应位置的指令；
​	执行该指令；
​	PC ++;

}
```

JVM Stack

每个线程私有

1. Frame - 每个方法对应一个栈帧
   1. Local Variable Table
   2. Operand Stack
      对于long的处理（store and load），多数虚拟机的实现都是原子的
      jls 17.7，没必要加volatile
   3. Dynamic Linking
      https://blog.csdn.net/qq_41813060/article/details/88379473 
      jvms 2.6.3
   4. return address
      a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方

![批注 2020-07-29 094425](/assets/批注%202020-07-29%20094425.png)

Heap

所有JAVA线程共享

Method Area

1. Perm Space (<1.8)
   字符串常量位于PermSpace
   FGC不会清理
   大小启动的时候指定，不能变
2. Meta Space (>=1.8)
   字符串常量位于堆
   会触发FGC清理
   不设定的话，最大就是物理内存

Runtime Constant Pool

Native Method Stack

Direct Memory

> JVM可以直接访问的内核空间的内存 (OS 管理的内存)
>
> NIO ， 提高效率，实现zero copy

## JDK7的堆内存结构

![](https://img-blog.csdnimg.cn/20190222154219611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为新生代和老年代

1.Young （新生代）

新生代 分为三部分。Eden区(new 的对象)和两个大小相同的Survivior区（某一时刻，只有一个被使用），另外一个，当Eden区满了，GC就会将存活的对象移动到空闲的Survivor区，根据JVM的策略，在经过几次垃圾收集后，依然存活在Survivor区的对象，将移动到Tenured区（老年代）

2.Tenured（老年代）

老年代 主要保存生命周期长的对象。（new 的大对象，会直接进入老年代）

3.Perm（永久代）

永久代主要保存class、method、filed对象。这部分的空间一般不会溢出，除非一次性加载很多的类，不过在涉及热部署的应用服务器的时候，有时候会遇到 java.lang.OutOfMemoryError:PermGen space的错误

4.Virtual区：

最大内存和初始内存的差值，就是Virtual区

## JDK8堆内存结构

![](https://img-blog.csdnimg.cn/20190222154349947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20190222154442676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

### 为何移除

>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation

### 堆内存

- 共享，内存大户，存储所有的对象和数组
- -Xms 初始堆值，-Xmx最大堆值

## 对象内存布局

![批注 2020-05-11 111756](/assets/批注%202020-05-11%20111756.png)
![屏幕截图 2020-09-16 152736](/assets/屏幕截图%202020-09-16%20152736.png)

1. 对象头
   1. 对象本身运行时的数据 哈希吗 GC标记 锁信息等等
   2. 类元信息：指向Class的指针 
2. 实例数据：实例成员变量及所有可见的父类成员变量
3. 对齐填充

锁升级：无锁状态 -> 偏向锁 -> 自旋锁 -> 重量级锁

32位

![批注 2020-07-27 091839](/assets/批注%202020-07-27%20091839.png)

64位

![批注 2020-05-12 145237](/assets/批注%202020-05-12%20145237.png)

**Hotspot开启内存压缩的规则**

UseCompressedOopsClassPointers

UseCompressedOops

1. 4G以下，直接砍掉高32位
2. 4G - 32G，默认开启内存压缩 ClassPointers Oops
3. 32G，压缩无效，使用64位

## 对象定位

![批注 2020-05-11 134427](/assets/批注%202020-05-11%20134427.png)

## 查看堆内存使用情况

- 使用jstat命令

```shell
jstat -class pid # 查看加载的类
jstat -gc pid # 查看垃圾回收情况
```

## 内存分析

- jmap命令

```shell
jmap -histo pid # 查看所有对象
jmap -histo:live pid # 查看所有存活对象
jmap -dump:format=b,file=filename pid # 导出dump文件
```

- jhat分析dump文件
    - JDK9以后不再提供，被Visual VM代替

```shell
jhat filename
```

- mat分析

### 内存溢出定位与分析

- 添加运行参数

```java
java -Xmx8m -Xms8m -XX:+HeapDumpOnOutOfMemoryError
```

- 分析dump文件

### 分析线程执行情况

```shell
jstack pid
```

- 死锁

> 两个进程互相等待对方，一直阻塞下去

```text
Found one Java-level deadlock:
=============================
"Thread-0":
  waiting to lock monitor 0x000002292014eb00 (object 0x00000000ffea7640, a java.lang.Object),
  which is held by "Thread-1"
"Thread-1":
  waiting to lock monitor 0x000002292014ea00 (object 0x00000000ffea7630, a java.lang.Object),
  which is held by "Thread-0"

Java stack information for the threads listed above:
===================================================
"Thread-0":
        at Main.lambda$main$0(Main.java:24)
        - waiting to lock <0x00000000ffea7640> (a java.lang.Object)
        - locked <0x00000000ffea7630> (a java.lang.Object)
        at Main$$Lambda$14/0x0000000800ba4840.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)
"Thread-1":
        at Main.lambda$main$1(Main.java:37)
        - waiting to lock <0x00000000ffea7630> (a java.lang.Object)
        - locked <0x00000000ffea7640> (a java.lang.Object)
        at Main$$Lambda$15/0x0000000800ba4c40.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)

Found 1 deadlock.
```

## JMX

>MX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理
