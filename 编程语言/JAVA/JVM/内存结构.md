# 内存结构

## 内存管理

- 传统程序语言：由程序员手动内存管理
- 现代程序语言：自动内存管理

## 总体内存结构

![批注 2020-01-03 135700](/assets/批注%202020-01-03%20135700.png)

## JDK7的堆内存结构

![](https://img-blog.csdnimg.cn/20190222154219611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为新生代和老年代

1.Young （新生代）

新生代 分为三部分。Eden区(new 的对象)和两个大小相同的Survivior区（某一时刻，只有一个被使用），另外一个，当Eden区满了，GC就会将存活的对象移动到空闲的Survivor区，根据JVM的策略，在经过几次垃圾收集后，依然存活在Survivor区的对象，将移动到Tenured区（老年代）

2.Tenured（老年代）

老年代 主要保存生命周期长的对象。（new 的大对象，会直接进入老年代）

3.Perm（永久代）

永久代主要保存class、method、filed对象。这部分的空间一般不会溢出，除非一次性加载很多的类，不过在涉及热部署的应用服务器的时候，有时候会遇到 java.lang.OutOfMemoryError:PermGen space的错误

4.Virtual区：

最大内存和初始内存的差值，就是Virtual区

## JDK8堆内存结构

![](https://img-blog.csdnimg.cn/20190222154349947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20190222154442676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MjU0MjE=,size_16,color_FFFFFF,t_70)

### 为何移除

>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation

### 堆内存

- 共享，内存大户，存储所有的对象和数组
- -Xms 初始堆值，-Xmx最大堆值

## 查看堆内存使用情况

- 使用jstat命令

```shell
jstat -class pid # 查看加载的类
jstat -gc pid # 查看垃圾回收情况
```

## 内存分析

- jmap命令

```shell
jmap -histo pid # 查看所有对象
jmap -histo:live pid # 查看所有存活对象
jmap -dump:format=b,file=filename pid # 导出dump文件
```

- jhat分析dump文件
    - JDK9以后不再提供，被Visual VM代替

```shell
jhat filename
```

- mat分析

### 内存溢出定位与分析

- 添加运行参数

```java
java -Xmx8m -Xms8m -XX:+HeapDumpOnOutOfMemoryError
```

- 分析dump文件

### 分析线程执行情况

```shell
jstack pid
```

- 死锁

> 两个进程互相等待对方，一直阻塞下去

```text
Found one Java-level deadlock:
=============================
"Thread-0":
  waiting to lock monitor 0x000002292014eb00 (object 0x00000000ffea7640, a java.lang.Object),
  which is held by "Thread-1"
"Thread-1":
  waiting to lock monitor 0x000002292014ea00 (object 0x00000000ffea7630, a java.lang.Object),
  which is held by "Thread-0"

Java stack information for the threads listed above:
===================================================
"Thread-0":
        at Main.lambda$main$0(Main.java:24)
        - waiting to lock <0x00000000ffea7640> (a java.lang.Object)
        - locked <0x00000000ffea7630> (a java.lang.Object)
        at Main$$Lambda$14/0x0000000800ba4840.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)
"Thread-1":
        at Main.lambda$main$1(Main.java:37)
        - waiting to lock <0x00000000ffea7630> (a java.lang.Object)
        - locked <0x00000000ffea7640> (a java.lang.Object)
        at Main$$Lambda$15/0x0000000800ba4c40.run(Unknown Source)
        at java.lang.Thread.run(java.base@13/Thread.java:830)

Found 1 deadlock.
```

## JVM 栈

- 线程私有，存储类中每个方法的内容
- -Xss 最大栈值

## 方法区

- 存储类信息、常量池等
- 1.7及以前，永久区(Perm)，-XX:PermSize, -XX:MaxPermSize
- 1.8及以后，元数据区，-XX:MetaspaceSize, -XX:MaxMetaspaceSize

## JMX

>MX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理

# 总结

- 使用visualvm进行可以对上述的大部分操作可视化
