# 垃圾回收

> 一个跟踪过程，它传递性地跟踪指向当前使用的对象的所有指针，以便找到可以引用的所有对象，然后重新使用在此跟踪过程中未找到的任何堆内存。公共语言运行库垃圾回收器还压缩使用中的内存，以缩小堆所需要的工作空间

## JAVA对象生命周期

### 内存回收API

- Object的finalize方法，垃圾收集器在回收对象时调用，有且仅被调用一次
- System的gc方法。不靠谱

## JAVA对象引用

- 基于对象引用判定无用对象
- 对象引用链

### 强引用

```java
Object obj = new Object(); Object obj2 = obj;
```

- 强引用还存在，对象就不会被回收，哪怕发生OOM异常

### 软引用

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

- 有用但并非必需的对象
- 在系统的内存不够时，会把这些对象列为可回收

### 弱引用

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

- 比软引用强度更弱些
- 只能生存到下一次垃圾收集发生之前

### 虚引用

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

- 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，用于对象回收跟踪

### 总结

引用类型 | 强引用  | 软引用           | 弱引用           | 虚引用
---- | ---- | ------------- | ------------- | ----------------
类型   | 正常赋值 | SoftReference | WeakReference | PhantomReference
回收时间 | 不回收  | 内存紧张时回收       | GC就回收         | 随时可能被回收

## 内存分配与回收

### Minor GC 和 Full GC

- Minor GC（Young GC）:回收新生代，这种类型的GC执行很频繁，执行速度也很快
  - 当 Eden 空间满时，就将触发一次 Minor GC
- Full GC（Major GC）：回收老年代和新生代，这种GC执行一般比较少，执行速度慢
  - System.gc()会建议虚拟机去触发Full GC,但只是建议
  - 老年代空间不足的情况下，也会进行Full GC
  -  CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足，会触发 Full GC

### 内存分配策略

![批注 2020-05-08 165104](/assets/批注%202020-05-08%20165104.png)

- 对象优先在Eden上分配
- 为避免在 Eden 和 Survivor 之间的大量内存复制，大对象的内存直接在老年代
  - `-XX:PretenureSizeThreshold`
- 长期存活的对象进入老年代
  - `-XX:MaxTenuringThreshold` 用来定义年龄的阈值
- 动态对象年龄判定
  - 如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄
- 空间分配担保
  - Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的
  - 否则虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许失败
    - 就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC
    - 否则进行Full GC

## 垃圾回收算法

- GCRoots

可以作为GCRoots的对象包括下面几种：

- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(Native方法)引用的对象

### 引用计数法

> 为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收

### 标记清除法

> GC 标记-清除算法由标记阶段和清除阶段构成。在标记阶段会把所有的活动对象都做上标记，然后在清除阶段会把没有标记的对象，也就是非活动对象回收，该算法一般应用于老年代,因为老年代的对象生命周期比较长

![202031685456](/assets/202031685456.png)

- 可以解决循环引用的问题 
- 必要时才回收(内存不足时) 
- **回收时，应用需要挂起，也就是stop the world。**
- **标记和清除的效率不高**
- **会造成内存碎片**

### 标记压缩算法

> 其中标记阶段跟标记-清除算法中的标记阶段是一样的,而对于压缩阶段，它的工作就是移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的

但这种方式需要移动大量对象，处理效率比较低

![20203168564](/assets/20203168564.png)

- 任意顺序 : 即不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象；
- 线性顺序 : 考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块；
- 滑动顺序 : 按照对象原来在堆中的顺序滑动到堆的一端。

### 复制清除算法

> 把内存分为两个空间一个是From空间，一个是To空间，对象一开始只在From空间分配，To空间是空闲的。GC时把存活的对象从From空间复制粘贴到To空间，之后把To空间变成新的From空间，原来的From空间变成To空间，这也是JVM年轻代所使用的的回收算法

![20203169025](/assets/20203169025.png)

商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。
当进行GC时，将Eden与使用过的Survivor中存活的对象移动到另外一个Survivor中，然后清除Eden与使用过的Survivor

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%

- 在存活对象不多的情况下，性能高，能解决内存碎片和java垃圾回收算法之-标记清除 中导致的引用更新问题。
- **会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，coping的性能会变得很差**

### 分代收集

![批注 2020-05-08 164208](/assets/批注%202020-05-08%20164208.png)

不同对象使用不同的回收算法

- 新生代
  - 主要存放短暂生命周期的对象
  - 新创建的对象都先放入新生代，大部分新建对象在第一次gc时被回收
  - 新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快
  - **使用复制清除算法**
- 老年代
  - 一个对象经过几次gc仍存活，则放入老年代
  - 这些对象可以活很长时间，或者伴随程序一生，需要常驻内存的，可以减少回收次数
  - 老年代 GC（Major GC  / Full GC）：指发生在老年代的 GC
  - **使用标记清除 或者标记压缩算法**

### 方法区的回收

方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
只有满足以下三个条件，类才有可能会被卸载：

- 该类的所有实例已被回收
- 该类的ClassLoader已被回收
- 该类的class没有在任何地方被引用

## 内存分配

### 内存配置常见参数

```
-XX:+PrintGC      每次触发GC的时候打印相关日志
-XX:+UseSerialGC      串行回收
-XX:+PrintGCDetails  更详细的GC日志
-Xms               堆初始值
-Xmx               堆最大可用值
-Xmn               新生代堆最大可用值
-XX:SurvivorRatio  用来设置新生代中eden空间和from/to空间的比例.
-XX:NewRatio       配置新生代与老年代占比 1:2
含以-XX:SurvivorRatio=eden/from=den/to
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。
-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.
```

### OutOfMemoryError异常

- Java堆溢出

```java
java.lang.OutOfMemoryError: Java heap space 堆内存溢出
```

因为堆内存无法满足内存申请需要

设置堆内存大小解决`-Xmx`

- 虚拟机栈溢出

```java
java.lang.StackOverflowError  栈内存溢出
```

由于方法调用栈过深

设置线程最大调用深度`-Xss`

#### 内存溢出与内存泄漏

内存溢出就是申请的内存大小超出了系统所能提供的，系统不能满足需求，于是产生溢出

内存泄漏是使用过的内存空间没有被及时释放，长时间占用内存，最终导致内存空间不足，而出现内存溢出

## 垃圾收集器

截止到JDK14,当前JAVA已有的垃圾回收器

![批注 2020-05-08 163037](/assets/批注%202020-05-08%20163037.png)

连线表示垃圾收集器可以配合使用

垃圾回收器的发展路线是随着内存越来越大演进
以及从分代算法演化到不分代算法

什么是调优

- 规划与预调优
- 优化运行环境
- 解决JVM运行时出现的问题

调优方向：

- 吞吐量
- 响应时间

除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行

### 串行垃圾收集器Serial

![2020316989](/assets/2020316989.jpg)

- 会导致STW（stop the world）
- JAVA WEB应用不会使用该种收集器
- 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大

```
[120.792s][info   ][gc           ] GC(25) Pause Young (Allocation Failure) 10M->6M(15M) 0.936ms
[120.792s][info   ][gc,cpu       ] GC(25) User=0.00s Sys=0.00s Real=**0.00s**
```

通过JVM参数`-XX:+UseSerialGC`可以使用串行垃圾回收器

### ParNew

![20203169926](/assets/20203169926.jpg)

它是 Serial 收集器的多线程版本

```
[GC (Allocation Failure) [ParNew: 4928K->512K(4928K), 0.0024282 secs] 7129K->3525K(15872K), 0.0024673 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```

参数控制：`-XX:+UseParNewGC` 指定使用ParNew收集器

`-XX:ParallelGCThreads` 限制线程数量

### Parallel

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器
吞吐量指的是CPU用于运行用户程序的时间占总时间的比值

停顿时间短，回收效率高，对吞吐量要求高

`-XX:-UseParallelGC`(年轻代) 和 `-XX:+UseParallelOldGC`(老年代)

### Serial Old

Serial 收集器的老年代版本，给 Client 场景下的虚拟机使用

如果用在Server端：是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用

### Parallel Old

![202031692117](/assets/202031692117.jpg)

Parallel Scavenge 收集器的老年代版本

### CMS垃圾收集器

![202031692235](/assets/202031692235.jpg)

（Concurrent Mark Sweep）

> CMS是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。它可以与Serial收集器和Parallel New收集器搭配使用。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上

![](https://upload-images.jianshu.io/upload_images/2184951-cd90513432053c9a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

响应时间优先，减少垃圾收集停顿时间

通过JVM参数 `-XX:+UseConcMarkSweepGC`设置

### G1垃圾收集器

一款面向服务端应用的垃圾收集器

- 开启
- 设置堆最大内存
- 设置最长停顿时间

![](https://user-gold-cdn.xitu.io/2018/5/8/1633b807bfc36594?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

G1使用建议：

- 避免设置年轻代大小
- 暂停时间不要太苛刻

通过JVM参数 `-XX:+UseG1GC` 使用G1垃圾回收器

## 可视化GC日志分析工具

[gceasy](http://gceasy.io)
