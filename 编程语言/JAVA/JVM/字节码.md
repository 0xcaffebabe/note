# 字节码

- 字节码文件结构
- 字节码生成
- 字节码操作
- 字节码增强
- 字节码反编译与混淆

## Class 文件

- JVM所执行的二进制文件，跨平台的基础
- 满足这种规范的class文件都会被JVM加载运行
- 可以由其他语言编译生成
- 不同版本的JDK生成的类文件略有不同

![批注 2019-12-20 144534](/assets/批注%202019-12-20%20144534.png)

### 构成

类型             | 名称                  | 数量
-------------- | ------------------- | ---------------------
u4             | magic               | 1
u2             | minor_version       | 1
u2             | major_version       | 1
u2             | constant_pool_count | 1
cp_info        | constant_pool       | constant_pool_count-1
u2             | access_flags        | 1
u2             | this_class          | 1
u2             | super_class         | 1
u2             | interfaces_count    | 1
u2             | interfaces          | interfaces_count
u2             | fields_count        | 1
field_info     | fields              | fields_count
u2             | methods_count       | 1
method_info    | methods             | methods_count
u2             | attributes_count    | 1
attribute_info | attributes          | attributes_count

Class 文件中的所有字节存储都是使用大端序

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：

- 无符号数：以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数
   - 以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
- 表：由多个无符号数或者其他表作为数据项构成的复合数据类型

反编译：

```shell
javap -v classname
```

#### 魔数与 Class 文件版本

前4个字节为魔数，十六进制表示为0xCAFEBABE，标识该文件为class文件

第5、6字节表示次版本号（小更新） 第7和第8个字节是主版本号（从45开始，一个大版本加1）

#### 常量池

常量池的入口放置了一项u2类型的数据，代表常量池容量计数值（constant_pool_count），这个数是**从1开始**

- 字面量：接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等
- 符号引用
   - 被模块导出或者开放的包（Package）
   - 类和接口的全限定名（Fully Qualified Name）
   - 字段的名称和描述符（Descriptor）
   - 方法的名称和描述符
   - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic
   - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

#### 访问标志

常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被public、abstract、final等修饰符修饰

标志名称           | 标志值    | 含义
-------------- | ------ | -------------------------------------------------------------------------------------------------------
ACC_PUBLIC     | 0x0001 | 是否为public类型
ACC_FINAL      | 0x0010 | 是否被声明为final，只有类可设置
AcC_SUPER      | 0x0020 | 是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK1.0.2之后编译出来的类的这个标志都必须为真
ACC_INTERFACE  | 0x0200 | 标识这是一个接口
AcC_ABSTRACT   | Ox0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型值为假
AcC_SYNTHETIC  | Ox1000 | 标识这个类并非由用户代码产生的
Acc_ANNOTATION | 0x2000 | 标识这是一个注解
ACC_ENUM       | 0x4000 | 标识这是一个枚举
AcC_MODULE     | 0x8000 | 标识这是一个模块

#### 类索引、父类索引与接口索引集合

- 类索引与父类索引都是一个u2类型的数据
- 接口索引入口的第一项u2类型的数据为接口计数器

#### 字段表集合

- 用于描述类和接口中声明的变量（包括类级以及实例级别）
- 第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。

字段表结构：

类型             | 名称               | 数量
-------------- | ---------------- | ----------------
u2             | access_flags     | 1
u2             | name_index       | 1
u2             | descriptor_index | 1
u2             | attributes_count | 1
attribute_info | attributes       | attributes_count

字段访问标志，存放在access_flags里面：

标志名称          | 标志值    | 含义
------------- | ------ | --------------
ACC_PUBLIC    | Ox0001 | 字段是否public
ACC_PRIVATE   | Ox0002 | 字段是否 private
ACC_PROTECTED | ox0004 | 字段是否 protected
ACC_STATIC    | Ox0008 | 字段是否static
ACC FINAL     | 0x0010 | 字段是否final
ACC_VOLATILE  | Ox0040 | 字段是否 volatile
ACC_TRANSIENT | ox0080 | 字段是否transient
ACC_SYNTHETIC | ox1000 | 字段是否由编译器自动产生
ACC_ENUM      | Ox4000 | 字段是否 enum

name_index和descriptor_index分别代表着字段的简单名称以及字段和方法的描述符

- 简单名称则就是指没有类型和参数修饰的方法或者字段名称

描述符：

标志字符 | 含义
---- | ------------------------
B    | 基本类型byte
C    | 基本类型char
D    | 基本类型double
F    | 基本类型float
I    | 基本类型int
J    | 基本类型1ong
S    | 基本类型short
Z    | 基本类型boolean
V    | 特殊类型void
L    | 对象类型，如Ljava/lang/Object;

对于数组类型，每一维度将使用一个前置的`[`字符来描述，，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”

用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内

方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”

#### 方法表集合

方法表的结构同字段表

方法访问标志：

标志名称             | 标志值    | 含义
---------------- | ------ | -----------------
ACC_PUBLIC       | Ox0001 | 方法是否为public
ACC_PRIVATE      | Ox0002 | 方法是否为private
ACC_PROTECTED    | Ox0004 | 方法是否为protected
ACC_STATIC       | 0x0008 | 方法是否为static
ACC_FINAL        | 0x0010 | 方法是否为final
AcC_SYNCHRONIZED | Ox0020 | 方法是否为synchronized
ACC_BRIDGE       | Ox0040 | 方法是不是由编译器产生的桥接方法
AcC_VARARGS      | Ox0080 | 方法是否接受不定参数
ACC_NATIVE       | Ox0100 | 方法是否为native
ACC_ABSTRACT     | 0x0400 | 方法是否为abstract
AcC_STRICT       | Ox0800 | 方法是否为strictfp
ACC_SYNTHETIC    | Ox1000 | 方法是否由编译器自动产生

方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面

#### 属性表集合

- Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息

属性名称                                 | 使用位置             | 含义
------------------------------------ | ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Code                                 | 方法表              | Java代码编译成的字节码指令
ConstantValue                        | 字段表              | 由final关键字定义的常量值
Deprecated                           | 类、方法表、字段表        | 被声明为deprecated 的方法和字段
Exceptions                           | 方法表              | 方法抛出的异常列表
EnclosingMethod                      | 类文件              | 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标示这个类所在的外围方法类文件
InncrClasses                         | Code属性           | 内部类列表
LineNumberTable                      | Codc属性           | Java 源码的行号与字节码指令的对应关系
LocalVariableTable                   | Code属性           | 方法的局部变量描述
StackMapTable                        | Code属性           | JDK6中新增的属性，供新的类型检查验证器(Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配
Signature                            | 类、方法表、字段表        | JDK 5中新增的属性，用于支持范型情况下的方法签名。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（TypeVariables）或参数化类型（Parameterized Types)，则Signature属性会为它记录泛型签名信息。由于Java的范型采用擦除法实现，为了避免类型信息被擦除后导致签名混乱，需要这个属性记录范型中的相关信息
SourceFile                           | 类文件              | 记录源文件名称
SourceDebugExtension                 | 类文件              | JDK 5中新增的属性，用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号JSR 45提案为这些非Java类文件语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以用于存储这个标准所新加人的调试信息
Synthetic                            | 类、方法表、字段表        | 标识方法或字段为编译器自动生成的
LocalVariablcTypeTable               | 类                | JDK 5中新增的属性，它使用特征签名代替描述符，是为了引人泛型语法之后能描述泛型参数化类型而添加
RuntimeVisibleAnnotations            | 类、方法表、字段表        | JDK 5中新增的属性，为动态注解提供支持。该属性用于指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的
RuntimcInvisiblcAnnotations          | 类、方法表、字段表        | JDK 5中新增的属性，与RuntimeVisibleAnnota-tions属性作用刚好相应，用于指明哪些注解是运行时不可见的
RuntimeVisibleParamcterAnnotations   | 方法表              | JDK5中新增的属性，作用与RuntimeVisible-Annotations属性类似，只不过作用对象为方法参数
RuntimelnvisibleParameterAnnotations | 方法表              | JDK 5中新增的属性，作用与 RuntimelnvisiblcAnnotations属性类似，只不过作用对象为方法参数
AnnotationDefault                    | 方法表              | JDK 5中新增的属性，用于记录注解类元素的默认值
BootstrapMethods                     | 类文件              | JDK 7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符
RuntimeVisibleTypeAnnotations        | 类、方法表、字段表，Code属性 | JDK 8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，用于指明哪些类注解是运行时(实际上运行时就是进行反射调用）可见的
RuntimelnvisibleTypeAnnotations      | 类、方法表、字段表,Code属性 | JDK 8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，与RuntimeVisibleTypeAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的
MethodParameters                     | 方法表              | JDK 8中新增的属性，用于支持（编译时加上-parameters参数）将方法名称编译进 Class文件中，并可运行时获取。此前要获取方法名称（典型的如IDE的代码提示）只能通过JavaDoc中得到
Module                               | 类                | JDK 9中新增的属性，用于记录一个Module的名称以及相关信息（requires.exports.opens, uses .provides)
ModulePackages                       | 类                | JDK9中新增的属性，用于记录一个模块中所有被exports或者opens 的包
ModuleMainClass                      | 类                | JDK9中新增的属性，用于指定一个模块的主类
NestHost                             | 类                | JDK 11中新增的属性，用于支持嵌套类（Java中类的内部类）的反射和访问控制的API，一个内部类通过该属性得知自己的宿主类
NestMembers                          | 类                | JDK 11中新增的属性，用于支持嵌套类（Java中的内部类）的反射和访问控制的API，一个宿主类通过该属性得知自已己有哪些内部类

属性表结构：

类型 | 名称                   | 数量
-- | -------------------- | ----------------
u2 | attribute_name_index | 1
u4 | attribute_length     | 1
u1 | info                 | attribute_length

**1.Code属性**

类型             | 名称                     | 数量                     | 说明
-------------- | ---------------------- | ---------------------- | ----------------------------------------------------------------------------
u2             | attribute_name_index   | 1                      | attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为"Code"，它代表了该属性的属性名称
u4             | attribute_length       | l                      | 属性值的长度
u2             | max_stack              | l                      | 代表了操作数栈（Operand Stack）深度的最大值
u2             | max_locals             | 1                      | 代表了局部变量表所需的存储空间（32位以下（包含）的变量占用一个槽）
u4             | code_length            | 1                      | 执行的字节码长度（《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令）
u1             | code                   | code_length            | 存放执行的字节码
u2             | exception_table_length | 1
exception_info | exception_table        | exception_table_length
u2             | attributes_count       | 1
u2             | attributes_count       | 1
attribute_info | attributes             | attributes_count


```java
public int inc() {return m + 1;}
```

一个方法编译后：

```java
public int inc();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1 //这里的方法虽然没有参数，但是参数数量为1,1就是this
         0: aload_0
         1: getfield      #2                  // Field m:I
         4: iconst_1
         5: iadd
         6: ireturn
      LineNumberTable:
        line 4: 0
```

异常表：

类型 | 名称         | 数量 | 说明
-- | ---------- | -- | --------------
u2 | start_pc   | 1  | 异常捕获起始行
u2 | end_pc     | 1  | 异常捕获结束行（不包含本行）
u2 | handler_pc | 1  | 发生异常后跳转的位置
u2 | catch_type | 1  | 异常的类型

**2.Exceptions属性**

列举出方法中可能抛出的受查异常（Checked Excepitons）

类型 | 名称                    | 数量
-- | --------------------- | --------------------
u2 | attribute_name_index  | 1
u4 | attribute_length      | 1
u2 | number_of_exceptions  | 1
u2 | exception_index_table | number_of_exceptions

**3.LineNumberTable属性**

类型               | 名称                       | 数量
---------------- | ------------------------ | ------------------------
u2               | attribute_name_index     | 1
u4               | attribute_length         | 1
u2               | line_number_table_length | 1
line_number_info | line_number_table        | line_number_table_length

### 内存结构

![](http://blog.cheyo.net/static/file/jvm_memory.png)

### 分类

- 加载和存储指令
  -  用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
- 运算指令
- 类型转换指令
- 对象/数组创建与访问指令
- 操作数栈管理指令
- 控制转移指令
- 方法调用和返回指令
- 异常处理指令
- 同步控制指令

### 组成

- 操作码
- 操作数
- JVM指令集基于栈

### ASM

>ASM是一个通用的Java字节码操作和分析框架

- Core API
  - 不需要读取类的整个结构，使用流式的方法来处理字节码文件
  - 编程难度较大
- Tree API
  - 消耗内存多，但是编程比较简单
  - 通过各种Node类来映射字节码的各个区域

#### 字节码增强

- java agent
  - premain：支持在main函数之前，对类的字节码进行修改/替换
  - agentmain：支持在程序运行过程中，对字节码进行替换

#### 字节码混淆

- 使反编译的代码可读性变差
- ProGuard

### javassist

- 生成类

```java
ClassPool pool = ClassPool.getDefault();
// 创建类
CtClass userClass = pool.makeClass("wang.ismy.test.User");
// 添加属性
userClass.addField(CtField.make("private String name;",userClass));
userClass.addField(CtField.make("private Integer age;",userClass));
// 添加方法
userClass.addMethod(CtMethod.make("public String getName(){return name;}",userClass));
userClass.addConstructor(new CtConstructor(new CtClass[]{pool.get("java.lang.String"),pool.get("java.lang.Integer")},userClass));
userClass.writeFile("./User.class");
```

- 修改类

```java
ClassPool pool = ClassPool.getDefault();
pool.appendClassPath(new ClassClassPath(Main.class));
CtClass userClass = pool.get("wang.ismy.assist.User");
userClass.getDeclaredMethod("getName").setBody("{return name + \"123\";}");
Class<?> aClass = userClass.toClass();
Object obj = aClass.newInstance();
System.out.println(aClass.getMethod("getName").invoke(obj));
```

## 字节码指令

[oracle 官方 pdf](https://docs.oracle.com/javase/specs/jvms/se13/jvms13.pdf)

1. 基于寄存器的指令集
2. 基于栈的指令集
   Hotspot中的Local Variable Table = JVM中的寄存器

### 加载或存储指令

操作数据在虚拟机栈的局部变量表与操作栈之间来回传输

1. 将局部变量加载到操作栈
   1. ILOAD int类型
   2. ALOAD　对象引用
2. 从栈顶存储到局部变量表
   1. ISTORE
   2. ASTORE
3. 将常量加载到操作栈顶
   1. ICONST -1到5的数
   2. BIPUSH　-128 ~ 127
   3. SIPUSH -32768 ~ 32767
   4. LDC int范围的值或者字符串

### 运算指令

对两个操作栈帧上的值进行运算，并把结果写入栈顶

1. IADD
2. IMUL

### 类型转换指令

显式转换两个不同类型的数值

1. I2L
2. D2F

### 对象创建与访问指令

创建　初始化对象　及方法调用

1. 创建　NEW NEWARRAY
2. 访问属性 GETFIELD PUTFIELD GETSTATIC
3. 检查实例类型 INSTANCEOF CHECKCAST

### 操作栈管理指令

1. 出栈 POP POP2
2. 复杂栈顶元素并入栈 DUP

### 方法调用与返回指令

1. InvokeStatic
2. InvokeVirtual 调用对象的实例方法
3. InvokeInterface
4. InovkeSpecial
   可以直接定位，不需要多态的方法
   private 方法 ， 构造方法　父类方法　实例初始化方法
5. InvokeDynamic
   JVM最难的指令
   lambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令
6. RETURN 返回void

### 同步指令

1. ACC_SYNCHRONIZED 标志同步方法
2. MONITORENTER MONITOREXIT 标记临界区

### 其他

LINENUMBER 存储了字节码与源码的对应关系

LOCALVARIABLE 存储当前方法用到的局部变量表

## 字节码的执行

1. 解释执行
2. 编译执行
3. JIT编译与解释混合执行

![截图录屏_选择区域_20200918145300](/assets/截图录屏_选择区域_20200918145300.png)

这样就造成机器在热机所承载的负载可能会比冷机的高

- -Xmixed 默认为混合模式
- -Xint 解释模式
- -Xcomp 纯编译模式

热点代码检测

- 多次被调用的方法 方法计数器
- 多次被被调用的循环 循环计数器

## 代码优化

- 使用局部变量
- 减少重复计算
- 懒加载
- 异常对性能不利
- 避免创建导入不使用的对象和类
- 反射对性能不利
- 连接池和线程池有利于提高性能
- 容器初始化指定长度
- 不同的数据结构在不同操作下的性能表现不同
- 使用键值对遍历Map
- 不应手动调用GC
- 正则表达式对性能有影响
- 日志输出注意级别
- 资源close可以分开

