# 字节码

- 字节码文件结构
- 字节码生成
- 字节码操作
- 字节码增强
- 字节码反编译与混淆

## class 文件

- JVM所执行的二进制文件，跨平台的基础
- 满足这种规范的class文件都会被JVM加载运行
- 可以由其他语言编译生成
- 不同版本的JDK生成的类文件略有不同

![批注 2019-12-20 144534](/assets/批注%202019-12-20%20144534.png)

### 构成

- 包括两种数据类型
  - 定长数据
  - 不定长数据

前4个字节为魔数，十六进制表示为0xCAFEBABE，标识该文件为class文件

第5、6字节表示次版本号

- 反编译

```shell
javap -v classname
```

#### 常量池

- 字面量
- 符号引用

#### 访问标志

常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被public、abstract、final等修饰符修饰

#### 类索引

- 类索引
- 父类索引
- 接口索引

#### 字段表

- 用于描述类和接口中声明的变量
- 第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。

#### 方法表

同字段表

#### 附加属性

- 该项存放了在该文件中类或接口所定义属性的基本信息

### 内存结构

![](http://blog.cheyo.net/static/file/jvm_memory.png)

### 分类

- 加载和存储指令
  -  用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
- 运算指令
- 类型转换指令
- 对象/数组创建与访问指令
- 操作数栈管理指令
- 控制转移指令
- 方法调用和返回指令
- 异常处理指令
- 同步控制指令

### 组成

- 操作码
- 操作数
- JVM指令集基于栈

### ASM

>ASM是一个通用的Java字节码操作和分析框架

- Core API
  - 不需要读取类的整个结构，使用流式的方法来处理字节码文件
  - 编程难度较大
- Tree API
  - 消耗内存多，但是编程比较简单
  - 通过各种Node类来映射字节码的各个区域

#### 字节码增强

- java agent
  - premain：支持在main函数之前，对类的字节码进行修改/替换
  - agentmain：支持在程序运行过程中，对字节码进行替换

#### 字节码混淆

- 使反编译的代码可读性变差
- ProGuard

### javassist

- 生成类

```java
ClassPool pool = ClassPool.getDefault();
// 创建类
CtClass userClass = pool.makeClass("wang.ismy.test.User");
// 添加属性
userClass.addField(CtField.make("private String name;",userClass));
userClass.addField(CtField.make("private Integer age;",userClass));
// 添加方法
userClass.addMethod(CtMethod.make("public String getName(){return name;}",userClass));
userClass.addConstructor(new CtConstructor(new CtClass[]{pool.get("java.lang.String"),pool.get("java.lang.Integer")},userClass));
userClass.writeFile("./User.class");
```

- 修改类

```java
ClassPool pool = ClassPool.getDefault();
pool.appendClassPath(new ClassClassPath(Main.class));
CtClass userClass = pool.get("wang.ismy.assist.User");
userClass.getDeclaredMethod("getName").setBody("{return name + \"123\";}");
Class<?> aClass = userClass.toClass();
Object obj = aClass.newInstance();
System.out.println(aClass.getMethod("getName").invoke(obj));
```

## 字节码指令

[oracle 官方 pdf](https://docs.oracle.com/javase/specs/jvms/se13/jvms13.pdf)

1. 基于寄存器的指令集
2. 基于栈的指令集
   Hotspot中的Local Variable Table = JVM中的寄存器

### 加载或存储指令

操作数据在虚拟机栈的局部变量表与操作栈之间来回传输

1. 将局部变量加载到操作栈
   1. ILOAD int类型
   2. ALOAD　对象引用
2. 从栈顶存储到局部变量表
   1. ISTORE
   2. ASTORE
3. 将常量加载到操作栈顶
   1. ICONST -1到5的数
   2. BIPUSH　-128 ~ 127
   3. SIPUSH -32768 ~ 32767
   4. LDC int范围的值或者字符串

### 运算指令

对两个操作栈帧上的值进行运算，并把结果写入栈顶

1. IADD
2. IMUL

### 类型转换指令

显式转换两个不同类型的数值

1. I2L
2. D2F

### 对象创建与访问指令

创建　初始化对象　及方法调用

1. 创建　NEW NEWARRAY
2. 访问属性 GETFIELD PUTFIELD GETSTATIC
3. 检查实例类型 INSTANCEOF CHECKCAST

### 操作栈管理指令

1. 出栈 POP POP2
2. 复杂栈顶元素并入栈 DUP

### 方法调用与返回指令

1. InvokeStatic
2. InvokeVirtual 调用对象的实例方法
3. InvokeInterface
4. InovkeSpecial
   可以直接定位，不需要多态的方法
   private 方法 ， 构造方法　父类方法　实例初始化方法
5. InvokeDynamic
   JVM最难的指令
   lambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令
6. RETURN 返回void

### 同步指令

1. ACC_SYNCHRONIZED 标志同步方法
2. MONITORENTER MONITOREXIT 标记临界区

### 其他

LINENUMBER 存储了字节码与源码的对应关系

LOCALVARIABLE 存储当前方法用到的局部变量表

## 代码优化

- 使用局部变量
- 减少重复计算
- 懒加载
- 异常对性能不利
- 避免创建导入不使用的对象和类
- 反射对性能不利
- 连接池和线程池有利于提高性能
- 容器初始化指定长度
- 不同的数据结构在不同操作下的性能表现不同
- 使用键值对遍历Map
- 不应手动调用GC
- 正则表达式对性能有影响
- 日志输出注意级别
- 资源close可以分开

