{"name":"字节码执行引擎","id":"编程语言-JAVA-JVM-字节码执行引擎","content":"# 字节码执行引擎\n\n## 字节码的执行\n\n1. 解释执行\n2. 编译执行\n3. JIT编译与解释混合执行\n\n```mermaid\nflowchart TD\n    A[方法调用] --> B{已编译?}\n    B -->|是| C[执行编译后的机器码]\n    B -->|否| D[方法调用计数器加1]\n    D --> E{计数是否超过阈值?}\n    E -->|否| F[解释方式执行]\n    E -->|是| H[提交编译请求]\n    H --> I[编译器]\n    I --> J[后台执行编译]\n    J --> K[Code Cache]\n    K --> C\n\n    C --> 方法返回\n    F --> 方法返回\n\n```\n\n这样就造成机器在热机所承载的负载可能会比冷机的高\n\n- -Xmixed 默认为混合模式\n- -Xint 解释模式\n- -Xcomp 纯编译模式\n\n热点代码检测\n\n- 多次被调用的方法 方法计数器\n- 多次被被调用的循环 循环计数器\n\n还有一种新的编译方式，即所谓的 AOT（Ahead-of-Time Compilation），直接将字节码编译成机器代码，这是 graalvm 所做的\n\n## 运行时栈帧结构\n\n用于支持虚拟机进行方法调用和方法执行背后的数据结构\n\n栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息\n\n每个栈帧的大小在编译期就已经确定（根据局部变量表 操作数栈等）\n\n### 局部变量表\n\n用于存放方法参数和方法内部定义的局部变量，方法的Code属性max_locals数据项确定了局部变量表的最大容量\n\n规范说到每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据\n\n虚拟机实现至少都应当能通过reference做两件事：\n\n- 根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引\n- 根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息\n\n对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间\n\n局部变量表中的变量槽是可以重用的，但是这种重用会影响到垃圾回收，如果垃圾收集器发现变量表还存在某个变量的引用 就不会轻易回收它：\n\n```java\nbyte[] bytes = new byte[1024 * 1024 * 128];\nbytes = null; // 不加上这行 bytes不会在gc被调用时被回收\nSystem.gc();\n```\n\n### 操作数栈\n\n操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中\n\n用来支持各种指令操作\n\n### 动态连接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用\n\n### 方法返回地址\n\n方法执行后 有两种方式退出方法：\n\n- 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者\n- 方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理\n\n方法退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中\n\n### 附加信息\n\n《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息\n\n## 方法调用\n\n方法调用是最普遍、最频繁的操作之一\n\n方法调用的指令：\n\n- invokestatic：用于调用静态方法。\n- invokespecial：用于调用实例构造器`<init>()`方法、私有方法和父类中的方法\n- invokevirtual:用于调用所有的虚方法\n- invokeinterface:用于调用接口方法，会在运行时再确定一个实现该接口的对象\n- invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法\n\n只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本, 这些方法被称为非虚方法\n\n```java\npublic static void say(){\n    System.out.println(\"hello world\");\n}\npublic static void main(String[] args) {\n    say();\n}\n```\n\n```java\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=0, locals=1, args_size=1\n         0: invokestatic  #21                 // Method say:()V\n         3: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 3\n```\n\n### 分派\n\n静态类型：编译时能确定的类型\n\n所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载\n\n编译过程中，编译器会暂时用符号引用来表示目标方法，这些符号引用存在类常量池中\n\n```java\nstatic void f(Object obj){\n    System.out.println(\"obj\");\n}\nstatic void f(CharSequence seq){\n    System.out.println(\"seq\");\n}\nstatic void f(String str){\n    System.out.println(\"str\");\n}\npublic static void main(String[] args) {\n    Object obj = \"str\";\n    CharSequence seq = \"str\";\n    String str = \"str\";\n    f(obj); // obj\n    f(seq); // seq\n    f(str); // str\n}\n```\n\n#### 动态分派\n\n方法覆写的话会在运行时动态决定应该调用哪个方法\n\ninvokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，只有方法才会参与多态 字段没有invokevirtual相关指令 所以字段不会多态\n\n#### 单分派与多分派\n\n- 静态多分派：根据参数来决定\n- 动态单分派：根据被调用的对象决定\n\n### 虚拟机动态分派的实现\n\n为了性能 JVM不会频繁搜索类元数据 而是使用了一个虚方法表：\n\n![屏幕截图 2020-10-29 145045](/assets/屏幕截图%202020-10-29%20145045.png)\n\n## 动态类型语言支持\n\n- invokedynamic指令，用以支持动态语言的方法调用，它将调用点（CallSite）抽象成一个 Java 类，并且将原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序\n\n动态类型语言：类型检查的主体过程是在运行期而不是编译期进行的\n\n虚方法调用对性能的会影响 JVM 使用内联缓存加速动态绑定\n\n### java.lang.invoke\n\n模拟invokedynamic:\n\n```java\n                                              // 返回值类型  参数类型\nMethodType methodType = MethodType.methodType(void.class, String.class);\nObject obj = System.out;\nMethodHandle methodHandle = MethodHandles.lookup()\n        .findVirtual(obj.getClass(), \"println\", methodType).bindTo(obj);\nmethodHandle.invoke(\"hello world\");\n```\n\nMethodHandle是在模拟字节码层次的方法调用 反射API只能为Java服务 使用invoke包可以用来开发动态语言\n\n### 实战 自己控制方法调用\n\n```java\nstatic class GrandFather {\n    void thinking() {\n        System.out.println(\"i am grandfather\");\n    }\n}\nstatic class Father extends GrandFather {\n    void thinking() {\n        System.out.println(\"i am father\");\n    }\n}\n\nstatic class Son extends Father {\n    void thinking() {\n        // 在这里填入适当的代码（不能修改其他地方的代码）\n        // 实现调用祖父类的thinking()方法，打印\"i am grandfather\"\n        try {\n            MethodType mt = MethodType.methodType(void.class);\n            Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n           lookupImpl.setAccessible(true);\n           MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(null)).findSpecial(GrandFather.class, \"thinking\", mt, GrandFather.class);\n                try {\n                    mh.invoke(this);\n                } catch (Throwable throwable) {\n                    throwable.printStackTrace();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n```\n\n## 执行引擎\n\n- 解释执行\n\n早期的JVM是通过解释字节码来执行的 但后面也出现了编译为本地机器码的编译器 所以现代的Java是拥有编译模式以及解释模式亦或者混合模式\n\n- 基于栈\n\n对于JVM来说 基于栈移植容易 实现容易\n\n栈架构指令集的缺点在于速度稍慢\n\n### 实战：分析一段简单的四则运算\n\n```java\npublic int calc(){\n    int a = 100;\n    int b = 200;\n    int c = 300;\n    return (a + b) * c;\n}\n```\n```java\npublic int calc();\n    descriptor: ()I\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: bipush        100\n         2: istore_1\n         3: sipush        200\n         6: istore_2\n         7: sipush        300\n        10: istore_3\n        11: iload_1\n        12: iload_2\n        13: iadd\n        14: iload_3\n        15: imul\n        16: ireturn\n      LineNumberTable:\n        line 9: 0\n        line 10: 3\n        line 11: 7\n        line 12: 11\n```\n\njavap提示这段代码需要深度为2的操作数栈和4个变量槽的局部变量空间\n\n1.Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶 参数为100\n\n![屏幕截图 2020-10-29 153202](/assets/屏幕截图%202020-10-29%20153202.png)\n\n2.istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中 后面的istore 以及xxpush都是一样\n\n![屏幕截图 2020-10-29 153409](/assets/屏幕截图%202020-10-29%20153409.png)\n\n3.iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶\n\n![屏幕截图 2020-10-29 153448](/assets/屏幕截图%202020-10-29%20153448.png)\n\n4.load_2指令的执行过程与iload_1类似，把第2个变量槽的整型值入栈\n\n![屏幕截图 2020-10-29 153545](/assets/屏幕截图%202020-10-29%20153545.png)\n\n5.iadd指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，然后把结果重新入栈\n\n![屏幕截图 2020-10-29 153628](/assets/屏幕截图%202020-10-29%20153628.png)\n\n6.iload_3指令把存放在第3个局部变量槽中的300入栈到操作数栈中\n\n![屏幕截图 2020-10-29 153701](/assets/屏幕截图%202020-10-29%20153701.png)\n\n7.指令imul是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后\n把结果重新入栈，与iadd完全类似\n\n8.ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给该方法的调用者\n\n![屏幕截图 2020-10-29 153756](/assets/屏幕截图%202020-10-29%20153756.png)\n","metadata":"","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2024-11-18T19:42:07+08:00","author":"MY","message":"📦JVM 字节码","hash":"de7fc529ef5744108380126f7cdeaa6a45e0bb8c"},{"date":"2023-08-20T15:43:00+08:00","author":"MY","message":"✏️JVM","hash":"ec497f7b6e48d763cece8e02546081140ea80280"},{"date":"2023-08-18T20:12:28+08:00","author":"MY","message":"✏JVM","hash":"fb061ff5146d1bb3017b1c0c2d4bf2f8008e67e1"},{"date":"2020-11-02T16:15:39+08:00","author":"MY","message":"✏更新 JVM 执行引擎","hash":"f8a5c867fca37958cca59a97da23dcfa54cb96ed"},{"date":"2020-10-29T15:39:01+08:00","author":"MY","message":"✏更新 JVM 字节码执行引擎","hash":"757e8557ba566bba5bd7cb51606b8f9ebadeeae2"},{"date":"2020-10-28T20:11:52+08:00","author":"MY","message":"✏更新 Ruby","hash":"4583433c2f51b76fb98c390702ec1b108926f85b"}],"createTime":"2020-10-28T20:11:52+08:00"}