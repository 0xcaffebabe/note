# 类加载机制

## 生命周期

![202031694011](/assets/202031694011.png)

## 类加载过程

### 加载

- 通过类的完全限定名称获取该类的二进制字节流
  - 可从zip包读取，如jar、war
  - 可从网络获取
  - 运行时动态生成
- 将字节流表示的静态存储结构转换为方法区的运行时存储结构
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口

### 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求

### 准备

准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存

### 解析

将常量池的符号引用替换为直接引用的过程

### 初始化

初始化阶段是虚拟机执行类构造器 `<clinit>()` 方法的过程

`<clinit>()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的

## 类加载时机

### 主动引用

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化
- 对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化
- 始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类

### 被动引用

除此主动引用外，所有引用类的方式都不会触发初始化，称为被动引用

- 子类引用父类的静态字段
- 定义一个该类的数组
- 引用该类的常量

## 类加载器

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载

### 分类

- 按虚拟机角度
  - 启动类加载器，使用 C++ 实现，是虚拟机自身的一部分
  - 其他类加载器，都是JAVA中继承自java.lang.ClassLoader的类加载器
- 按JAVA开发人员角度
  - 启动类加载器
  - 扩展类加载器
  - 应用程序类加载器

### 双亲委派模型

![2020316101321](/assets/2020316101321.png)

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载

这样就使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一

所以系统中的String类加载优先级就会比在classpath或者用户自定义的String类优先级更高