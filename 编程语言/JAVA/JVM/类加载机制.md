# 类加载机制

## 生命周期

![202031694011](/assets/202031694011.png)
![批注 2020-07-15 085357](/assets/批注%202020-07-15%20085357.png)

## 类加载过程

将.class字节流实例化成Class对象并进行相关初始化的过程

### 加载

- 通过类的完全限定名称获取该类的二进制字节流
  - 可从zip包读取，如jar、war
  - 可从网络获取
  - 运行时动态生成
- 将字节流表示的静态存储结构转换为方法区的运行时存储结构
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口

### 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求

### 准备

准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存

### 解析

确保类与类之间的相互引用正确性

将常量池的符号引用替换为直接引用的过程

### 初始化

初始化阶段是虚拟机执行类构造器 `<clinit>()` 方法的过程

`<clinit>()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的

## 类加载时机

### 主动引用

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化
- 对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化
- 始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类

### 被动引用

除此主动引用外，所有引用类的方式都不会触发初始化，称为被动引用

- 子类引用父类的静态字段
- 定义一个该类的数组
- 引用该类的常量

## 类加载器

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载

负责查找、加载、校验字节码的应用程序

### 分类

- 按虚拟机角度
  - 启动类加载器，使用 C++ 实现，是虚拟机自身的一部分 系统类rt.jar
  - 其他类加载器，都是JAVA中继承自java.lang.ClassLoader的类加载器
- 按JAVA开发人员角度
  - 启动类加载器 jre/lib/ext
  - 扩展类加载器 classpath
  - 应用程序类加载器 程序自定义

### 双亲委派模型

![2020316101321](/assets/2020316101321.png)

- 首先判断是否已经加载
- 若无，找父加载器加载
- 若再无，由当前加载器加载
- 上级类加载器所加载的类，无法访问下级类加载器所加载的类

![批注 2020-07-15 092654](/assets/批注%202020-07-15%20092654.png)

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载

这样就使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一

所以系统中的String类加载优先级就会比在classpath或者用户自定义的String类优先级更高

### 自定义类加载路径

- 使用URLClassLoader

```java
URL url = new URL("file:~/mysql-connector-java-5.1.44-bin.jar");
URLClassLoader loader = new URLClassLoader(new URL[]{url});
Class<?> klass = loader.loadClass("com.mysql.jdbc.Driver");
System.out.println(klass);
```

- 获取当前线程类加载器

```java
ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
```

- 热部署

### 自定义类加载器

- 模板方法模式

findInCache -> parent.loadClass -> findClass()

```java
class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        if ("wang.ismy.Main".equals(name)){
            byte[] bytes = new byte[0];
            try {
                bytes = new FileInputStream("path").readAllBytes();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return defineClass(name,bytes,0,bytes.length);
        }else {
            return super.findClass(name);
        }
    }
}
```

自定义类加载器的场景：

1. 隔离加载类 确保中间件应用的jar不会影响到中间件的jar
2. 修改加载方式 从其他地方获取class字节流
3. 字节码加解密

## 打破双亲委派

- JDK1.2之前 自定义ClassLoader必须重写loadClass
- ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定
