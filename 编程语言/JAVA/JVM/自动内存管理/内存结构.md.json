{"name":"内存结构","id":"编程语言-JAVA-JVM-自动内存管理-内存结构","content":"# 内存结构\n\n## 总体内存结构\n\n名称     | 线程私有/共享 | 功能            | 大小                | 异常\n------ | ------- | ------------- | ----------------- | -----------------------------------\n程序计数器  | 私有      | 保存当前线程执行方法    | 通常固定大小            | 不会\nJVM栈(VMS)   | 私有      | 方法的栈帧         | -Xss              | StackOverflowError,OutOfMemoryError\n本地方法栈(NMS)  | 私有      | 存储native方法信息  | 通常会固定大小           | StackOverflowError,OutOfMemoryError\n堆      | 共享      | 存储对象和数组       | -Xms初始堆值,-Xmx最大堆值 | OutOfMemoryError\n方法区    | 共享      | 存储类结构 常量 静态变量 | -XX参数             | OutOfMemoryError\n运行时常量池 | 共享      | 常量池运行时表示      | 从属于方法区            | OutOfMemoryError\n直接内存 | 共享 | 一般是为了提升性能所使用 | -XX:MaxDirectMemorySize参数控制| OutOfMemoryError\n\n```mermaid\nmindmap\n    root((内存结构))\n        JVM Stacks\n            frame\n        Program Counter\n        Heap\n        Method Area\n            runtime constant pool\n        Native Method Stacks\n        Direct Memory\n```\n\n```mermaid\nstateDiagram-v2\n    state 线程A {\n        PC1 VMS1 NMS1\n    }\n    state 线程B {\n        PC2 VMS2 NMS2\n    }\n    state 线程C {\n        PC3 VMS3 NMS3\n    }\n    线程A --> Heap\n    线程B --> Heap\n    线程C --> Heap\n\n```\n\n![截图录屏_选择区域_20200918152033](/assets/截图录屏_选择区域_20200918152033.png)\n\n### PC 程序计数器\n\n用来存放执行指令的偏移量和行号指示器等\n\nJava虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器\n\n> 存放指令位置\n> 虚拟机的运行，类似于这样的循环：\n\n```c\nwhile( not end ) {\n\n​\t取PC中的位置，找到对应位置的指令；\n​\t执行该指令；\n​\tPC ++;\n\n}\n```\n\n### JVM Stack\n\n每个线程私有\n\n![截图录屏_选择区域_20200918153359](/assets/截图录屏_选择区域_20200918153359.png)\n\n1. Frame - 每个方法对应一个栈帧\n   1. Local Variable Table　局部变量表\n      存放方法参数和局部变量的区域\n   2. Operand Stack　操作栈\n      各种指令往栈中写入或者读取信息\n      对于long的处理（store and load），多数虚拟机的实现都是原子的\n      jls 17.7，没必要加volatile\n   3. Dynamic Linking　动态连接\n      常量池中一个对当前方法的引用\n      https://blog.csdn.net/qq_41813060/article/details/88379473 \n      jvms 2.6.3\n   4. return address　方法返回地址\n      a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方\n\n### 本地方法栈\n\n为本地方法服务\n\n### 堆\n\n- 共享，内存大户，存储所有的对象和数组\n- 是垃圾收集器管理的内存区域\n- 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率\n- -Xms(memory start) 初始堆值，-Xmx(memory max)最大堆值\n\n### 方法区\n\n各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据\n\n1. 1.8之前被HotSpot使用一个永久代实现\n   字符串常量位于永久代\n   FGC不会清理\n   这区域的内存回收目标主要是针对常量池的回收和对类型的卸载 但是类型卸载条件十分苛刻\n   大小启动的时候指定，不能变\n2. Meta Space (>=1.8)\n   字符串常量位于堆\n   会触发FGC清理\n   不设定的话，最大就是物理内存\n\n#### 运行时常量池\n\n是方法区的一部分\n\n用于存放编译期生成的各种字面量与符号引用\n\nJava语言并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中，比如String.intern()\n\n### 直接内存\n\n> JVM可以直接访问的内核空间的内存 (OS 管理的内存)\n> NIO ， 提高效率，实现zero copy\n\n一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据\n\n本机直接内存的分配不会受到Java堆大小的限制\n\n## 对象的创建\n\n- 内存分配\n   - 把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”\n   - 如果没有一块完整的空闲内存 就无法使用这种方法了\n- 线程安全的保证 分配时 多个线程并发执行\n   - 虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性\n   - 另外一种方式是每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB） 只有这个缓冲区用完了 才会在堆中分配\n\n## 对象内存布局\n\n- 以下分析都是基于HotSpot虚拟机\n\n```text\n普通对象\n4 或 8 字节        | 4 或 8 字节          |\nmarkdord(对象标记)|class pointer(类型指针)|instance data(实例数据)|padding(对齐)\n数组\n4 或 8 字节        | 4 或 8 字节          | 4 字节        |\nmarkdord(对象标记)|class pointer(类型指针)|length(数组长度)|instance data(实例数据)|padding(对齐)\n```\n\n1. 对象头\n   1. 对象本身运行时的数据 哈希吗 GC标记 锁信息等等\n   2. 类元信息：指向Class的指针 \n2. 实例数据：实例成员变量及所有可见的父类成员变量\n3. 对齐填充\n\n锁升级：无锁状态 -> 偏向锁 -> 自旋锁 -> 重量级锁\n\n![32位虚拟机对象头](/assets/批注%202020-07-27%20091839.png)\n\n![64位虚拟机对象头](/assets/批注%202020-05-12%20145237.png)\n\n64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位，开启指针压缩后，对象头中的类型指针会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节，虚拟机通过使用一个 32 位偏移量来表示对象引用，从而降低指针所需要的数据位数，这意味着虚拟机需要对对象的内存进行填充以及重新排列变量的顺序以实现对齐，\n\n**Hotspot开启内存压缩的规则**\n\nUseCompressedOopsClassPointers\n\nUseCompressedOops\n\n1. 4G以下，直接砍掉高32位\n2. 4G - 32G，默认开启内存压缩 ClassPointers Oops\n3. 32G，压缩无效，使用64位\n\n## 对象定位\n\n- 句柄方式\n\n```mermaid\nstateDiagram-v2\n    state 栈 {\n        ref --> 句柄池\n    }\n    state 堆 {\n        state 句柄池 {\n            实例数据指针 --> 对象实例数据\n            类型数据指针 --> 对象类型数据\n        }\n        对象实例数据\n    }\n    state 方法区 {\n        对象类型数据\n    }\n```\n\n- 直接定位\n\n```mermaid\nstateDiagram-v2\n    state 栈 {\n        ref --> 对象实例数据\n    }\n    state 堆 {\n        state 对象实例数据 {\n            类型数据指针 --> 对象类型数据\n        }\n    }\n    state 方法区 {\n        对象类型数据\n    }\n```\n\n\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销\n\n## 对象实例化\n\n### 字节码角度\n\n```java\nObject ref = new Object()\n```\n\n得到字节码:\n\n```\nstack=2, locals=2, args_size=1\n   0: new           #2                  // class java/lang/Object\n   3: dup\n   4: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n   7: astore_1\n   8: return\n\n```\n\nnew:\n\n1. 如果类不存在　就先进行类加载\n2. 为所有属性值分配内存\n3. 对所有属性值进行０值初始化\n4. 最后将指向实例对象的引用变量压入虚拟机栈顶\n\ndup:\n\n1. 在栈顶复制实例对象的引用变量\n   1. 复制出来的这个变量用来作为句柄调用相关方法\n   2. 早一点的那个变量则是用来赋值\n\ninvokespecial:\n\n1. 通过上面dup复制的变量调用对象的`<init>` 方法\n\n### 从执行步骤\n\n1. 确认类信息是否存在于metaspace 否则使用类加载器加载类　并生成相关Class对象\n2. 计算对象占用的内存空间(实例数据) 接下来在堆内存划分一块空间进行分配　为对象分配内存时　需要进行同步操作\n3. 设定成员变量的默认值\n4. 设置对象头　哈希吗　GC信息等等\n5. 执行init方法　初始化成员变量　执行初始化代码块等等\n\n## 查看堆内存使用情况\n\n- 使用jstat命令\n\n```shell\njstat -class pid # 查看加载的类\njstat -gc pid # 查看垃圾回收情况\n```\n\n## 内存分析\n\n- jmap命令\n\n```shell\njmap -histo pid # 查看所有对象\njmap -histo:live pid # 查看所有存活对象\njmap -dump:format=b,file=filename pid # 导出dump文件\n```\n\n- jhat分析dump文件\n    - JDK9以后不再提供，被Visual VM代替\n\n```shell\njhat filename\n```\n\n- mat分析\n\n### 内存溢出定位与分析\n\n#### Java 堆溢出\n\n- 添加运行参数\n\n```sh\njava -Xmx8m -Xms8m -XX:+HeapDumpOnOutOfMemoryError\n```\n\n```java\nList<Object> list = new ArrayList<>();\nwhile (true){\n    list.add(new Object());\n}\n```\n\n- 分析dump文件\n   - 如果是内存泄漏 找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们\n   - 如果内存中的对象确实都是必须存活的，那就应当检查Java虚拟机\n的堆参数（-Xmx与-Xms）设置\n\n#### 虚拟机栈和本地方法栈溢出\n\n```sh\n-Xss256k\n```\n\n- 减少栈内存容量 异常出现时输出的堆栈深度相应缩小\n\n```java\npublic class JVMSOFWithMinStack {\n    private int stackLength = 1;\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n    public static void main(String[] args) throws Throwable {\n        JVMSOFWithMinStack oom = new JVMSOFWithMinStack();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength); // 3183\n            throw e;\n        }\n    }\n}\n```\n\n- 定义了大量的本地变量 异常出现时输出的堆栈深度相应缩小\n\n```java\npublic class JVMSOFWithMuchParams {\n    private static int stackLength = 0;\n\n    public static void test() {\n        long unused1, unused2, unused3, unused4, unused5,\n                unused6, unused7, unused8, unused9, unused10,\n                unused11, unused12, unused13, unused14, unused15,\n                unused16, unused17, unused18, unused19, unused20,\n                unused21, unused22, unused23, unused24, unused25,\n                unused26, unused27, unused28, unused29, unused30,\n                unused31, unused32, unused33, unused34, unused35,\n                unused36, unused37, unused38, unused39, unused40,\n                unused41, unused42, unused43, unused44, unused45,\n                unused46, unused47, unused48, unused49, unused50,\n                unused51, unused52, unused53, unused54, unused55,\n                unused56, unused57, unused58, unused59, unused60,\n                unused61, unused62, unused63, unused64, unused65,\n                unused66, unused67, unused68, unused69, unused70,\n                unused71, unused72, unused73, unused74, unused75,\n                unused76, unused77, unused78, unused79, unused80,\n                unused81, unused82, unused83, unused84, unused85,\n                unused86, unused87, unused88, unused89, unused90,\n                unused91, unused92, unused93, unused94, unused95,\n                unused96, unused97, unused98, unused99, unused100;\n        stackLength++;\n        test();\n        unused1 = unused2 = unused3 = unused4 = unused5 =\n                unused6 = unused7 = unused8 = unused9 = unused10 =\n                        unused11 = unused12 = unused13 = unused14 = unused15 =\n                                unused16 = unused17 = unused18 = unused19 = unused20 =\n                                        unused21 = unused22 = unused23 = unused24 = unused25 =\n                                                unused26 = unused27 = unused28 = unused29 = unused30 =\n                                                        unused31 = unused32 = unused33 = unused34 = unused35 =\n                                                                unused36 = unused37 = unused38 = unused39 = unused40 =\n                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =\n                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =\n                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =\n                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =\n                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =\n                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =\n                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =\n                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =\n                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =\n                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =\n                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =\n                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = 0;\n    }\n\n    public static void main(String[] args) {\n        try {\n            test();\n        } catch (Error e) {\n            System.out.println(\"stack length:\" + stackLength); // 127\n            throw e;\n        }\n    }\n}\n```\n\n#### 方法区和运行时常量池溢出\n\n在JDK7和7之前如果大量创建String.intern或者动态类 由于类的回收条件苛刻 极有可能造成OOM\n\n但在JDK8之后 这些问题就没有了\n\n#### 本机直接内存溢出\n\n```sh\n-Xmx20M -XX:MaxDirectMemorySize=10M\n```\n\n```java\npublic class DirectMemoryOOM {\n    private static final int _1MB = 1024 * 1024;\n    public static void main(String[] args) throws Exception {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n}\n```\n\n直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常\n\n### 分析线程执行情况\n\n```shell\njstack pid\n```\n\n- 死锁\n\n> 两个进程互相等待对方，一直阻塞下去\n\n```text\nFound one Java-level deadlock:\n=============================\n\"Thread-0\":\n  waiting to lock monitor 0x000002292014eb00 (object 0x00000000ffea7640, a java.lang.Object),\n  which is held by \"Thread-1\"\n\"Thread-1\":\n  waiting to lock monitor 0x000002292014ea00 (object 0x00000000ffea7630, a java.lang.Object),\n  which is held by \"Thread-0\"\n\nJava stack information for the threads listed above:\n===================================================\n\"Thread-0\":\n        at Main.lambda$main$0(Main.java:24)\n        - waiting to lock <0x00000000ffea7640> (a java.lang.Object)\n        - locked <0x00000000ffea7630> (a java.lang.Object)\n        at Main$$Lambda$14/0x0000000800ba4840.run(Unknown Source)\n        at java.lang.Thread.run(java.base@13/Thread.java:830)\n\"Thread-1\":\n        at Main.lambda$main$1(Main.java:37)\n        - waiting to lock <0x00000000ffea7630> (a java.lang.Object)\n        - locked <0x00000000ffea7640> (a java.lang.Object)\n        at Main$$Lambda$15/0x0000000800ba4c40.run(Unknown Source)\n        at java.lang.Thread.run(java.base@13/Thread.java:830)\n\nFound 1 deadlock.\n```\n\n## JMX\n\n>JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理\n","metadata":"","hasMoreCommit":true,"totalCommits":21,"commitList":[{"date":"2025-09-21T14:03:43+08:00","author":"MY","message":"docs(mindmap): 统一思维导图根节点格式","hash":"44fc90fa0f22040d171dbf83cd6f2fd8c020444a"},{"date":"2025-01-13T13:37:42+08:00","author":"MY","message":"📦JVM 内存结构","hash":"4732c339293308b9d484462a0aa6994c52a237c9"},{"date":"2024-11-18T18:25:45+08:00","author":"MY","message":"📦JVM 内存结构","hash":"1aaa980dac5a310bb3a42d28c6d7e4ef54b9d2d0"},{"date":"2023-12-11T15:00:28+08:00","author":"MY","message":"📦内存结构","hash":"84798ac34a724ea332b4f2afbbf941472e78850e"},{"date":"2023-08-21T20:12:20+08:00","author":"MY","message":"✏JVM","hash":"593f0284b1b968f0d8db08aceae7d6cdef1f059f"},{"date":"2021-03-28T16:00:24+08:00","author":"MY","message":"✏更新 JVM 内存结构","hash":"ba408ef56453c3de9bbc2dbf7b458612a05103b9"},{"date":"2020-10-23T14:15:18+08:00","author":"MY","message":"📦重构 JVM结构","hash":"b598a26128a75b53d91d42266153f411e005915b"},{"date":"2020-10-18T15:19:50+08:00","author":"MY","message":"✏更新 JVM 内存结构","hash":"a6ae2649ccf7629657d8747ed185bc196fcd9e24"},{"date":"2020-09-18T16:16:43+08:00","author":"0xcaffebabe","message":"✏更新 内存结构","hash":"1c41143c55611203d643eeac8ea72f792c19d1e4"},{"date":"2020-09-16T15:31:41+08:00","author":"MY","message":"✏更新 JVM 对象内存布局","hash":"8ad39bee9706e7a2254c3e62c072b6274375614f"}],"createTime":"2019-11-22T22:35:23+08:00"}