{"name":"ByteBuf","id":"编程语言-JAVA-框架-netty-ByteBuf","content":"# ByteBuf\n\n数据容器\n\n- 可以进行扩展\n- 容量按需增长\n- 读写切换不需要调用flip\n- 读写使用不同索引\n- 方法链式调用\n- 引用计数\n- 池化\n\n![批注 2020-07-07 105759](/assets/批注%202020-07-07%20105759.png)\n\n## [零拷贝](/操作系统/输入输出.md#零拷贝)\n\nNetty 零拷贝完全是基于（Java 层面）用户态的，不同于操作系统中的零拷贝，操作系统的零拷贝描述的是用户态与内核态之间的内存拷贝。Netty 的更多的是偏向于数据操作优化：\n\n1. 通过 wrap 操作把字节数组、ByteBuf、ByteBuffer 包装成一个 ByteBuf 对象, 进而避免了拷贝操作\n2. 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝\n3. CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝\n4. 堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝\n\n## 使用模式\n\n- 堆缓冲区\n\nByteBuf将数据存储在JVM的堆空间中\n\n```java\nByteBuf heapBuf = ...;\nif (heapBuf.hasArray()) {  ← --  检查ByteBuf 是否有一个支撑数组\n　　byte[] array = heapBuf.array();  ← --  如果有，则获取对该数组的引用　\n　　int offset = heapBuf.arrayOffset() + heapBuf.readerIndex();  ← --  计算第一个字节的偏移量。\n　　int length = heapBuf.readableBytes();　 ← --  获得可读字节数\n　　handleArray(array, offset, length);　 ← --  使用数组、偏移量和长度作为参数调用你的方法\n}\n```\n\n- 直接缓冲区\n\n这种模式下的ByteBuf支持通过本地调用分配内存\n\n所以直接缓冲区的数据在堆外，不会被GC处理\n\n```java\nByteBuf directBuf = ...; \nif (!directBuf.hasArray()) {  ← --  检查ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区\n　　int length = directBuf.readableBytes();  ← --  获取可读字节数\n　　byte[] array = new byte[length];　 ← --  分配一个新的数组来保存具有该长度的字节数据　　\n　　directBuf.getBytes(directBuf.readerIndex(), array);  ← --  将字节复制到该数组\n　　handleArray(array, 0, length);  ← --  使用数组、偏移量和长度作为参数调用你的方法\n}\n```\n\n- 复合缓冲区\n\n这种模式下允许多个ByteBuf聚合起来，提供一个ByteBuf整体视图来进行操作\n\n## 字节级操作\n\n- 随机访问\n\n```java\nByteBuf buffer = ...;\nfor (int i = 0; i < buffer.capacity(); i++) {\n　　byte b = buffer.getByte(i);\n　　System.out.println((char)b);\n}\n```\n\n不会改变索引的值\n\n- 顺序访问\n\n![批注 2020-07-07 110658](/assets/批注%202020-07-07%20110658.png)\n\n调用discardReadBytes()可以回收可丢弃字节的空间\n\n读取所有数据\n\n```java\nByteBuf buffer = ...;\nwhile (buffer.isReadable()) {\n　　System.out.println(buffer.readByte());\n}\n```\n\n写入数据\n\n```java\nByteBuf buffer = ...;\nwhile (buffer.writableBytes() >= 4) {\n　　buffer.writeInt(random.nextInt());\n}\n```\n\n- 索引管理\n  - readerIndex(int)：设置读索引位置\n  - writerIndex(int)： 设置写索引位置\n  - clear()：将读索引写索引重置为0\n\n- 查找\n\n```java\n// 查找回车符(\\r)\nByteBuf buffer = ...;\nint index = buffer.forEachByte(ByteBufProcessor.FIND_CR);\n```\n\n- 派生缓冲区\n\n  - duplicate()\n  - slice()\n  - slice(int, int)\n  - Unpooled.unmodifiableBuffer(…)\n  - order(ByteOrder)\n  - readSlice(int)\n  - copy()\n\n这些方法都会返回一个新的ByteBuf实例\n\n- 读/写\n  - get和set操作，从给定的索引开始，并且保持索引不变；\n  - read和write操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。\n- 其他操作\n\n名称                | 描述\n----------------- | ----------------------------------------------------------------------\n`isReadable()`    | 如果至少有一个字节可供读取，则返回`true`\n`isWritable()`    | 如果至少有一个字节可被写入，则返回`true`\n`readableBytes()` | 返回可被读取的字节数\n`writableBytes()` | 返回可被写入的字节数\n`capacity()`      | 返回`ByteBuf`可容纳的字节数。在此之后，它会尝试再次扩展直 到达到`maxCapacity()`\n`maxCapacity()`   | 返回`ByteBuf`可以容纳的最大字节数\n`hasArray()`      | 如果`ByteBuf`由一个字节数组支撑，则返回`true`\n`array()`         | 如果 `ByteBuf`由一个字节数组支撑则返回该数组；否则，它将抛出一个`UnsupportedOperationException`异常\n\n\n## ByteBufHolder\n\n- 支持缓冲区池化\n  - 从池中复用ByteBuf\n\n名称            | 描述\n------------- | --------------------------------------------------\n`content()`   | 返回由这个`ByteBufHolder`所持有的`ByteBuf`\n`copy()`      | 返回这个`ByteBufHolder`的一个深拷贝，包括一个其所包含的`ByteBuf`的非共享副本\n`duplicate()` | 返回这个`ByteBufHolder`的一个浅拷贝，包括一个其所包含的`ByteBuf`的共享副本\n\n## ByteBuf分配\n\n**ByteBufAllocator**\n\n- 池化\n- buffer 返回基于对或者直接缓存存储\n- headBuffer 返回基于堆内存\n- directBuffer 返回基于直接内存\n- compositeBuffer\n- ioBuffer 返回套接字的IO操作buffer\n\n实现：\n\n- PooledByteBufAllocator\n  - 池化\n- UnpooledByteBufAllocator\n  - 每次调用都会返回一个新实例\n\n**Unpooled缓冲区**\n\n提供了一些静态方法来创建ByteBuf实例\n\n**ByteBufUtils**\n\n- hexdump 以16进制打印缓冲区\n- equals 比较两个ByteBuf\n\n## 引用计数\n\nByteBuf 与 ByteBufHolder 都实现了引用计数\n\n```java\nboolean released = buffer.release();  ← --  减少到该对象的活动引用。当减少到0 时，该对象被释放，并且该方法返回true\n```\n\n访问一个引用计数被释放的对象 会抛出异常","metadata":"","hasMoreCommit":false,"totalCommits":5,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-09-13T16:31:05+08:00","author":"MY","message":"📦IO","hash":"4d55fc1e6699d75db71a6082e18f36a4a89e8767"},{"date":"2022-06-14T16:05:20+08:00","author":"cjiping","message":"📦整理 零拷贝","hash":"e17e9f8a29c5a0dc08e77530a959a27b32e45e39"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2020-07-12T10:00:56+08:00","author":"MY","message":"✏更新 netty","hash":"20cbdb843308e6364ecf6b14d2951deee6376a34"}],"createTime":"2020-07-12T10:00:56+08:00"}