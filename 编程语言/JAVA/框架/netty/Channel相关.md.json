{"name":"Channel相关","id":"编程语言-JAVA-框架-netty-Channel相关","content":"# Channel相关\n\n## Channel\n\n### 生命周期\n\n状态                    | 描述\n--------------------- | ------------------------------------------\n`ChannelUnregistered` | `Channel`已经被创建，但还未注册到`EventLoop`\n`ChannelRegistered`   | `Channel`已经被注册到了`EventLoop`\n`ChannelActive`       | `Channel`处于活动状态（已经连接到它的远程节点）。它现在可以接收和发送数据了\n`ChannelInactive`     | `Channel`没有连接到远程节点\n\n\n## ChannelHandler\n\n### 生命周期\n\n类型                | 描述\n----------------- | -------------------------------------------\n`handlerAdded`    | 当把`ChannelHandler`添加到`ChannelPipeline`中时被调用\n`handlerRemoved`  | 当从`ChannelPipeline`中移除`ChannelHandler`时被调用\n`exceptionCaught` | 当处理过程中在`ChannelPipeline`中有错误产生时被调用\n\n### ChannelInboundHandler\n\n- 入站消息操作\n\n类型                          | 描述\n--------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n`channelRegistered`         | 当`Channel`已经注册到它的`EventLoop`并且能够处理I/O时被调用\n`channelUnregistered`       | 当`Channel`从它的`EventLoop`注销并且无法处理任何I/O时被调用\n`channelActive`             | 当`Channel`处于活动状态时被调用；`Channel`已经连接/绑定并且已经就绪`channelInactive`                                                                                                                                                                                        | 当`Channel`离开活动状态并且不再连接它的远程节点时被调用\n`channelReadComplete`       | 当`Channel`上的一个读操作完成时被调用\n`channelRead`               | 当从`Channel`读取数据时被调用\n`ChannelWritabilityChanged` | 当`Channel`的可写状态发生改变时被调用。用户可以确保写操作不会完成得太快（以避免发生`OutOfMemoryError`）或者可以在`Channel`变为再次可写时恢复写入。可以通过调用`Channel`的`isWritable()`方法来检测`Channel`的可写性。与可写性相关的阈值可以通过`Channel.config(). setWriteHighWaterMark()`和`Channel.config().setWriteLowWaterMark()`方法来设置\n`userEventTriggered`        | 当`ChannelnboundHandler.fireUserEventTriggered()`方法被调用时被调用，因为一个POJO被传经了`ChannelPipeline`\n\n\n需要注意的是 在channelRead方法里面需要显式释放ByteBuf\n\n```java\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {  ← --  丢弃已接收的消息\n  ReferenceCountUtil.release(msg);\n}\n```\n\nSimpleChannelInboundHandler 会自动释放资源\n\n### ChannelOutboundHandler\n\n- 出站消息操作\n\n类型                                                                          | 描述\n--------------------------------------------------------------------------- | ---------------------------------\n`bind(ChannelHandlerContext,SocketAddress,ChannelPromise)`                  | 当请求将`Channel`绑定到本地地址时被调用\n`connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)` | 当请求将`Channel`连接到远程节点时被调用\n`disconnect(ChannelHandlerContext,ChannelPromise)`                          | 当请求将`Channel`从远程节点断开时被调用\n`close(ChannelHandlerContext,ChannelPromise)`                               | 当请求关闭`Channel`时被调用\n`deregister(ChannelHandlerContext,ChannelPromise)`                          | 当请求将`Channel`从它的`EventLoop`注销时被调用\n`read(ChannelHandlerContext)`                                               | 当请求从`Channel`读取更多的数据时被调用\n`flush(ChannelHandlerContext)`                                              | 当请求通过`Channel`将入队数据冲刷到远程节点时被调用\n`write(ChannelHandlerContext,Object,<br>``ChannelPromise)`                  | 当请求通过`Channel`将数据写到远程节点时被调用\n\n### ChannelHandlerAdapter\n\n```mermaid\nclassDiagram\n    interface ChannelHandler\n\n    interface ChannelInboundHandler\n\n    interface ChannelOutboundHandler\n\n    class ChannelHandlerAdapter\n\n    class ChannelInboundHandlerAdapter\n\n    class ChannelOutboundHandlerAdapter\n\n    ChannelHandler <|-- ChannelInboundHandler\n    ChannelHandler <|-- ChannelOutboundHandler\n    ChannelInboundHandler <|-- ChannelInboundHandlerAdapter\n    ChannelHandlerAdapter <|-- ChannelInboundHandlerAdapter\n    ChannelHandlerAdapter <|-- ChannelOutboundHandlerAdapter\n    ChannelOutboundHandler <|-- ChannelOutboundHandlerAdapter\n    ChannelHandler <|-- ChannelHandlerAdapter\n\n```\n\n### ResourceLeakDetector\n\n通过分配1%的采样来检测内存泄漏\n\n1. 创建ByteBuf时调用了track0(obj)方法，传入的obj就是创建的ByteBuf对象。\n2. track0(obj)方法内做了2件事\n  - 创建一个弱引用对象，绑定上面传入的ByteBuf对象和一个全局的弱引用队列refQueue。\n  - 把这个弱引用对象加入到另一个全局集合allLeaks里面。\n3. ByteBuf对象用完了，正常情况会调用release()方法回收堆外内存，同时release()方法中调用了弱引用对象DefaultResourceLeak的close()方法，从allLeaks集合里面把这个弱引用对象移除。如果开发者忘记调用release()方法，则allLeaks集合里还会存在这个弱引用对象。\n4. 一段时间后，ByteBuf对象被GC回收，此时会触发一个操作：ByteBuf对象所绑定的弱引用对象被加入到refQueue中。\n5. 下一次创建ByteBuf时又调用了track0(obj)方法，把refQueue和allLeaks这俩集合一对比，既存在于refQueue（说明ByteBuf用完了且已经被GC回收），又存在于allLeaks（说明没调用release释放内存），表明存在内存泄漏\n\n### XXTrafficShapingHandler\n\n通过指定一个限制速度，读取或写入时进行计算，如果当前速度超限，会让生产者或者消费者等待一段时间后，再进行读取写入\n\n## ChannelPipeline\n\n拦截流经 Channel 的入站和出站时间的ChannelHandler 示例链\n\n### 修改\n\n名称                                    | 描述\n------------------------------------- | --------------------------------------------------------------\n`addFirst addBefore addAfter addLast` | 将一个`ChannelHandler`添加到`ChannelPipeline`中\n`remove`                              | 将一个`ChannelHandler`从`ChannelPipeline`中移除\n`replace`                             | 将`ChannelPipeline`中的一个`ChannelHandler`替换为另一个`Channel- Handler`\n\n### 访问 ChannelHandler\n\n名称        | 描述\n--------- | ---------------------------------------------\n`get`     | 通过类型或者名称返回`ChannelHandler`\n`context` | 返回和`ChannelHandler`绑定的`ChannelHandlerContext`\n`names`   | 返回`ChannelPipeline`中所有`ChannelHandler`的名称\n\n\n### 出入站事件\n\n## ChannelHandlerContext\n\n代表了 ChannelHandler 与 ChannelPipeline 之间的关联\n\n这个类提供的一些访问在 Channel 与 ChannelPipeline 上也有\n\n使用该类的目的是产生更短的事件流以及为了更高的性能","metadata":"","hasMoreCommit":false,"totalCommits":5,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-11-23T11:11:50+08:00","author":"MY","message":"✏Netty","hash":"0221dce7ab44660a2b3c946fc196d61cee138986"},{"date":"2023-11-21T20:11:52+08:00","author":"MY","message":"✏Netty","hash":"4c2ba429f91812eca42015a3cf8a185b43fdbabb"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2020-07-12T10:00:56+08:00","author":"MY","message":"✏更新 netty","hash":"20cbdb843308e6364ecf6b14d2951deee6376a34"}],"createTime":"2020-07-12T10:00:56+08:00"}