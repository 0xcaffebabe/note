{"name":"netty","id":"编程语言-JAVA-框架-netty-netty","content":"# Netty\n\n>Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。\n\n使用场景：\n\n- 高性能领域\n- 多线程并发领域    \n- 异步通信领域\n\n## Reactor主从多线程模型\n\n- 处理高并发\n- 一组线程接收请求，一组线程处理IO\n\n```mermaid\nstateDiagram\n    state \"用户端\" as Client {\n        [*] --> Client1 : 用户端 1\n        [*] --> Client2 : 用户端 2\n        [*] --> Client3 : 用户端 3\n    }\n    \n    state \"事件分离器\" as EventDispatcher {\n        MainReactor : Main Reactor Acceptor Thread Pool\n        SubReactor : Sub Reactor IO Thread Pool\n        MainReactor --> SubReactor : 触发 IO 事件\n        MainReactor --> Auth : 认证 (Auth)\n        MainReactor --> SLA : 服务质量 (SLA)\n    }\n\n    state \"Handlers\" as Handlers {\n        [*] --> Handler1 : Handler 1\n        [*] --> Handler2 : Handler 2\n        [*] --> Handler3 : Handler 3\n    }\n\n    Client --> MainReactor : 发起事件\n    SubReactor --> Handlers : 分发到 Handler\n\n```\n\n## 特性\n\n分类|特性\n-|-\n设计|统一的API,支持多种传输类型，阻塞的和非阻塞的；简单而强大的线程模型；真正的无连接数据报套接字支持；链接逻辑组件以支持复用\n性能|拥有比Java的核心API更高的吞吐量以及更低的延迟；得益于池化和复用，拥有更低的资源消耗；最少的内存复制\n健壮性|不会因为慢速、快速或者超载的连接而导致OutofMemoryError；消除在高速网络中NIO应用程序常见的不公平读/写比率\n\n- 非阻塞网络调用使得我们可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。\n- 选择器使得我们能够通过较少的线程便可监视许多连接上的事件。\n\n## 核心组件\n\n- 回调\n  - netty使用回调来将事件处理交给程序\n- Future\n  - netty的实现：ChannelFuture\n  - ChannelFutureListener\n    - 回调的更精细版本\n- 事件与ChannelHandler\n\n![批注 2020-07-04 092924](/assets/批注%202020-07-04%20092924.png)\n\n## 组件和设计\n\n### Channel\n\n它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作\n\n- EmbeddedChannel；\n- LocalServerChannel；\n- NioDatagramChannel；\n- NioSctpChannel；\n- NioSocketChannel。\n\n### EventLoop\n\n![批注 2020-07-05 094441](/assets/批注%202020-07-05%20094441.png)\n\n一个EventLoop在它的生命周期内只和一个Thread绑定 这个Thread会处理EventLoop所有的IO事件\n\n一个Channel对应一个EventLoop 一个EventLoop有一个或多个Channel\n\n### ChannelFuture\n\n提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。\n\n属于同一个Channel的操作都能保证按调用的顺序执行\n\n### ChannelHandler\n\nChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等\n\n```mermaid\nclassDiagram\n  ChannelHandler <-- ChannelInboundHandler: 继承\n  ChannelHandler <-- ChannelHandlerAdapter: 继承\n  ChannelHandler <-- ChannelOutboundHandler: 继承\n  ChannelInboundHandler <.. ChannelInboundHandlerAdapter: 实现\n  ChannelHandlerAdapter <-- ChannelInboundHandlerAdapter: 继承\n  ChannelHandlerAdapter <-- ChannelOutboundHandlerAdapter: 继承\n  ChannelOutboundHandler <.. ChannelOutboundHandlerAdapter: 实现\n```\n\n### ChannelPipeline\n\nChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API\n\n![](/assets/202337111911.png)\n\n在netty中，有两种消息发送方式\n\n- Channel: 消息会从头开始传递\n- ChannelHandlerContext 消息会从某一个Handler开始传递\n\n### 编码器解码器\n\n- xxxDecoder\n- xxxEncoder\n\n### ServerBootStrap\n\n- 使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。\n- 用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。\n\nServer端需要两组EventLoop\n\n![批注 2020-07-05 100502](/assets/批注%202020-07-05%20100502.png)\n\n## 异常处理\n\n- 入站异常\n  - ChannelHnadler.exceptionCaught\n- 出站异常\n  - ChannelFutureListener\n  - ChannelFuture\n\n## 线程模型\n\n线程模型确定了代码的执行方式\n\n### 线程池模型\n\n线程池管理着一些线程，当任务被提交时，就会被分配给其中一个线程进行处理。\n\n这种模型不能消除由上下文切换所带来的开销\n\n### EventLoop\n\n```java\nfor (;;) {\n    Runnable task = takeTask();\n    if (task != null) {\n        task.run();\n        updateLastExecutionTime();\n    }\n\n    if (confirmShutdown()) {\n        break;\n    }\n}\n```\n\n一个EventLoop 由 永远都不会变动的一个 Thread 驱动 \n\n### 任务调度\n\n- JDK自带的ScheduleExecutorService\n- netty 自带的调度\n\n```java\nChannel ch = ...\nScheduledFuture<?> future = ch.eventLoop().schedule(  ← --  创建一个Runnable以供调度稍后执行\n　　new Runnable() { \n　　@Override\n　　public void run() {  ← --  要执行的代码\n　　　　System.out.println(\"60 seconds later\");　\n　　}\n}, 60, TimeUnit.SECONDS);　 ← --  调度任务在从现在开始的60 秒之后执行\n```\n\n### 线程管理\n\n当一个任务交由 eventloop 执行时，如果当前线程是 eventloop 所属的线程，则就直接执行了。如果当前线程不是 eventloop 所属的线程，则将任务放入到任务队列中，等待 eventloop 线程来执行\n\n所以一定不能将一个长时间运行的任务放入到执行队列中 否则EventLoop会被阻塞\n\n### 线程分配\n\n![异步传输](/assets/批注%202020-07-08%20113146.png)\n\n![阻塞传输](/assets/批注%202020-07-08%20113208.png)\n\n## 单元测试\n\n### EmbeddedChannel\n\n![批注 2020-07-10 105859](/assets/批注%202020-07-10%20105859.png)\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(new EchoServerHandler());\n\nchannel.writeInbound(\"hello\"); // 入站数据\nassertTrue(channel.finish()); // 标记为完成\nString outData = channel.readOutbound(); // 出站数据\nassertEquals(\"hello\",outData);\n```\n","metadata":"","hasMoreCommit":true,"totalCommits":16,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-09-13T16:31:05+08:00","author":"MY","message":"📦IO","hash":"4d55fc1e6699d75db71a6082e18f36a4a89e8767"},{"date":"2023-03-07T03:20:43Z","author":"My","message":"✏Netty","hash":"838d32c337e448a12e4b7551ead7fefe6efae177"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2021-07-23T11:23:58+08:00","author":"cjiping","message":"✏更新 netty nio","hash":"94445280f4409e4f4d6b7c8348a90523f25070ac"},{"date":"2020-07-09T12:37:24+08:00","author":"MY","message":"✏更新 netty","hash":"cd0b0dc799e5bcee42874ee6804dacc4ddf99363"},{"date":"2020-07-08T11:33:00+08:00","author":"MY","message":"✏更新 netty","hash":"ab7637807a533f261c50e1cf15c6ec2ab04531bc"},{"date":"2020-07-07T11:39:42+08:00","author":"MY","message":"✏更新 netty","hash":"b9da1d53505a4f8f3267963fa46905cd68e33417"},{"date":"2020-07-05T10:08:05+08:00","author":"MY","message":"更新 netty","hash":"ea2537433859c6ef370d5e99eb05933792e6b36d"},{"date":"2020-07-04T09:31:06+08:00","author":"MY","message":"更新 netty","hash":"7d5284b5ef63a3d913ab735935efb3041683efe8"}],"createTime":"2019-07-20T13:31:17+08:00"}