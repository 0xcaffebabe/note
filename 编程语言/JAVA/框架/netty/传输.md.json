{"name":"传输","id":"编程语言-JAVA-框架-netty-传输","content":"## 传\n\n## API\n\n核心是 **Channel**\n\n```mermaid\nclassDiagram\n    interface Comparable\n\n    interface AttributeMap\n\n    interface Channel\n\n    interface ServerChannel\n\n    interface ChannelPipeline\n\n    interface ChannelConfig\n\n    class AbstractChannel\n\n    Comparable <|-- Channel\n    AttributeMap <|-- Channel\n    Channel <|.. ServerChannel\n    ChannelPipeline <|..* Channel\n    ChannelConfig <|..* Channel\n    Channel <|-- AbstractChannel\n\n```\n\nChannel的方法\n\n方法名           | 描述\n------------- | --------------------------------------------------------------------------------------------------\neventLoop     | 返回分配给`Channel`的`EventLoop`\npipeline      | 返回分配给`Channel`的`ChannelPipeline`\nisActive      | 如果`Channel`是活动的，则返回`true`。活动的意义可能依赖于底层的传输。例如，一个`Socket`传输一旦连接到了远程节点便是活动的，而一个`Datagram`传输一旦被打开便是活动的\nlocalAddress  | 返回本地的`SocketAddress`\nremoteAddress | 返回远程的`SocketAddress`\nwrite         | 将数据写到远程节点。这个数据将被传递给`ChannelPipeline`，并且排队直到它被flush\nflush         | 将之前已写的数据刷新到底层传输，如一个`Socket`\nwriteAndFlush | 一个简便的方法，等同于调用`write()`并接着调用`flush()`\n\nChannel 是线程安全的\n\n## 内置的传输方式\n\n名称       | 包                             | 描述                                                                              | 使用场景\n-------- | ----------------------------- | ------------------------------------------------------------------------------- | --------------------\nNIO      | `io.netty.channel.socket.nio` | 使用`java.nio.channels`包作为基础----基于选择器的方式                                          | 需要非阻塞的情况下（常用）\nEpoll    | `io.netty.channel.epoll`      | 由JNI驱动的`epoll()`和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如`SO_REUSEPORT`，比NIO传输更快，而且是完全非阻塞 | 同上\nOIO      | `io.netty.channel.socket.oio` | 使用`java.net`包作为基础----使用阻塞流                                                      | 需要阻塞传输的情况下\nLocal    | `io.netty.channel.local`      | 可以在VM内部通过管道进行通信的本地传输                                                            | 在同一个JVM内部\nEmbedded | `io.netty.channel.embedded`   | Embedded传输，允许使用`ChannelHandler`而又不需要一个真正的基于网络的传输                                | 测试`ChannelHandler`时\n\n在实际生产环境中，只推荐使用 NIO 了，Epoll 也是NIO， 是 Netty 自己单独实现的，性能称比 Linux 自带的好\n\n### NIO\n\n### Epoll\n\n该传输的语义同NIO 如果要使用该传输 只需要将 EventLoop 中的 NioServerSocketChannel 替换为 EpollServerSocketChannel即可\n\n### OIO\n\n更熟悉的名字叫做 BIO\n\n### Local\n\n没有绑定物理网络地址\n\n### Embedded\n\n可以将一组ChannelHandler 嵌入到 其他 ChannelHandler内部\n","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-11-12T15:10:19+08:00","author":"MY","message":"✏️netty","hash":"a2f3406d24e10571b5b2f5155ce0d851fcfc8fa2"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2020-07-12T10:00:56+08:00","author":"MY","message":"✏更新 netty","hash":"20cbdb843308e6364ecf6b14d2951deee6376a34"}],"createTime":"2020-07-12T10:00:56+08:00"}