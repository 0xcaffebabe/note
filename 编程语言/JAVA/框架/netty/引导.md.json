{"name":"引导","id":"编程语言-JAVA-框架-netty-引导","content":"# 引导\n\n```mermaid\nclassDiagram\n    AbstractBootstrap <|-- Bootstrap\n    AbstractBootstrap <|-- ServerBootstrap\n```\n\n## Bootstrap\n\n- 客户端\n\n名称                                                                                                  | 描述\n--------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n`Bootstrap group(EventLoopGroup)`                                                                   | 设置用于处理`Channel`所有事件的`EventLoopGroup`\n`Bootstrap channel(Class<? extends C>)`, `Bootstrap channelFactory(` `ChannelFactory<? extends C>)` | `channel()`方法指定了`Channel`的实现类。如果该实现类没提供默认的构造函数，可以通过调用`channelFactory()`方法来指定一个工厂类，它将会被`bind()`方法调用\n`Bootstrap localAddress(` `SocketAddress)`                                                          | 指定`Channel`应该绑定到的本地地址。如果没有指定，则将由操作系统创建一个随机的地址。或者，也可以通过`bind()`或者`connect()`方法指定`localAddress`\n`Bootstrap option(ChannelOption<> option,T value)`                                                  | 设置`ChannelOption`，其将被应用到每个新创建的`Channel`的`ChannelConfig`。这些选项将会通过`bind()`或者`connect()`方法设置到`Channel`，不管哪个先被调用。这个方法在`Channel`已经被创建后再调用将不会有任何的效果。支持的`ChannelOption`取决于使用的`Channel`类型。\n`Bootstrap attr(Attribute<> key, T value)`                                                          | 指定新创建的`Channel`的属性值。这些属性值是通过`bind()`或者`connect()`方法设置到`Channel`的，具体取决于谁最先被调用。这个方法在`Channel`被创建后将不会有任何的效果。\n`Bootstrap handler(ChannelHandler)`                                                                 | 设置将被添加到`ChannelPipeline`以接收事件通知的`ChannelHandler`\n`Bootstrap clone()`                                                                                 | 创建一个当前`Bootstrap`的克隆，其具有和原始的`Bootstrap`相同的设置信息\n`Bootstrap remoteAddress(SocketAddress)`                                                            | 设置远程地址。或者，也可以通过`connect()`方法来指定它\n`ChannelFuture connect()`                                                                           | 连接到远程节点并返回一个`ChannelFuture`，其将会在连接操作完成后接收到通知\n`ChannelFuture bind()`                                                                              | 绑定`Channel`并返回一个`ChannelFuture`，其将会在绑定操作完成后接收到通知，在那之后必须调用`Channel. connect()`方法来建立连接\n \n   \n```java\nString host = \"127.0.0.1\";\nint port = 1234;\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n\ntry {\n    Bootstrap b = new Bootstrap();\n    // 指定线程工作池\n    b.group(workerGroup);\n    // 指定实例化channel的方式\n    b.channel(NioSocketChannel.class);\n    // 连接参数\n    b.option(ChannelOption.SO_KEEPALIVE, true);\n    b.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        public void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new TimeClientHandler());\n        }\n    });\n\n    // Start the client.\n    ChannelFuture f = b.connect(host, port).sync(); // (5)\n\n    // Wait until the connection is closed.\n    f.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} finally {\n    workerGroup.shutdownGracefully();\n}\n```\n\n## ServerBootStrap\n\n- 服务端\n\n名称               | 描述\n---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n`group`          | 设置`ServerBootstrap`要用的`EventLoopGroup`。这个`EventLoopGroup`将用于`ServerChannel`和被接受的子`Channel`的I/O处理\n`channel`        | 设置将要被实例化的`ServerChannel`类\n`channelFactory` | 如果不能通过默认的构造函数创建`Channel`，那么可以提供一个`Channel- Factory`\n`localAddress`   | 指定`ServerChannel`应该绑定到的本地地址。如果没有指定，则将由操作系统使用一个随机地址。或者，可以通过`bind()`方法来指定该`localAddress`\n`option`         | 指定要应用到新创建的`ServerChannel`的`ChannelConfig`的`Channel- Option`。这些选项将会通过`bind()`方法设置到`Channel`。在`bind()`方法被调用之后，设置或者改变`ChannelOption`都不会有任何的效果。所支持的`ChannelOption`取决于所使用的`Channel`类型。参见正在使用的`ChannelConfig`的API文档\n`childOption`    | 指定当子`Channel`被接受时，应用到子`Channel`的`ChannelConfig`的`ChannelOption`。所支持的`ChannelOption`取决于所使用的`Channel`的类型。参见正在使用的`ChannelConfig`的API文档\n`attr`           | 指定`ServerChannel`上的属性，属性将会通过`bind()`方法设置给`Channel`。在调用`bind()`方法之后改变它们将不会有任何的效果\n`childAttr`      | 将属性设置给已经被接受的子`Channel`。接下来的调用将不会有任何的效果\n`handler`        | 设置被添加到`ServerChannel`的`ChannelPipeline`中的`ChannelHandler`。更加常用的方法参见`childHandler()`\n`childHandler`   | 设置将被添加到已被接受的子`Channel`的`ChannelPipeline`中的`Channel- Handler`。`handler()`方法和`childHandler()`方法之间的区别是：前者所添加的`ChannelHandler`由接受子`Channel`的`ServerChannel`处理，而`childHandler()`方法所添加的`ChannelHandler`将由已被接受的子`Channel`处理，其代表一个绑定到远程节点的套接字\n`clone`          | 克隆一个设置和原始的`ServerBootstrap`相同的`ServerBootstrap`\n`bind`           | 绑定`ServerChannel`并且返回一个`ChannelFuture`，其将会在绑定操作完成后收到通知（带着成功或者失败的结果）\n\nNetty 通过指定 EventLoopGroup 来决定使用哪一种 [Reactor 模型](/编程语言/并发模型.md#Reactor%20模型)\n\n\n```java\n// 单线程模式：\nEventLoopGroup eventGroup new NioEventLoopGroup(1);\n// 非主从多线程：\nEventLoopGroup eventGroup new NioEventLoopGroup();\n// 主从多线程：\nEventLoopGroup bossGroup new NioEventLoopGroup();\nEventLoopGroup workerGroup new NioEventLoopGroup()\n```\n\n\n\n```java\n// 接收到来的连接\nEventLoopGroup bossGroup = new NioEventLoopGroup();\n// 处理已建立连接的流量\nEventLoopGroup workerGroup = new NioEventLoopGroup();\ntry {\n    // 复制启动服务器\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n            // 使用 NioServerSocketChannel 将到来的连接实例化为Channel\n            .channel(NioServerSocketChannel.class)\n            // 指定处理器来处理 channel 与 channel 的事件\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new DiscardServerHandler());\n                }\n            })\n            // 指定一些参数（针对到来的连接）\n            .option(ChannelOption.SO_BACKLOG, 128)\n            // 指定一些参数（针对channel）\n            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n    // Bind and start to accept incoming connections.\n    ChannelFuture f = b.bind(port).sync();\n\n    // Wait until the server socket is closed.\n    // In this example, this does not happen, but you can do that to gracefully\n    // shut down your server.\n    f.channel().closeFuture().sync();\n} finally {\n    workerGroup.shutdownGracefully();\n    bossGroup.shutdownGracefully();\n}\n```\n\n尽可能重用 EventLoop , 减少先创创建所带来的的开销\n\n## ChannelOption\n\n这里可以设置处理连接的一些参数，如：\n\n```java\nbootstrap.option(ChannelOption.SO_KEEPALIVE,true)\n　　.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n```\n\n- ChannelOption.SO_BACKLOG\n\nChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog参数，函数listen(int socketfd,int backlog)用来初始化服务端可连接队列，服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小\n\n- ChannelOption.SO_KEEPALIVE\n\nChanneloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文\n\n## 关闭\n\n```java\nFuture<?> future = group.shutdownGracefully();　 ← --  shutdownGracefully()方法将释放所有的资源，并且关闭所有的当前正在使用中的Channel\n// block until the group has shutdown\nfuture.syncUninterruptibly();\n```","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-11-13T20:03:30+08:00","author":"MY","message":"✏netty","hash":"f0435a62810ce052636f6f6b0ba7750fd084c155"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2020-07-12T10:00:56+08:00","author":"MY","message":"✏更新 netty","hash":"20cbdb843308e6364ecf6b14d2951deee6376a34"}],"createTime":"2020-07-12T10:00:56+08:00"}