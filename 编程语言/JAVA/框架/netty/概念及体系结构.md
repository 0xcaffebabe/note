# 概念及体系结构

## JAVA网络编程

- BIO
  - 同步阻塞IO

![批注 2020-07-04 091237](/assets/批注%202020-07-04%20091237.png)

- 伪异步IO
- NIO
  - 同步非阻塞IO

![批注 2020-07-04 091304](/assets/批注%202020-07-04%20091304.png)

- AIO
  - 异步非阻塞IO

## 特性

![批注 2020-07-04 091702](/assets/批注%202020-07-04%20091702.png)

- 非阻塞网络调用使得我们可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。

- 选择器使得我们能够通过较少的线程便可监视许多连接上的事件。

### 阻塞与非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程

### 同步与异步

同步和异步关注的是消息通信机制 

所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用

## 核心组件

- 回调
  - netty使用回调来将事件处理交给程序
- Future
  - netty的实现：ChannelFuture
  - ChannelFutureListener
    - 回调的更精细版本
- 事件与ChannelHandler

![批注 2020-07-04 092924](/assets/批注%202020-07-04%20092924.png)

## 组件和设计

### Channel

它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作

- EmbeddedChannel；
- LocalServerChannel；
- NioDatagramChannel；
- NioSctpChannel；
- NioSocketChannel。

### EventLoop

![批注 2020-07-05 094441](/assets/批注%202020-07-05%20094441.png)

一个EventLoop在它的生命周期内只和一个Thread绑定 这个Thread会处理EventLoop所有的IO事件

一个Channel对应一个EventLoop 一个EventLoop有一个或多个Channel

### ChannelFuture

提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。

属于同一个Channel的操作都能保证按调用的顺序执行

### ChannelHandler

ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等

![](https://img2018.cnblogs.com/blog/1322310/201812/1322310-20181220211548971-1386097414.png)

- ChannelInboundHandler

### ChannelPipeline

ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API

![](https://img-blog.csdn.net/20160504161903129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在netty中，有两种消息发送方式

- Channel: 消息会从头开始传递
- ChannelHandlerContext 消息会从某一个Handler开始传递

### 编码器解码器

- xxxDecoder
- xxxEncoder

### ServerBootStrap

- 使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。
- 用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。

Server端需要两组EventLoop

![批注 2020-07-05 100502](/assets/批注%202020-07-05%20100502.png)

## 传输

### API

核心是 **Channel**

![批注 2020-07-06 123702](/assets/批注%202020-07-06%20123702.png)

Channel的方法

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">方　法　名</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>eventLoop</code></p> </td> 
   <td> <p class="表格单元格">返回分配给<code>Channel</code>的<code>EventLoop</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>pipeline</code></p> </td> 
   <td> <p class="表格单元格">返回分配给<code>Channel</code>的<code>ChannelPipeline</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>isActive</code></p> </td> 
   <td> <p class="表格单元格">如果<code>Channel</code>是活动的，则返回<code>true</code>。活动的意义可能依赖于底层的传输。例如，一个<code>Socket</code>传输一旦连接到了远程节点便是活动的，而一个<code>Datagram</code>传输一旦被打开便是活动的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>localAddress</code></p> </td> 
   <td> <p class="表格单元格">返回本地的<code>SocketAddress</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>remoteAddress</code></p> </td> 
   <td> <p class="表格单元格">返回远程的<code>SocketAddress</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>write</code></p> </td> 
   <td> <p class="表格单元格">将数据写到远程节点。这个数据将被传递给<code>ChannelPipeline</code>，并且排队直到它被flush</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>flush</code></p> </td> 
   <td> <p class="表格单元格">将之前已写的数据刷新到底层传输，如一个<code>Socket</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>writeAndFlush</code></p> </td> 
   <td> <p class="表格单元格">一个简便的方法，等同于调用<code>write()</code>并接着调用<code>flush()</code></p> </td> 
  </tr> 
 </tbody> 
</table>

Channel 是线程安全的

### 内置的传输

<table width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">包</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格">NIO</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.socket.nio</code></p> </td> 
   <td> <p class="表格单元格">使用<code>java.nio.channels</code>包作为基础——基于选择器的方式</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Epoll<a href="#anchor42" id="ac42"><sup>[1]</sup></a></p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.epoll</code></p> </td> 
   <td> <p class="表格单元格">由JNI驱动的<code>epoll()</code>和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如<code>SO_REUSEPORT</code>，比NIO传输更快，而且是完全非阻塞的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">OIO</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.socket.oio</code></p> </td> 
   <td> <p class="表格单元格">使用<code>java.net</code>包作为基础——使用阻塞流</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Local</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.local</code></p> </td> 
   <td> <p class="表格单元格">可以在VM内部通过管道进行通信的本地传输</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Embedded</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.embedded</code></p> </td> 
   <td> <p class="表格单元格">Embedded传输，允许使用<code>ChannelHandler</code>而又不需要一个真正的基于网络的传输。这在测试你的<code>ChannelHandler</code>实现时非常有用</p> </td> 
  </tr> 
 </tbody> 
</table>

- NIO

![批注 2020-07-06 124813](/assets/批注%202020-07-06%20124813.png)

- Epoll

该传输的语义同NIO 如果要使用该传输 只需要将 EventLoop 中的 NioServerSocketChannel 替换为 EpollServerSocketChannel即可

- OIO

![批注 2020-07-06 125423](/assets/批注%202020-07-06%20125423.png)

- Local

没有绑定物理网络地址

- Embedded

可以将一组ChannelHandler 嵌入到 其他 ChannelHandler内部

### 场景

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">应用程序的需求</p> </th> 
   <th> <p class="表头单元格">推荐的传输</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格">非阻塞代码库或者一个常规的起点</p> </td> 
   <td> <p class="表格单元格">NIO（或者在Linux上使用epoll）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">阻塞代码库</p> </td> 
   <td> <p class="表格单元格">OIO</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">在同一个JVM内部的通信</p> </td> 
   <td> <p class="表格单元格">Local</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">测试<code>ChannelHandler</code>的实现</p> </td> 
   <td> <p class="表格单元格">Embedded</p> </td> 
  </tr> 
 </tbody> 
</table>

## ByteBuf

数据容器

- 可以进行扩展
- 零拷贝
- 容量按需增长
- 读写切换不需要调用flip
- 读写使用不同索引
- 方法链式调用
- 引用计数
- 池化

![批注 2020-07-07 105759](/assets/批注%202020-07-07%20105759.png)

### 使用模式

- 堆缓冲区

ByteBuf将数据存储在JVM的堆空间中

```java
ByteBuf heapBuf = ...;
if (heapBuf.hasArray()) {  ← --  检查ByteBuf 是否有一个支撑数组
　　byte[] array = heapBuf.array();  ← --  如果有，则获取对该数组的引用　
　　int offset = heapBuf.arrayOffset() + heapBuf.readerIndex();  ← --  计算第一个字节的偏移量。
　　int length = heapBuf.readableBytes();　 ← --  获得可读字节数
　　handleArray(array, offset, length);　 ← --  使用数组、偏移量和长度作为参数调用你的方法
}
```

- 直接缓冲区

这种模式下的ByteBuf支持通过本地调用分配内存

所以直接缓冲区的数据在堆外，不会被GC处理

```java
ByteBuf directBuf = ...; 
if (!directBuf.hasArray()) {  ← --  检查ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区
　　int length = directBuf.readableBytes();  ← --  获取可读字节数
　　byte[] array = new byte[length];　 ← --  分配一个新的数组来保存具有该长度的字节数据　　
　　directBuf.getBytes(directBuf.readerIndex(), array);  ← --  将字节复制到该数组
　　handleArray(array, 0, length);  ← --  使用数组、偏移量和长度作为参数调用你的方法
}
```

- 复合缓冲区

这种模式下允许多个ByteBuf聚合起来，提供一个ByteBuf整体视图来进行操作

### 字节级操作

- 随机访问

```java
ByteBuf buffer = ...;
for (int i = 0; i < buffer.capacity(); i++) {
　　byte b = buffer.getByte(i);
　　System.out.println((char)b);
}
```

不会改变索引的值

- 顺序访问

![批注 2020-07-07 110658](/assets/批注%202020-07-07%20110658.png)

调用discardReadBytes()可以回收可丢弃字节的空间

读取所有数据

```java
ByteBuf buffer = ...;
while (buffer.isReadable()) {
　　System.out.println(buffer.readByte());
}
```

写入数据

```java
ByteBuf buffer = ...;
while (buffer.writableBytes() >= 4) {
　　buffer.writeInt(random.nextInt());
}
```

- 索引管理
  - readerIndex(int)：设置读索引位置
  - writerIndex(int)： 设置写索引位置
  - clear()：将读索引写索引重置为0

- 查找

```java
// 查找回车符(\r)
ByteBuf buffer = ...;
int index = buffer.forEachByte(ByteBufProcessor.FIND_CR);
```

- 派生缓冲区

  - duplicate()
  - slice()
  - slice(int, int)
  - Unpooled.unmodifiableBuffer(…)
  - order(ByteOrder)
  - readSlice(int)
  - copy()

这些方法都会返回一个新的ByteBuf实例

- 读/写
  - get和set操作，从给定的索引开始，并且保持索引不变；
  - read和write操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。
- 其他操作

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>isReadable()</code></p> </td> 
   <td> <p class="表格单元格">如果至少有一个字节可供读取，则返回<code>true</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>isWritable()</code></p> </td> 
   <td> <p class="表格单元格">如果至少有一个字节可被写入，则返回<code>true</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>readableBytes()</code></p> </td> 
   <td> <p class="表格单元格">返回可被读取的字节数</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>writableBytes()</code></p> </td> 
   <td> <p class="表格单元格">返回可被写入的字节数</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>capacity()</code></p> </td> 
   <td> <p class="表格单元格">返回<code>ByteBuf</code>可容纳的字节数。在此之后，它会尝试再次扩展直 到达到<code>maxCapacity()</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>maxCapacity()</code></p> </td> 
   <td> <p class="表格单元格">返回<code>ByteBuf</code>可以容纳的最大字节数</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>hasArray()</code></p> </td> 
   <td> <p class="表格单元格">如果<code>ByteBuf</code>由一个字节数组支撑，则返回<code>true</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>array()</code></p> </td> 
   <td> <p class="表格单元格">如果 <code>ByteBuf</code>由一个字节数组支撑则返回该数组；否则，它将抛出一个<code>UnsupportedOperationException</code>异常</p> </td> 
  </tr> 
 </tbody> 
</table>

### ByteBufHolder

- 支持缓冲区池化
  - 从池中复用ByteBuf

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>content()</code></p> </td> 
   <td> <p class="表格单元格">返回由这个<code>ByteBufHolder</code>所持有的<code>ByteBuf</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>copy()</code></p> </td> 
   <td> <p class="表格单元格">返回这个<code>ByteBufHolder</code>的一个深拷贝，包括一个其所包含的<code>ByteBuf</code>的非共享副本</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>duplicate()</code></p> </td> 
   <td> <p class="表格单元格">返回这个<code>ByteBufHolder</code>的一个浅拷贝，包括一个其所包含的<code>ByteBuf</code>的共享副本</p> </td> 
  </tr> 
 </tbody> 
</table>

### ByteBuf分配

**ByteBufAllocator**

- 池化
- buffer 返回基于对或者直接缓存存储
- headBuffer 返回基于堆内存
- directBuffer 返回基于直接内存
- compositeBuffer
- ioBuffer 返回套接字的IO操作buffer

实现：

- PooledByteBufAllocator
  - 池化
- UnpooledByteBufAllocator
  - 每次调用都会返回一个新实例

**Unpooled缓冲区**

提供了一些静态方法来创建ByteBuf实例

**ByteBufUtils**

- hexdump 以16进制打印缓冲区
- equals 比较两个ByteBuf

### 引用计数

ByteBuf 与 ByteBufHolder 都实现了引用计数

```java
boolean released = buffer.release();  ← --  减少到该对象的活动引用。当减少到0 时，该对象被释放，并且该方法返回true
```

访问一个引用计数被释放的对象 会抛出异常

## Channel

### 生命周期

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">状　　态</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>ChannelUnregistered</code></p> </td> 
   <td> <p class="表格单元格"><code>Channel</code>已经被创建，但还未注册到<code>EventLoop</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>ChannelRegistered</code></p> </td> 
   <td> <p class="表格单元格"><code>Channel</code>已经被注册到了<code>EventLoop</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>ChannelActive</code></p> </td> 
   <td> <p class="表格单元格"><code>Channel</code>处于活动状态（已经连接到它的远程节点）。它现在可以接收和发送数据了</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>ChannelInactive</code></p> </td> 
   <td> <p class="表格单元格"><code>Channel</code>没有连接到远程节点</p> </td> 
  </tr> 
 </tbody> 
</table>

## ChannelHandler

### 生命周期

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">类　　型</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>handlerAdded</code></p> </td> 
   <td> <p class="表格单元格">当把<code>ChannelHandler</code>添加到<code>ChannelPipeline</code>中时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>handlerRemoved</code></p> </td> 
   <td> <p class="表格单元格">当从<code>ChannelPipeline</code>中移除<code>ChannelHandler</code>时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>exceptionCaught</code></p> </td> 
   <td> <p class="表格单元格">当处理过程中在<code>ChannelPipeline</code>中有错误产生时被调用</p> </td> 
  </tr> 
 </tbody> 
</table>

### ChannelInboundHandler

- 入站消息操作

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">类　　型</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>channelRegistered</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>已经注册到它的<code>EventLoop</code>并且能够处理I/O时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>channelUnregistered</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>从它的<code>EventLoop</code>注销并且无法处理任何I/O时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>channelActive</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>处于活动状态时被调用；<code>Channel</code>已经连接/绑定并且已经就绪</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>channelInactive</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>离开活动状态并且不再连接它的远程节点时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>channelReadComplete</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>上的一个读操作完成时被调用<a href="#anchor61" id="ac61"><sup>[1]</sup></a></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>channelRead</code></p> </td> 
   <td> <p class="表格单元格">当从<code>Channel</code>读取数据时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>ChannelWritabilityChanged</code></p> </td> 
   <td> <p class="表格单元格">当<code>Channel</code>的可写状态发生改变时被调用。用户可以确保写操作不会完成得太快（以避免发生<code>OutOfMemoryError</code>）或者可以在<code>Channel</code>变为再次可写时恢复写入。可以通过调用<code>Channel</code>的<code>isWritable()</code>方法来检测<code>Channel</code>的可写性。与可写性相关的阈值可以通过<code>Channel.config(). setWriteHighWaterMark()</code>和<code>Channel.config().setWriteLowWater- Mark()</code>方法来设置</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>userEventTriggered</code></p> </td> 
   <td> <p class="表格单元格">当<code>ChannelnboundHandler.fireUserEventTriggered()</code>方法被调用时被调用，因为一个POJO被传经了<code>ChannelPipeline</code></p> </td> 
  </tr> 
 </tbody> 
</table>

需要注意的是 在channelRead方法里面需要显式释放ByteBuf

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {  ← --  丢弃已接收的消息
　　　ReferenceCountUtil.release(msg);　
}
```

SimpleChannelInboundHandler 会自动释放资源

### ChannelOutboundHandler

- 出站消息操作

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">类　　型</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>bind(ChannelHandlerContext,</code><br> <code>SocketAddress,ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求将<code>Channel</code>绑定到本地地址时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>connect(ChannelHandlerContext,</code><br> <code>SocketAddress,SocketAddress,ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求将<code>Channel</code>连接到远程节点时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>disconnect(ChannelHandlerContext,</code><br> <code>ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求将<code>Channel</code>从远程节点断开时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>close(ChannelHandlerContext,ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求关闭<code>Channel</code>时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>deregister(ChannelHandlerContext,</code><br> <code>ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求将<code>Channel</code>从它的<code>EventLoop</code>注销时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>read(ChannelHandlerContext)</code></p> </td> 
   <td> <p class="表格单元格">当请求从<code>Channel</code>读取更多的数据时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>flush(ChannelHandlerContext)</code></p> </td> 
   <td> <p class="表格单元格">当请求通过<code>Channel</code>将入队数据冲刷到远程节点时被调用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>write(ChannelHandlerContext,Object,<br></code><code>ChannelPromise)</code></p> </td> 
   <td> <p class="表格单元格">当请求通过<code>Channel</code>将数据写到远程节点时被调用</p> </td> 
  </tr> 
 </tbody> 
</table>

### ChannelHandlerAdapter

![批注 2020-07-08 105137](/assets/批注%202020-07-08%20105137.png)

### ResourceLeakDetector

通过分配1%的采样来检测内存泄漏

## ChannelPipeline

拦截流经 Channel 的入站和出站时间的ChannelHandler 示例链

### 修改

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>addFirst<br> addBefore<br> addAfter<br> addLast</code></p> </td> 
   <td> <p class="表格单元格">将一个<code>ChannelHandler</code>添加到<code>ChannelPipeline</code>中</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>remove</code></p> </td> 
   <td> <p class="表格单元格">将一个<code>ChannelHandler</code>从<code>ChannelPipeline</code>中移除</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>replace</code></p> </td> 
   <td> <p class="表格单元格">将<code>ChannelPipeline</code>中的一个<code>ChannelHandler</code>替换为另一个<code>Channel- Handler</code></p> </td> 
  </tr> 
 </tbody> 
</table>

### 访问 ChannelHandler

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>get</code></p> </td> 
   <td> <p class="表格单元格">通过类型或者名称返回<code>ChannelHandler</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>context</code></p> </td> 
   <td> <p class="表格单元格">返回和<code>ChannelHandler</code>绑定的<code>ChannelHandlerContext</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>names</code></p> </td> 
   <td> <p class="表格单元格">返回<code>ChannelPipeline</code>中所有<code>ChannelHandler</code>的名称</p> </td> 
  </tr> 
 </tbody> 
</table>

### 出入站事件

## ChannelHandlerContext

代表了 ChannelHandler 与 ChannelPipeline 之间的关联

这个类提供的一些访问在 Channel 与 ChannelPipeline 上也有

使用该类的目的是产生更短的事件流以及为了更高的性能

## 异常处理

- 入站异常
  - exceptionCaught
- 出站异常
  - ChannelFutureListener
  - ChannelFuture

## 线程模型

线程模型确定了代码的执行方式

### 线程池模型

![批注 2020-07-08 111409](/assets/批注%202020-07-08%20111409.png)

不能消除由上下文切换所带来的开销

### EventLoop

```java
while (!terminated) {
　List<Runnable> readyEvents = blockUntilEventsReady();　 ← --  阻塞，直到有事件已经就绪可被运行
　 for (Runnable ev: readyEvents) {
　　　ev.run();　 ← --  循环遍历，并处理所有的事件
　 }
}
```

一个EventLoop 由 永远都会变动的一个 Thread 驱动 

### 任务调度

- JDK自带的ScheduleExecutorService
- netty 自带的调度

```java
Channel ch = ...
ScheduledFuture<?> future = ch.eventLoop().schedule(  ← --  创建一个Runnable以供调度稍后执行
　　new Runnable() { 
　　@Override
　　public void run() {  ← --  要执行的代码
　　　　System.out.println("60 seconds later");　
　　}
}, 60, TimeUnit.SECONDS);　 ← --  调度任务在从现在开始的60 秒之后执行
```

### 线程管理

![批注 2020-07-08 112901](/assets/批注%202020-07-08%20112901.png)

所以一定不能将一个长时间运行的任务放入到执行队列中 否则EventLoop会被阻塞

### 线程分配

- 异步传输

![批注 2020-07-08 113146](/assets/批注%202020-07-08%20113146.png)

- 阻塞传输

![批注 2020-07-08 113208](/assets/批注%202020-07-08%20113208.png)