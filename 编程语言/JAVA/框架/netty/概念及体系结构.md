# 概念及体系结构

## JAVA网络编程

- BIO
  - 同步阻塞IO

![批注 2020-07-04 091237](/assets/批注%202020-07-04%20091237.png)

- 伪异步IO
- NIO
  - 同步非阻塞IO

![批注 2020-07-04 091304](/assets/批注%202020-07-04%20091304.png)

- AIO
  - 异步非阻塞IO

## 特性

![批注 2020-07-04 091702](/assets/批注%202020-07-04%20091702.png)

- 非阻塞网络调用使得我们可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。

- 选择器使得我们能够通过较少的线程便可监视许多连接上的事件。

### 阻塞与非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程

### 同步与异步

同步和异步关注的是消息通信机制 

所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用

## 核心组件

- 回调
  - netty使用回调来将事件处理交给程序
- Future
  - netty的实现：ChannelFuture
  - ChannelFutureListener
    - 回调的更精细版本
- 事件与ChannelHandler

![批注 2020-07-04 092924](/assets/批注%202020-07-04%20092924.png)

## 组件和设计

### Channel

它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作

- EmbeddedChannel；
- LocalServerChannel；
- NioDatagramChannel；
- NioSctpChannel；
- NioSocketChannel。

### EventLoop

![批注 2020-07-05 094441](/assets/批注%202020-07-05%20094441.png)

一个EventLoop在它的生命周期内只和一个Thread绑定 这个Thread会处理EventLoop所有的IO事件

一个Channel对应一个EventLoop 一个EventLoop有一个或多个Channel

### ChannelFuture

提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。

属于同一个Channel的操作都能保证按调用的顺序执行

### ChannelHandler

ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等

![](https://img2018.cnblogs.com/blog/1322310/201812/1322310-20181220211548971-1386097414.png)

- ChannelInboundHandler

### ChannelPipeline

ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API

![](https://img-blog.csdn.net/20160504161903129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在netty中，有两种消息发送方式

- Channel: 消息会从头开始传递
- ChannelHandlerContext 消息会从某一个Handler开始传递

### 编码器解码器

- xxxDecoder
- xxxEncoder

### ServerBootStrap

- 使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。
- 用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。

Server端需要两组EventLoop

![批注 2020-07-05 100502](/assets/批注%202020-07-05%20100502.png)

## 传输

### API

核心是 **Channel**

![批注 2020-07-06 123702](/assets/批注%202020-07-06%20123702.png)

Channel的方法

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">方　法　名</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格"><code>eventLoop</code></p> </td> 
   <td> <p class="表格单元格">返回分配给<code>Channel</code>的<code>EventLoop</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>pipeline</code></p> </td> 
   <td> <p class="表格单元格">返回分配给<code>Channel</code>的<code>ChannelPipeline</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>isActive</code></p> </td> 
   <td> <p class="表格单元格">如果<code>Channel</code>是活动的，则返回<code>true</code>。活动的意义可能依赖于底层的传输。例如，一个<code>Socket</code>传输一旦连接到了远程节点便是活动的，而一个<code>Datagram</code>传输一旦被打开便是活动的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>localAddress</code></p> </td> 
   <td> <p class="表格单元格">返回本地的<code>SocketAddress</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>remoteAddress</code></p> </td> 
   <td> <p class="表格单元格">返回远程的<code>SocketAddress</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>write</code></p> </td> 
   <td> <p class="表格单元格">将数据写到远程节点。这个数据将被传递给<code>ChannelPipeline</code>，并且排队直到它被flush</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>flush</code></p> </td> 
   <td> <p class="表格单元格">将之前已写的数据刷新到底层传输，如一个<code>Socket</code></p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格"><code>writeAndFlush</code></p> </td> 
   <td> <p class="表格单元格">一个简便的方法，等同于调用<code>write()</code>并接着调用<code>flush()</code></p> </td> 
  </tr> 
 </tbody> 
</table>

Channel 是线程安全的

### 内置的传输

<table width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">名　　称</p> </th> 
   <th> <p class="表头单元格">包</p> </th> 
   <th> <p class="表头单元格">描　　述</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格">NIO</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.socket.nio</code></p> </td> 
   <td> <p class="表格单元格">使用<code>java.nio.channels</code>包作为基础——基于选择器的方式</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Epoll<a href="#anchor42" id="ac42"><sup>[1]</sup></a></p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.epoll</code></p> </td> 
   <td> <p class="表格单元格">由JNI驱动的<code>epoll()</code>和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如<code>SO_REUSEPORT</code>，比NIO传输更快，而且是完全非阻塞的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">OIO</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.socket.oio</code></p> </td> 
   <td> <p class="表格单元格">使用<code>java.net</code>包作为基础——使用阻塞流</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Local</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.local</code></p> </td> 
   <td> <p class="表格单元格">可以在VM内部通过管道进行通信的本地传输</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">Embedded</p> </td> 
   <td> <p class="表格单元格"><code>io.netty.channel.embedded</code></p> </td> 
   <td> <p class="表格单元格">Embedded传输，允许使用<code>ChannelHandler</code>而又不需要一个真正的基于网络的传输。这在测试你的<code>ChannelHandler</code>实现时非常有用</p> </td> 
  </tr> 
 </tbody> 
</table>

- NIO

![批注 2020-07-06 124813](/assets/批注%202020-07-06%20124813.png)

- Epoll

该传输的语义同NIO 如果要使用该传输 只需要将 EventLoop 中的 NioServerSocketChannel 替换为 EpollServerSocketChannel即可

- OIO

![批注 2020-07-06 125423](/assets/批注%202020-07-06%20125423.png)

- Local

没有绑定物理网络地址

- Embedded

可以将一组ChannelHandler 嵌入到 其他 ChannelHandler内部

### 场景

<table border="1" width="90%"> 
 <thead> 
  <tr> 
   <th> <p class="表头单元格">应用程序的需求</p> </th> 
   <th> <p class="表头单元格">推荐的传输</p> </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> <p class="表格单元格">非阻塞代码库或者一个常规的起点</p> </td> 
   <td> <p class="表格单元格">NIO（或者在Linux上使用epoll）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">阻塞代码库</p> </td> 
   <td> <p class="表格单元格">OIO</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">在同一个JVM内部的通信</p> </td> 
   <td> <p class="表格单元格">Local</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="表格单元格">测试<code>ChannelHandler</code>的实现</p> </td> 
   <td> <p class="表格单元格">Embedded</p> </td> 
  </tr> 
 </tbody> 
</table>