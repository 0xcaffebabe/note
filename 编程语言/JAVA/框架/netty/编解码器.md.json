{"name":"编解码器","id":"编程语言-JAVA-框架-netty-编解码器","content":"# 编解码器\n\n## 解码器\n\n### ByteToMessageDecoder\n\n数据通过网络传输，最终会缓存在一个字节数组里\n\n所以就会可能出现传输：\n\n```\n|ABC|DEF|GHI|\n```\n\n接收：\n\n```\n|AB|CDEFG|H|I|\n```\n\n```java\npublic class TimeDecoder extends ByteToMessageDecoder {\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        // 如果缓冲区没有足够的数据，不进行处理，只有缓冲区累积一定的数据时，才将数据添加到out\n        if (in.readableBytes() < 4){\n            return;\n        }\n        // 添加到out后，代表解码器成功解码了一条消息\n        out.add(in.readBytes(4));\n    }\n}\n...\nbootstrap.handler(new ChannelInitializer<SocketChannel>() {\n    @Override\n    public void initChannel(SocketChannel ch) throws Exception {\n        ch.pipeline().addLast(new TimeDecoder(),new TimeClientHandler());\n    }\n});\n```\n\n当然这种粘包也可以通过创建一个缓冲区，每次数据到来时，将数据放入到缓冲区，如果缓冲区超过一定大小则就进行处理\n\n```java\npublic class TimeClientHandler extends ChannelInboundHandlerAdapter {\n    private ByteBuf buf;\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        ByteBuf m = (ByteBuf) msg;\n        buf.writeBytes(m); // (2)\n        m.release();\n        \n        if (buf.readableBytes() >= 4) { // (3)\n            long currentTimeMillis = (buf.readUnsignedInt() - 2208988800L) * 1000L;\n            System.out.println(new Date(currentTimeMillis));\n            ctx.close();\n        }\n    }\n}\n```\n\n### ReplayingDecoder\n\n使用了一个自定义的ByteBuf 支持更简单的操作\n\n### MessageToMessageDecoder\n\nByteToMessage 是一次解码，而MessageToMessage在一次解码的基础上，对其进行二次解码\n\n## 编码器\n\n### MessageToByteEncoder\n\n```java\npublic class ShortToByteEncoder extends MessageToByteEncoder<Short> { //← --  扩展了MessageToByteEncoder\n    @Override\n    public void encode(ChannelHandlerContext ctx, Short msg, ByteBuf out)\n      throws Exception {\n        out.writeShort(msg); // ← --  将Short 写入ByteBuf 中\n    }\n}\n```\n\n### MessageToMessageEncoder\n\n## 编解码器\n\n- xxxCodec\n\n## netty 内置的 Handler 以及 编解码器\n\n- SslHandler\n  - SSL/TLS\n- Http\n  - HttpResponseDecoder\n  - HttpRequestEncoder\n  - HttpServerCodec\n  - `pipeline.addLast(\"aggregator\",new HttpObjectAggregator(512 * 1024));`\n  - 压缩:HttpContentCompressor\n- WebSocket\n\n```java\n　　@Override\n　　protected void initChannel(Channel ch) throws Exception {\n　　　　ch.pipeline().addLast(\n　　　　　　new HttpServerCodec(),\n　　　　　　new HttpObjectAggregator(65536),   ← --  为握手提供聚合的HttpRequest\n　　　　　  new WebSocketServerProtocolHandler(\"/websocket\"), ← --  如果被请求的端点是\"/websocket\"，则处理该升级握手　\n　　　　　　new TextFrameHandler(),　 ← --  TextFrameHandler 处理TextWebSocketFrame\n　　　　　  new BinaryFrameHandler(),　← -- BinaryFrameHandler 处理BinaryWebSocketFrame　\n　　　　　  new ContinuationFrameHandler());　← -- ContinuationFrameHandler 处理ContinuationWebSocketFrame　 \n　　}\n```\n\n- 检测空闲连接或超时 前两者都是通过定时任务调度，检测最后操作时间实现，后者则是在特定时间检查特定状态实现\n  - IdleStateHandler\n  - ReadTimeoutHandler\n  - WriteTimeoutHandler\n- 根据分隔符分割字节流\n  - DelimiterBasedFrameDecoder\n  - LineBasedFrameDecoder\n- 根据长度分割字节流\n  - FixedLengthFrameDecoder\n  - LengthFieldBasedFrameDecoder\n- 写大型数据\n\n```java\nFileInputStream in = new FileInputStream(file);   ← -- 创建一个FileInputStream \nFileRegion region = new DefaultFileRegion(　 ← -- 以该文件的完整长度创建一个新的DefaultFileRegion\n　　in.getChannel(), 0, file.length());\nchannel.writeAndFlush(region);\n```\n\n```java\npipeline.addLast(new ChunkedWriteHandler());　 ← --  添加Chunked-WriteHandler以处理作为ChunkedInput传入的数据\n　　　　pipeline.addLast(new WriteStreamHandler());   ← --  一旦连接建立，WriteStreamHandler就开始写文件数据　 \n```\n\n### 数据传输前置长度\n\n无论使用什么分割符代表消息间隔，数据中都会可能出现这样的符号，为了避免这个问题，可以通过使用固定的字节长度代表消息数据段长度来解决\n\n```text\n03 下雨天 03 留客天 02 天留 03 我不留\n```\n\n- LengthFieldBasedFrameDecoder\n\n### 序列化\n  \n#### JDK\n\n名称                        | 描述\n------------------------- | ------------------------------------------------------------------\n`CompatibleObjectDecoder` | 和使用JDK序列化的非基于Netty的远程节点进行互操作的解码器\n`CompatibleObjectEncoder` | 和使用JDK序列化的非基于Netty的远程节点进行互操作的编码器\n`ObjectDecoder`           | 构建于JDK序列化之上的使用自定义的序列化来解码的解码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取\n`ObjectEncoder`           | 构建于JDK序列化之上的使用自定义的序列化来编码的编码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取\n\n#### JBoss Marshalling\n\n名称                                                            | 描述\n------------------------------------------------------------- | -----------------------------------\n`CompatibleMarshallingDecoder`,`CompatibleMarshallingEncoder` | 与只使用JDK序列化的远程节点兼容\n`MarshallingDecoder`, `MarshallingEncoder`                    | 适用于使用JBoss Marshalling的节点。这些类必须一起使用\n\n#### Protocol Buffers\n\n名称                                     | 描述\n-------------------------------------- | ---------------------------------------------------------------------------\n`ProtobufDecoder`                      | 使用protobuf对消息进行解码\n`ProtobufEncoder`                      | 使用protobuf对消息进行编码\n`ProtobufVarint32FrameDecoder`         | 根据消息中的Google Protocol Buffers的\"Base 128 Varints\"a整型长度字段值动态地分割所接收到的`ByteBuf`\n`ProtobufVarint32LengthFieldPrepender` | 向`ByteBuf`前追加一个Google Protocal Buffers的\"Base 128 Varints\"整型的长度字段值\n","metadata":"","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2024-11-19T19:31:45+08:00","author":"MY","message":"📦Netty","hash":"7946c5ade41a20d7e1705b2037db91ae913e2073"},{"date":"2023-11-14T20:09:16+08:00","author":"MY","message":"✏Netty","hash":"1095b13006db95940617e2eeb6c041f4dfbe3126"},{"date":"2022-05-17T21:00:48+08:00","author":"MY","message":"✏️更新 netty","hash":"a5a88d9c64f98c6122c9e89b6be6435ddbc73ad0"},{"date":"2022-01-07T17:00:35+08:00","author":"cjiping","message":"📦整理 Netty","hash":"371cf8a728d093fe35cab31c0d354cff1e29653d"},{"date":"2020-07-13T11:23:23+08:00","author":"MY","message":"✏更新 netty 编解码器","hash":"3288f3af36bde6c138fd62256cd4cb0d78f53d82"},{"date":"2020-07-11T09:40:23+08:00","author":"MY","message":"✏更新 netty","hash":"88831a55e00f5ce94d2cf2014a3c4f6569a0be81"}],"createTime":"2020-07-11T09:40:23+08:00"}