{"name":"编译原理","id":"编程语言-JAVA-编译原理","content":"# 编译原理\n\n## 词法解析\n\n```java\n// JavaParser\npublic JCTree.JCCompilationUnit parseCompilationUnit() {\n        Token firstToken = token;\n        JCModifiers mods = null;\n        boolean consumedToplevelDoc = false;\n        boolean seenImport = false;\n        boolean seenPackage = false;\n        ListBuffer<JCTree> defs = new ListBuffer<>();\n        if (token.kind == MONKEYS_AT)\n            mods = modifiersOpt(); // 解析修饰符\n\n        if (token.kind == PACKAGE) { // 解析包声明\n            int packagePos = token.pos;\n            List<JCAnnotation> annotations = List.nil();\n            seenPackage = true;\n            if (mods != null) {\n                checkNoMods(mods.flags);\n                annotations = mods.annotations;\n                mods = null;\n            }\n            nextToken();\n            JCExpression pid = qualident(false);\n            accept(SEMI);\n            JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));\n            attach(pd, firstToken.comment(CommentStyle.JAVADOC));\n            consumedToplevelDoc = true;\n            defs.append(pd);\n        }\n\n        boolean checkForImports = true;\n        boolean firstTypeDecl = true;\n        while (token.kind != EOF) {\n            if (token.pos <= endPosTable.errorEndPos) {\n                // error recovery\n                skip(checkForImports, false, false, false);\n                if (token.kind == EOF)\n                    break;\n            }\n            if (checkForImports && mods == null && token.kind == IMPORT) { // 解析import\n                seenImport = true;\n                defs.append(importDeclaration());\n            } else { // 解析类主体\n                Comment docComment = token.comment(CommentStyle.JAVADOC); // 类doc注释\n                if (firstTypeDecl && !seenImport && !seenPackage) {\n                    docComment = firstToken.comment(CommentStyle.JAVADOC);\n                    consumedToplevelDoc = true;\n                }\n                if (mods != null || token.kind != SEMI)\n                    mods = modifiersOpt(mods);\n                if (firstTypeDecl && token.kind == IDENTIFIER) {\n                    ModuleKind kind = ModuleKind.STRONG; // 模块解析\n                    if (token.name() == names.open) {\n                        kind = ModuleKind.OPEN;\n                        nextToken();\n                    }\n                    if (token.kind == IDENTIFIER && token.name() == names.module) {\n                        if (mods != null) {\n                            checkNoMods(mods.flags & ~Flags.DEPRECATED);\n                        }\n                        defs.append(moduleDecl(mods, kind, docComment));\n                        consumedToplevelDoc = true;\n                        break;\n                    } else if (kind != ModuleKind.STRONG) {\n                        reportSyntaxError(token.pos, Errors.ExpectedModule);\n                    }\n                }\n                JCTree def = typeDeclaration(mods, docComment);\n                if (def instanceof JCExpressionStatement)\n                    def = ((JCExpressionStatement)def).expr;\n                defs.append(def);\n                if (def instanceof JCClassDecl)\n                    checkForImports = false;\n                mods = null;\n                firstTypeDecl = false;\n            }\n        }\n        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n        if (!consumedToplevelDoc)\n            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));\n        if (defs.isEmpty())\n            storeEnd(toplevel, S.prevToken().endPos);\n        if (keepDocComments)\n            toplevel.docComments = docComments;\n        if (keepLineMap)\n            toplevel.lineMap = S.getLineMap();\n        this.endPosTable.setParser(null); // remove reference to parser\n        toplevel.endPositions = this.endPosTable;\n        return toplevel;\n    }\n```\n\nJavaParser 根据 Java 语言规范来解析.java文件进行词法解析\n\n每调用一次nextToken 就会构造一个Token \n\n```mermaid\nsequenceDiagram\n    Scanner ->> Names: 传char[]字符数组给fromChars方法\n    Names ->> Name.Table: table.fromChars\n    Name.Table ->> Name.Table: 根据char[]构建Name对象数组，数组索引是char[]的hash值\n    Name.Table ->> Names: \"\"\n    Names ->> Scanner: \"\"\n    Scanner ->> Keywords: 传Name对象到Keywords的key方法 查找相应的 Token\n    Keywords ->> Scanner: 根据name.getIndex查找key数组对应的Token\n```\n\n## 语法分析\n\n- 进行package词法分析的时候构建一个节点\n\n```java\nJCExpression t = toP(F.at(token.pos).Ident(ident()));\n```\n\n- 进行import词法分析时构造的import语法树\n\n```java\nprotected JCTree importDeclaration() {\n    int pos = token.pos;\n    nextToken();\n    boolean importStatic = false;\n    if (token.kind == STATIC) {\n        importStatic = true;\n        nextToken();\n    }\n    JCExpression pid = toP(F.at(token.pos).Ident(ident()));\n    do {\n        int pos1 = token.pos;\n        accept(DOT);\n        if (token.kind == STAR) {\n            pid = to(F.at(pos1).Select(pid, names.asterisk));\n            nextToken();\n            break;\n        } else {\n            pid = toP(F.at(pos1).Select(pid, ident()));\n        }\n    } while (token.kind == DOT);\n    accept(SEMI);\n    return toP(F.at(pos).Import(pid, importStatic));\n}\n```\n\n- 类主体语法树构造\n\n```java\nJCTree typeDeclaration(JCModifiers mods, Comment docComment) {\n    int pos = token.pos;\n    if (mods == null && token.kind == SEMI) {\n        nextToken();\n        return toP(F.at(pos).Skip());\n    } else {\n        return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);\n    }\n}\n```\n\n最后会生成一颗完整的语法树\n\n## 语义分析\n\n打磨语法树\n\n- Enter类\n\n## 代码生成\n\n- Gen类\n\n## 编译器API\n\n- 对.java文件即时编译\n- 对字符串即时编译\n- 监听编译与错误\n\n`JavaCompiler`\n\n- run方法：调用直接在源代码目录生成class文件，api较为简单\n- getTask方法：功能较为强大，支持对内存中的源代码生成class\n\n### 编译文件\n\n```java\nJavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\njavaCompiler.run(null,null,null,\"path\");\n```\n\n### 编译字符串\n\n```java\nprivate static Class<?> compile(String className, String javaCodes) throws URISyntaxException {\n\n    class JavaSourceFromString extends SimpleJavaFileObject {\n        private final String src;\n\n        public JavaSourceFromString(String className, String code) throws URISyntaxException {\n            super(URI.create(\"string:///\" + className.replace('.', '/')\n                    + \".java\"), JavaFileObject.Kind.SOURCE);\n            this.src = code;\n        }\n\n        public String getCode() {return src;}\n\n        @Override\n        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n            return src;\n        }\n    }\n\n    //将字符串包装为SimpleJavaFileObject对象\n    JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCodes);\n    System.out.println(srcObject.getCode());\n    Iterable<? extends JavaFileObject> fileObjects = Arrays.asList(srcObject);\n\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);\n    DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<JavaFileObject>();\n\n    //设置编译的输出目录，并包装在options中\n    String flag = \"-d\";\n    String outDir = \"\";\n    try {\n        File classPath = new File(Thread.currentThread().getContextClassLoader().getResource(\"\").toURI());\n        outDir = classPath.getAbsolutePath() + File.separator;\n        System.out.println(outDir);\n    } catch (URISyntaxException e1) {\n        e1.printStackTrace();\n    }\n    Iterable<String> options = Arrays.asList(flag, outDir);\n\n    //JavaCompiler.getTask方法：以future的任务形式(多线程)，来执行编译任务\n\n    // 第一个参数：额外输出流，null表示默认使用system.err\n    // 第二个参数：文件管理器，null表示编译器标准文件管理器\n    // 第三个参数：诊断监听器，null表示使用编译器默认方法来报告诊断信息\n    // 第四个参数：编译器参数，null表示无参数\n    // 第五个参数：需要经过annotation处理的类名，null表示没有类需要annotation处理\n    // 第六个参数：待编译的类\n\n    JavaCompiler.CompilationTask task =\n            compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects);\n\n    //等待编译结束\n    boolean result = task.call();\n    if (result) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n    else\n    {\n        //print the Diagnostic's information\n        for  (Diagnostic diagnostic : diagnosticCollector\n                .getDiagnostics())\n        {\n            System.out.println(\"Error on line: \"\n                    + diagnostic.getLineNumber() + \"; URI: \"\n                    + diagnostic.getSource().toString());\n        }\n    }\n    return null;\n}\n```\n\n```java\nString sourceCode = \"\"\"\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"hello world\");\n    }\n}\n\"\"\";\nClass<?> klass = compile(\"HelloWorld\", sourceCode);\nMethod method = klass.getDeclaredMethod(\"main\", String[].class);\nmethod.invoke(null, new Object[]{new String[]{}}); // print hello world\n```\n\n### 应用\n\n- JSP编译\n- 在线编程\n- 自动化构建和测试\n","metadata":"tags: ['Java']","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2024-11-18T16:40:55+08:00","author":"MY","message":"📦Java 高级","hash":"2b21c6566aa4db8dff3d81003dea531cbe044061"},{"date":"2022-06-22T16:40:38+08:00","author":"cjiping","message":"📦整理 Java","hash":"dd8a407d9e17e954526376861d539512ad700daa"},{"date":"2020-10-04T10:31:39+08:00","author":"MY","message":"➕增加 Java 编译原理","hash":"2ed93eca5e25d4c6bca2c96afee0da344a95e25d"}],"createTime":"2020-10-04T10:31:39+08:00"}