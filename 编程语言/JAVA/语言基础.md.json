{"name":"语言基础","id":"编程语言-JAVA-语言基础","content":"# 语言基础\n\n## JAVA运行环境\n\n![](/assets/202339161051.png)\n\n- JVM\n\nJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。\n\n- JDK\n\nJDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具，能够创建和编译程序。\n\n- JRE\n\nJRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n**oracle jdk与openjdk**\n\nOracle JDK由Oracle公司开发，Oracle JDK采用了商业实现\nOpenJDK是Java SE平台版的开源和免费实现，虽然OpenJDK的部分功能有所缺失，但整体相差不大\n\n## 关键字\n\n- 完全小写的字母\n- 被高亮的单词\n\n### 标识符\n\n- 类的名称\n- 变量名称\n- 方法名称\n\n## 常量与变量\n\n### 常量\n\n>在程序运行期间，固定不变的量\n\n### 数据类型\n\n- 基本数据类型\n  - 整数型\n    - byte short int long 这些类型的包装类型的valueOf都作了缓存\n  - 浮点型\n    - float double\n  - 字符型\n    - char\n  - 布尔型\n    - boolean\n- 引用数据类型\n\n| 类型名称 | 默认值   | 大小 | 最小值   | 最大值     | 包装类    | 缓存区间            |\n| -------- | -------- | ---- | -------- | ---------- | --------- | ------------------- |\n| boolean  | false    | 1B   | 0(false) | 1(true)    | Boolean   | 无                  |\n| byte     | (byte)0  | 1B   | -128     | 127        | Byte      | -128~127            |\n| char     | '\\u0000' | 2B   | '\\u0000' | '\\uFFFF'   | Character | (char)0 ~ (char)127 |\n| short    | (short)0 | 2B   | -32768   | 32767      | Short     | -128 ~ 127          |\n| int      | 0        | 4B   | -2^31    | 2^31-1     | Integer   | -128 ~ 127          |\n| long     | 0L       | 8B   | -2^63    | 2^63-1     | Long      | -128 ~ 127          |\n| float    | 0.0f     | 4B   | 1.4e-45  | 3.4e+38    | Float     | 无                  |\n| double   | 0.0d     | 8B   | 4.9e-324 | 1.798e+308 | Double    | 无                  |\n\n#### 浮点数的表示\n\n```mermaid\npacket-beta\n  0-22: \"有效数字(23位)\"\n  23-30: \"指数(8位)\"\n  31: \"符号(1位)\"\n```\n\n指数 = $X + 2^{x的二进制位数-1}$\n\n有效数字 = 使用原码存储\n\n由于某些数字不能由有限二进制位精确表示 所以会出现1f-0.9f != 0.1 这种情况\n\n### 变量\n\n> 程序运行期间，内容可以发生改变的量\n\n## 数据类型转换\n\n- 隐式转换\n\n> 数据范围从小到大\n\n- 显式转换\n\n```java\n范围小的类型 范围小的变量名 = (范围小的类) 原本范围大的数据;\n```\n\n*数据溢出*\n\n当被转换的数值范围大于目标类型时，就会发生数据溢出，导致一部分数据丢失\n\n- byte short char 在运算时都会被提升为int类型\n\n### ASCII 码表\n\n使用数字表示某些字符\n\n![202083111314](/assets/202083111314.png)\n\n## 运算符\n\n> 进行特定操作的符号\n\n### 算术运算符\n\n`+ - * / %`\n\n加号的三种用法：\n\n- 数值加法\n- 字符计算\n- 字符串连接\n\n  - 优先级问题\n\n    ```java\n    String s = \"123\" + 20 + 30;\n    ```\n\n### 自增自减运算符\n\n- 单独使用\n- 混合使用\n\n### 赋值运算符\n\n- 基本\n- 复合\n\n### 比较运算符\n\n`> < >= <= == !=`\n\n### 逻辑运算符\n\n`&& || !`\n\n- 短路\n\n当 a && b 中的a为false时 就不会去计算b表达式\n\n### 位运算符\n\n```java\n// 以下所有操作都代表的是在2进制操作下\nSystem.out.println(2 << 2); // 左移 8\nSystem.out.println(2 >> 1); // 右移 2\nSystem.out.println(0xffffffff >>> 3); // 无符号右移（忽略掉符号位，对符号位也会移动）\nSystem.out.println(8 | 0); // 位或 8\nSystem.out.println(8 & 0); // 位与 0\nSystem.out.println(8 ^ 0); // 异或 8\nSystem.out.println(~8); // 位非 -9\n```\n\n## 方法\n\n方法签名包括方法名称与参数列表 是方法的唯一标识\n\n### 方法调用\n\n- 直接调用\n- 赋值调用\n- 递归调用\n\n### 参数的传递\n\n在JAVA中 参数都是通过值来进行传递的\n\n- 形参：方法定义阶段\n- 实参：方法调用阶段\n\n要避免使用Object作为可变参数\n\n入参保护：对于入参数据量进行判断控制 处理不了 直接返回错误\n\n参数校验：对于外部的输入 都需要校验 基于防御式编程理念 但是对于一些底层的方法就不必校验 越靠近外部 越需要校验\n\n### 修饰符\n\n#### 访问权限修饰符\n\n- private\n- public\n- protected\n\n#### static\n\n- 属于类本身\n\n可以被用来：\n\n1. 修饰类变量\n  - 注意线程安全问题\n2. 修饰方法\n  - 方法可以通过类直接调用\n3. 修饰代码块\n  - 使用到静态变量的代码块可以在任何位置\n\n**初始化时机**\n\n1. 父类的静态变量和静态块比子类优先初始化；\n2. 静态变量和静态块比类构造器优先初始化。\n\n---\n\n问：如何证明 static 静态变量和类实例无关\n\n答：不需要创建该类的实例就可以使用静态变量与静态方法\n\n问：变量和方法被 static 和 final 两个关键字修饰，为什么这么做\n\n答：static可以直接使用这些方法与变量，final则是变量地址不可变，方法不可覆写，提升稳定性\n\n问：catch 中发生了未知异常，finally 还会执行么\n\n答：会，但是异常会被catch吞掉\n\n#### [final](/编程语言/JAVA/高级/继承与多态.md#final关键字)\n\n#### transient\n\n用来修饰类变量，意思是当前变量是无需进行序列化的\n\n#### default \n\n修饰之后该方法就代表是一个默认实现，如果其他类继承该接口，就可以不用实现该方法，直接使用这个默认实现\n\n#### abstract\n\n- 抽象类及抽象方法\n\n#### [synchronized](/编程语言/JAVA/JAVA并发编程/基础概念.md#synchronized)\n\n### 方法重载\n\n指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关\n\n重载可以在编译时确定调用的方法 也被称为静态绑定\n\n```java\nvoid test(){\n  f(1);\n}\n\n// 重载方法的选择：\nvoid f(int i){} // 1. 精确匹配\nvoid f(long i){} // 2. 基本类型会自动转换成更大的数据类型\nvoid f(Integer i){} // 3. 自动装箱拆箱\nvoid f(Object i){} // 4. 向上转型进行匹配\nvoid f(Integer... i){} // 5. 最终通过可变参数匹配\n```\n\n### 方法重写\n\n对于子类 其可以改变父类的方法实现\n\n1. 父类无法调用在父类没有定义的方法\n2. 父类可以调用到子类重写的父类的方法\n\n子类重写的条件：\n\n- 只能针对非静态 非final 非构造方法\n- 访问权限不能变小\n- 重写方法的返回值类型要 `T super 父类的返回值类型`\n- 受检异常的类型同上\n- 方法签名需要与父类一致\n\n### 构造方法\n\n- 不能继承 不能覆写 不能直接调用\n- 方法名称必须与类名相同\n- 没有返回类型\n- 默认提供了一个无参构造\n- 可以为private\n\n### 类内方法\n\n外部使用静态成员时 尽量使用 类名.静态成员 来调用\n\n静态方法：\n\n- 不能使用实例成员\n- 不能使用super与this关键字\n\n### getter 与 setter\n\n为什么使用：\n\n- 满足面向对象的封装特性\n- 利于统一控制\n  - 权限...\n\n几种情况警惕：\n\n- 在方法中添加了业务逻辑会增加排查问题的难度\n- 同时定义getxxx与isxxx会迷惑程序员\n- 方法参数名称与成员变量名称相同 这点在IDE的使用下不是什么问题\n\n### 特殊方法\n\n#### finalize方法\n\n很早之前就已经被弃用了，不仅会导致垃圾回收变慢，甚至会导致死锁等问题产生\n\n一个替代品是从 JDK9 引入的java.lang.ref.Cleaner\n\n```java\npublic class CleaningExample implements AutoCloseable {\n    // A cleaner, preferably one shared within a library\n    private static final Cleaner cleaner = Cleaner.create();\n    static class State implements Runnable {\n        State() {\n            // initialize State needed for cleaning action\n        }\n        public void run() {\n            // cleanup action accessing State, executed at most once\n            System.out.println(\"清理操作\");\n        }\n    }\n    private final State state;\n    private final Cleaner.Cleanable cleanable;\n    public CleaningExample() {\n        this.state = new State();\n        this.cleanable = cleaner.register(this, state);\n    }\n    public void close() {\n        cleanable.clean();\n    }\n\n    public static void main(String[] args) {\n        try (var a = new CleaningExample()){}\n    }\n}\n```\n\n这个机制也有缺陷，跟一些第三方框架一样，都是通过虚引用来实现对资源的清理\n\n#### main方法\n\n### 同步异步\n\n异步处理的任务是非时间敏感的 异步调用需要通过诸如轮询的方式获取执行结果 轮询会增加机器的压力\n\n## 流程控制\n\n### 顺序结构\n\n### 分支结构\n\n- if\n- if-else\n- if-else if-else\n- switch\n\njava8 switch 支持的表达式:\n\n- enum\n- String\n- Integer\n- Short\n- Byte\n- Character\n- char\n- byte\n- short\n- int\n\n### 循环结构\n\n- for循环\n\n```java\nfor(初始化表达式①; 布尔表达式②; 步进表达式④){\n     循环体③\n}\n```\n\n- while循环\n\n```java\n初始化表达式①   \nwhile(布尔表达式②){\n         循环体③     \n     步进表达式④ \n}\n```\n\n- do...while循环\n\n```java\n初始化表达式①     \ndo{     \n    循环体③     \n    步进表达式④ \n}while(布尔表达式②)\n```\n\n- for 和 while 的小区别： \n  - 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while\n\n#### 跳出语句\n\n- continue\n- break\n  - 用在循环中\n  - 用在switch中\n\n#### 死循环\n\n#### 嵌套循环\n\n## 数组\n\n>数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 \n\n### 定义\n\n```java\nint arr = new int[3];\nint arr = new int[]{1,2,3};\n```\n\n### 访问\n\n```java\n\nint a = arr[2];\nint l = arr.length;\n```\n\n## == 与 equals\n\n== 运算符比较的是两个对象的地址\nequals默认实现也是比较地址，如果重写了equals，可以根据相应的逻辑来判断两个对象是否相等\n\n## hashCode 与 equals\n\n- 如果两个对象相等，则 hashcode 一定也是相同的\n- 两个对象相等,对两个对象分别调用 equals 方法都返回 true\n- 两个对象有相同的 hashcode 值，它们也不一定是相等的\n- 因此，**equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**\n- hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n只要覆写 equals，就必须覆写 hashCode；因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两个方法；\n\n如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。说明：String 已覆写 hashCode 和 equals 方法，所以我们可以愉快地使用 String 对象作为 key 来使用。\n\n有些数据结构比较两个元素相同时是先进行hashcode比较，然后才是equals\n\n## final关键字\n\n- 修饰类：类无法继承\n- 修饰变量：赋值之后无法修改\n- 修饰方法：无法被子类重写","metadata":"","hasMoreCommit":true,"totalCommits":12,"commitList":[{"date":"2024-10-24T14:25:32+08:00","author":"MY","message":"📦更新基本数据类型和浮点数表示的图片","hash":"cbb8551f65cb9094f3ddda94b6e2094ab7b028b8"},{"date":"2023-03-09T09:41:00Z","author":"My","message":"🛠替换在线图片","hash":"0c8b08bc22fbe482ba02da2f1fcad211441d3c23"},{"date":"2022-10-12T21:49:08+08:00","author":"MY","message":"✏️Java","hash":"0dc1fa35b269f76ec4eb6430d20f667ca134b0ed"},{"date":"2022-06-22T16:40:38+08:00","author":"cjiping","message":"📦整理 Java","hash":"dd8a407d9e17e954526376861d539512ad700daa"},{"date":"2022-06-09T21:51:44+08:00","author":"MY","message":"📦整理 Java","hash":"34c01b44e7566fa54773149765e3dd8420235279"},{"date":"2020-09-16T15:24:42+08:00","author":"MY","message":"✏更新 Java 数据类型","hash":"3a91e9187e36b5aac4fefd459fe56a72ed7a6329"},{"date":"2020-09-16T15:12:27+08:00","author":"MY","message":"✏更新 Java 重载","hash":"9e2b38b462c5081acfeb7901493fd372e4ce1b6a"},{"date":"2020-09-15T14:01:17+08:00","author":"MY","message":"✏更新 Java 方法","hash":"802d3f14ea0cb2af2b0a3ba6b244b67ae9d11728"},{"date":"2020-09-13T10:54:06+08:00","author":"MY","message":"✏更新 Java 语言基础","hash":"2e21730f816bfbd61e00552d4222f804c42f6dcc"},{"date":"2020-08-03T11:54:03+08:00","author":"MY","message":"✏更新 JAVA 语言基础","hash":"dcbde8f02099a05861982cae4a622971fed29290"}],"createTime":"2020-02-28T16:57:06+08:00"}