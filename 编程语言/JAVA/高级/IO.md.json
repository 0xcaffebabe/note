{"name":"IO","id":"编程语言-JAVA-高级-IO","content":"# IO\n\n网络框架设计模式：\n\n- Reactor模式：主动模式 应用程序不断轮询 询问底层IO是否准备就绪\n- Proactor模式：被动模式 read write都交给底层 通过回调完成操作\n\n服务器网络编程 1 + N + M 模型\n\n1个监听线程 N个IO线程 M个worker线程\n\n## 架构\n\n```mermaid\nmindmap\n root((处理流))\n    缓冲操作\n        BufferedInputStream\n        BufferedOutputStream\n        BufferedReader\n        BufferedWriter\n    基本数据类型操作\n        DataInputStream\n        DataOutputStream\n    对象序列化操作\n        ObjectInputStream\n        ObjectOutputStream\n    转化控制\n        InputStreamReader\n        OutputStreamWriter\n    打印控制\n        PrintStream\n        PrintWriter\n```\n\n```mermaid\nmindmap\n    root((节点流))\n        文件操作\n            FileInputStream\n            FileOutputStream\n            FileReader\n            FileWriter\n        管道操作\n            PipedInputStream\n            PipedOutputStream\n            PipedReader\n            PipedWriter\n        数组操作\n            ByteArrayInputStream\n            ByteArrayOutputStream\n            CharArrayReader\n            CharArrayWriter\n```\n\n大体分为几类：\n\n- 字节操作流 InputStream 与 OutputStream等 \n- 字符操作流 Writer 与 Reader\n- 磁盘IO File\n- 网络操作 Socekt等\n\n节点流可以从或向一个特定的地方（节点）读写数据，处理流则是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写，是一种[装饰器](/软件工程/设计模式/结构型模式.md#装饰器)\n\n字节到字符的转换十分耗时 非常容易出现乱码问题 这是字符流的用处\n\nInputStreamReader 与 OutputStreamWriter 是字节流与字符流之间的桥梁\n\n## File类\n\nFile并不代表一个真实存在的真实对象\n\nFileDescriptor才是代表一个真实文件对象\n\n从磁盘读取文件：\n\n![屏幕截图 2020-09-28 133112](/assets/屏幕截图%202020-09-28%20133112.png)\n\n构造方法\n\n- public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n- public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。\n- public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例\n\n静态成员变量\n\n- public static final String separator\n- public static final String pathSeparator\n- public static final File separatorChar\n- public static final File pathSeparatorChar\n\n### 获取\n\n- public String getAbsolutePath() ：返回此File的绝对路径名字符串。\n- public String getPath() ：将此File转换为路径名字符串。\n- public String getName() ：返回由此File表示的文件或目录的名称。\n- public long length() ：返回由此File表示的文件的长度。\n\n### 判断\n\n- public boolean exists() ：此File表示的文件或目录是否实际存在。\n- public boolean isDirectory() ：此File表示的是否为目录。\n- public boolean isFile() ：此File表示的是否为文件。\n\n### 创建删除\n\n- public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。\n- public boolean delete() ：删除由此File表示的文件或目录。\n- public boolean mkdir() ：创建由此File表示的目录。\n- public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n### 目录遍历\n\n- public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。\n- public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\n### 文件过滤器\n\n- FileFilter\n- FileNameFilter\n\n## IO\n\n### 顶级父类\n\n项   | 输入流               | 输出流\n--- | ----------------- | ------------------\n字节流 | 字节输入流 InputStream | 字节输出流 OutputStream\n字符流 | 字符输入流 Reader      | 字符输出流 Writer\n\n### 字节输出流【OutputStream】\n\n- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\n- public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。\n- public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。\n- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 oﬀ开始输 出到此输出流。\n- public abstract void write(int b) ：将指定的字节输出流。\n\n### FileOutputStream\n\n```java\nFileOutputStream fos = new FileOutputStream(\"fos.txt\");\n\nfor (int i =0;i<100;i++){\n    fos.write((\"hello\"+i+\"\\n\").getBytes());\n}\nfos.flush();\nfos.close();\n```\n\n- 数据追加续写\n\n```java\nFileOutputStream fos = new FileOutputStream(\"fos.txt\",true);\n```\n\n### 字节输入流【InputStream】\n\n- public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\n- public abstract int read() ： 从输入流读取数据的下一个字节。\n- public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n### FileInputStream\n\n构造方法\n\n- FileInputStream(File file) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 ﬁle命名。\n- FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件 系统中的路径名 name命名。\n\n```java\nFileInputStream fis = new FileInputStream(\"fos.txt\");\nint c = -1;\nwhile ((c = fis.read()) != -1) {\n    System.out.print((char)c);\n}\nfis.close();\n```\n\n### 字符流\n\nReader\n\n- public void close() ：关闭此流并释放与此流相关联的任何系统资源。\n- public int read() ： 从输入流读取一个字符。\n- public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\nFileReader\n\n```java\nFileReader reader = new FileReader(\"fos.txt\");\nint c = -1;\nwhile ((c = reader.read()) != -1){\n    System.out.print((char)c);\n}\n```\n\nWriter\n\n- void write(int c) 写入单个字符。\n- void write(char[] cbuf) 写入字符数组。\n- abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,oﬀ数组的开始索引,len 写的字符个数。\n- void write(String str) 写入字符串。\n- void write(String str, int off, int len) 写入字符串的某一部分,oﬀ字符串的开始索引,len写的字符个 数。\n- void flush() 刷新该流的缓冲。\n- void close() 关闭此流，但要先刷新它。\n\nFileWriter\n\n```java\nFileWriter writer = new FileWriter(\"fos.txt\");\nwriter.append(\"hh种\");\nwriter.flush();\nwriter.close();\n```\n\n- flush与close的区别\n\n## JDK7中IO的异常处理\n\n```java\n// JDK7\ntry (FileWriter writer = new FileWriter(\"fos.txt\")) {\n    writer.append(\"hh种\");\n    writer.flush();\n    \n} catch (IOException e) {\n    e.printStackTrace();\n}\n// JDK9\nFileWriter writer = new FileWriter(\"fos.txt\");\ntry (writer) {\n    writer.append(\"hh种\");\n    writer.flush();\n\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n## Properties\n\n- public Object setProperty(String key, String value) ： 保存一对属性。 \n- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 \n- `public Set<String> stringPropertyNames()` ：所有键的名称的集合。\n\n### 与流相关的方法\n\n- store\n- load\n\n## 缓冲流\n\n- 字节缓冲流： BufferedInputStream ， BufferedOutputStream \n- 字符缓冲流： BufferedReader ， BufferedWriter\n\n## 编码\n\n### IO 操作中的编解码\n\n```java\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"gbk.txt\"),\"gbk\");\n\nOutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"utf8.txt\"), StandardCharsets.UTF_8);\nint c = -1;\nwhile ((c= reader.read()) != -1){\n    writer.write(c);\n}\nwriter.close();\n```\n\n### 内存编解码\n\n```java\n\"蔡徐坤\".getBytes(\"gbk\");\nnew String(new byte[]{ -78, -52, -48, -20, -64, -92 },\"gbk\");\n```\n\n```mermaid\n---\ntitle: String 编码时序图\n---\nsequenceDiagram\n    participant String\n    participant StringCoding\n    participant Charset\n    participant StringEncoder\n    participant CharsetEncoder\n\n    String->>StringCoding: getBytes(charsetName)\n    StringCoding->>StringCoding: encode\n    StringCoding->>StringCoding: lookupCharset\n    StringCoding->>Charset: Charset.forName\n    Charset-->>StringCoding: 返回找到的Charset\n    StringCoding->>StringEncoder: 根据Charset new StringEncoder对象\n    StringEncoder->>CharsetEncoder: encode\n    CharsetEncoder->>CharsetEncoder: encode\n    CharsetEncoder->>CharsetEncoder: 调用encodeLoop方法\n    CharsetEncoder-->>StringEncoder: 返回ByteBuffer\n    StringEncoder-->>StringCoding: 返回ByteBuffer\n    StringCoding-->>String: 返回byte[]\n\n```\n\n### Web 中的编解码\n\n![屏幕截图 2020-09-29 113656](/assets/屏幕截图%202020-09-29%20113656.png)\n\n#### URL编解码\n\n`/页面?name=页面`\n\n这个URL被编码成`%2f%e9%a1%b5%e9%9d%a2%3fname%3d%e9%a1%b5%e9%9d%a2`\n\n不同浏览器的编码可能并不一致 那么服务端是如何解析的？\n\ntomcat中有一个配置：\n\n```xml\n<Connector URLEncoding=\"UTF-8\"> \n```\n\n这个配置就是用来对路径部分进行解码的\n\n至于queryString 要不是body中的charset 要不就是ISO-8859-1\n\n并且如果使用要body的charset的话 需要配置\n\n```xml\n<Connector useBodyEncodingForURI=\"true\"/>\n```\n\n#### HTTP header 编解码\n\n对于request.getHeader() 默认是使用的ISO-8859-1编码 且无法指定编码 不要在Header中传递非ASCII 字符\n\n#### 表单编解码\n\n浏览器会根据ContentType的Charset对表单参数进行编码\n\n服务端可以在Servlet容器中获取参数之前调用request.setCharacterEncoding()来指定服务器解码方式 如果没有调用此方法 那么会按照系统默认的编码方式解析\n\n#### Body 编解码\n\n服务端通过response.setCharacterEncoding来设置 这个方法的本质是设置响应头ContentType\n\n浏览器端按照以下顺序进行解码：\n\n- ContentType的charset\n- html meta标签的charset属性\n- 浏览器默认方式\n\n#### js文件编码问题\n\n如果外部引入的js文件与当前html不一致 需要\n\n```html\n<script charset=\"utf8\" src=\"xxx\"></script>\n```\n\n#### 常见编码问题\n\n![屏幕截图 2020-09-29 131724](/assets/屏幕截图%202020-09-29%20131724.png)\n![屏幕截图 2020-09-29 131741](/assets/屏幕截图%202020-09-29%20131741.png)\n![屏幕截图 2020-09-29 131801](/assets/屏幕截图%202020-09-29%20131801.png)\n\n## 序列化\n\n- ObjectOutputStream\n- ObjectInputStream\n\n```java\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"object\"));\noos.writeObject(new Person(\"jav\",15));\n\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"object\"));\nPerson p = (Person)ois.readObject();\n```\n\n序列化的类需要实现 `Serializable` 接口\n\n最好手动设置 serialVersionUID 的值, 类修改时根据是否兼容来调整这个值，serialVersionUID 值不一致会抛出序列化运行时异常。\n\n**transient关键字**修饰的变量不会被序列化\n\n序列化的目的：**持久化、传输**\n\n其他方式的序列化：\n\n- Hessian 效率很高 跨语言\n- Kryo 序列化\n- JSON 存在的一个问题是可能存在类型丢失\n\n序列化一些复杂对象：\n\n- 父类继承Serializable接口 所有子类都可以序列化\n- 子类实现Serializable接口 序列化后父类的属性会丢失\n- 成员变量如果要被序列化 需要实现Serializable接口 否则会报错\n- 反序列化时 成员如果发生修改 则发生修改的这些成员变量数据会丢失\n- 如果 serialVersionUID 被修改 反序列化会失败\n","metadata":"","hasMoreCommit":true,"totalCommits":15,"commitList":[{"date":"2025-09-21T14:03:43+08:00","author":"MY","message":"docs(mindmap): 统一思维导图根节点格式","hash":"44fc90fa0f22040d171dbf83cd6f2fd8c020444a"},{"date":"2024-11-18T16:40:55+08:00","author":"MY","message":"📦Java 高级","hash":"2b21c6566aa4db8dff3d81003dea531cbe044061"},{"date":"2023-09-13T16:31:05+08:00","author":"MY","message":"📦IO","hash":"4d55fc1e6699d75db71a6082e18f36a4a89e8767"},{"date":"2023-03-29T09:29:49+08:00","author":"MY","message":"📦IO","hash":"df6b632320242d8699d7fdaef8403a17a041318f"},{"date":"2022-06-23T21:09:40+08:00","author":"MY","message":"📦整理 数据的表示","hash":"f4f40ccc8edd6b4e554c4f373b57704bb126557f"},{"date":"2022-06-09T21:51:44+08:00","author":"MY","message":"📦整理 Java","hash":"34c01b44e7566fa54773149765e3dd8420235279"},{"date":"2020-09-29T13:20:00+08:00","author":"MY","message":"✏更新 IO 编码问题","hash":"afd5ebce0a5b1015eb8b8d54947c2bc934237f08"},{"date":"2020-09-28T14:48:29+08:00","author":"MY","message":"✏更新 IO 相关","hash":"28a47fdbc34dc2ec42719fe67cfb84287ce841c7"},{"date":"2020-09-27T20:00:56+08:00","author":"MY","message":"✏更新 IO","hash":"9020573a08fc6bc3b11600990a219e5c0d2a46d1"},{"date":"2020-09-15T11:01:58+08:00","author":"MY","message":"✏更新 java 序列化","hash":"61944e521519de1a9a0af5136db082bca51e600e"}],"createTime":"2019-08-02T17:01:26+08:00"}