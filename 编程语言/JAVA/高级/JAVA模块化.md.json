{"name":"JAVA模块化","id":"编程语言-JAVA-高级-JAVA模块化","content":"# 模块化\n\n模块化的访问控制通过类加载过程来完成\n\nJDK8之前jar的缺陷\n\n- jar文件无法控制别人访问其内部的public的类\n- 无法控制不同jar包中，相同的类名(包名+类名)\n- Java运行时，无法判定classpath路径上的jar中有多少个不同版本\n的文件。Java加载第一个符合名字的类\n- Java运行时，无法预判classpath路径上是否缺失了一些关键类\n\n## 兼容Java9 之前\n\n- 所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包\n- 模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的\n- 如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块\n\n## 模块化下的类加载器\n\n扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代\n\n新版的JDK也没了jre 现在可以用过jlink打包出一个jre：\n\n```sh\njlink -p $JAVA_HOME/jmods --add-modules java.base --output jre\n```\n\n平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader\n\n## 模块化原则\n\n- 强封装性：一个模块必须能够对其他模块隐藏其部分代码\n- 定义良好的接口：模块必须向其他模块公开定义良好且稳定的接口\n- 显式依赖：明确一个模块需要哪些模块的支持才能完成工作\n\n## Java 9 Jigsaw \n\n- 以模块(module)为中心\n- JDK 本身进行模块化\n\n### 模块系统\n\n- 在模块中，仍以包-类文件结构存在\n- 每个模块中，都有一个module-info.java\n- jlink\n\n### 步骤\n\n- 在src下面建立一个目录module.hello(模块名字，可自由定)\n- 在module.hello目录下，建立cn\\hello目录，再建立HelloWorld.java\n- 在module.hello目录下，建立一个module-info.java\n\n### module-info.java\n\n```java\nmodule module.hello { // 模块名\n    requires java.base; // 需要的模块\n    exports module.hello.wang.ismy.module; // 导出的模块\n}\n```\n\n- 单纯requires，模块依赖不会传递\n\n```java\nrequires transitive java.net.http; // 传递依赖\nrequires java.se; // 调用一个聚合模块\nexports module.hello.wang.ismy.module to java.xml; // 导出的模块只限定java.xml用\n```\n\n#### open\n\n- exports导出的包的public部分可以反射，其他权限修饰的内容和未导出的内容无法反射(setAccessible(true)也无效)\n\n- opens可以打开一些包，其他模块可以反射调用这些包及内容\n\n```java\nopen module module.hello { // 开放整个模块\n opens wang.ismy.module; // 开放某个包\n}\n```\n\n## 服务\n\n- provides提供接口，with实现类(不导出)\n- uses消费接口\n- ServiceLoader加载接口的实现类\n\n```java\nmodule module1 {\n\n    exports wang.ismy.module1;\n    provides wang.ismy.module1.Service with wang.ismy.module1.impl.ServiceImpl,\n            wang.ismy.module1.impl.ServiceImpl2;\n}\n```\n\n```java\nmodule module2 {\n    requires module1;\n    uses wang.ismy.module1.Service;\n}\n```\n\n- 使用\n\n```java\nServiceLoader<Service> serviceLoader = ServiceLoader.load(Service.class);\n\n        for (Service service : serviceLoader) {\n            service.run();\n        }\n```\n\n### 特点\n\n- 从根源上对JDK进行模块化，降低最终程序运行时负载\n- 在jar层上增加一个module机制\n- 引入exports/requires/opens明确模块边界和依赖关系，程序更隐私安全\n- 引入服务provides/uses使得程序更解耦\n- –jlink制作运行时映像，使运维更高效\n\n## OSGI\n\n- 动态JAVA模块化系统","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2020-10-27T14:32:23+08:00","author":"MY","message":"✏更新 Java 模块化","hash":"a6b23bb4ceb3519c7449faaafcb822452f91d7bb"},{"date":"2020-08-04T09:57:58+08:00","author":"MY","message":"✏更新 JAVA 模块化","hash":"489e0dc9398d82aa68788a73382e69167b38504a"},{"date":"2019-12-18T08:04:43+08:00","author":"MY","message":"完结JAVA模块化","hash":"ea28fe8f37b53c82462fcd00811c1feb1333db50"},{"date":"2019-12-16T21:40:21+08:00","author":"MY","message":"新增JAVA9模块化内容","hash":"3f5103f77d59e7e86a8e27c0bdefecb18cd29fb4"}],"createTime":"2019-12-16T21:40:21+08:00"}