{"name":"JDBC","id":"编程语言-JAVA-高级-JDBC","content":"# JDBC\n\n> Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。JDBC是面向关系型数据库的。\n\n## 常用类\n\n接口或类                | 作用\n------------------- | ----------------------------------------------------------------------\nDriverManager 类     | 1) 管理和注册数据库驱动 2) 得到数据库连接对象\nConnection 接口       | 一个连接对象，可用于创建 Statement 和 PreparedStatement 对象\nStatement 接口        | 一个 SQL 语句对象，用于将 SQL 语句发送给数据库服务器。\nPreparedStatemen 接口 | 一个 SQL 语句对象，是 Statement 的子接口 ResultSet 接口 用于封装数据库查询的结果集，返回给客户端 Java 程序\n\n_从 JDBC3 开始，目前已经普遍使用的版本。可以不用注册驱动而直接使用。Class.forName 这句话可以省略_\n\n## 数据类型\n\nSQL 类型          | JDBC 对应方法           | 返回类型\n--------------- | ------------------- | -----------------------\nBIT(1),bit(n)   | getBoolean()        | boolean\nTINYINT         | getByte()           | byte\nSAMLLINT        | getShort()          | short\nINT             | getInt()            | int\nBIGINT          | getLong()           | long\nCHAR,VHARCHAR   | getString()         | String\nText(Clob),Blob | getClob(),getBlob() | Clob,Blob\nDATE            | getDate()           | java.sql.Date 日期\nTIME            | getTime()           | java.sql.time 时间\nTIMESTAMP       | getTime()           | java.sql.TimeStamp 日期时间\n\n## 经典查询\n\n```java\ntry(Connection connection = DriverManager.getConnection(\"jdbc:mysql:///test?user=root&password=123\")){\nResultSet rs = connection.createStatement().executeQuery(\"select * from account\");\nwhile (rs.next()){\n    System.out.println(rs.getString(\"name\")+\"|\"+rs.getDouble(\"balance\"));\n}\n}catch (SQLException e){\n    e.printStackTrace();\n}\n```\n\n## SQL注入与PreparedStatement\n\n使用 PreparedStatement 避免 SQL注入\n\n## 事务控制\n\n```java\nconnection.setAutoCommit(false);\nconnection.commit();\nconnection.rollback();\n```\n\n## 数据库连接池\n\n> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n- c3p0\n- druid\n\n## 参数\n\n- 空闲线程数：初始化线程，还没被使用\n- 活动线程数：正在被使用的\n- 最大线程数：限制最多只能创建的线程数\n\n## JDBCUtils\n\n- 提供静态代码块加载配置文件，初始化连接池对象\n- 提供方法\n\n  - 获取连接方法：通过数据库连接池获取连接\n  - 释放资源\n  - 获取连接池的方法\n\n## DruidDatasource在并发环境下卡死的问题\n\n在测试一个并发写入时，当线程数超过一定量时，发现线程阻塞住了。使用VisualVM 分析线程栈\n\n发现线程在druid相关代码附近处于wating状态：\n\n![屏幕截图 2021-06-10 102911](/assets/屏幕截图%202021-06-10%20102911.png)\n\n出现这个的问题原因在于每个线程可能都会开启事务，然后申请一些连接做一些操作，当并发上去后，每个线程都会持有住一些连接，都在等待其他线程释放连接以能继续获取连接做操作，进而导致这些线程互相等待，阻塞在那边\n\ndruid 默认的最大连接为8 将其调大一点即可。\n\n```yml\nmax-active: 50\nremove-abandoned: true\n```\n\n## 池化\n\n核心思想是空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销\n\n数据库连接池相比线程池的一个设计要点就是保活检测，大部分数据库都会在连接空闲一段时间关闭连接，这部分客户端是无感知，使用关闭的连接就会抛出异常，这点在早期使用单个连接的项目遇到过，MySQL连接空闲超过8个小时，再使用就报错，当时的解决方案是调高服务端的空闲超时时间\n\n但对于连接池，可以通过两种方式来避免出现这种错误：\n\n1. 定期发送select 1语句检测\n2. 在每次获取到连接后，检测连接是否可用，但这种方式会引入多余的开销\n","metadata":"","hasMoreCommit":false,"totalCommits":8,"commitList":[{"date":"2024-11-18T16:40:55+08:00","author":"MY","message":"📦Java 高级","hash":"2b21c6566aa4db8dff3d81003dea531cbe044061"},{"date":"2022-08-14T19:41:43+08:00","author":"MY","message":"✏️JDBC","hash":"79bbb6d859542fa409ceaa8250d8e165c27b8ac8"},{"date":"2022-04-19T11:31:47+08:00","author":"cjiping","message":"📦整理 问题记录","hash":"68080b22aa70385e3941d8bd0502d83fb67312c5"},{"date":"2021-03-28T15:54:01+08:00","author":"MY","message":"✏更新 JDBC","hash":"7f69bf40c13d1b1b034ff77e088580231a486695"},{"date":"2020-08-04T10:27:34+08:00","author":"MY","message":"✏更新 JDBC","hash":"dfd8249bba27f2dfa7b4b6f1ab3435eabf8c40d2"},{"date":"2020-01-15T10:58:29+08:00","author":"MY","message":"更新线程池参数","hash":"b4a44220d08cc2db92862b269602da3d9310bffb"},{"date":"2019-08-05T17:13:15+08:00","author":"My、","message":"20190805下午","hash":"dc471f85edcf0636e5cca741a062a7cc53843924"},{"date":"2019-08-05T12:20:56+08:00","author":"My、","message":"20190805上午","hash":"d70e208de459f08537d8bfb2d9b8ebbf3a1bf867"}],"createTime":"2019-08-05T12:20:56+08:00"}