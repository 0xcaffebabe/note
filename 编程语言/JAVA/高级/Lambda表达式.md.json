{"name":"Lambda表达式","id":"编程语言-JAVA-高级-Lambda表达式","content":"# Lambda 表达式\n\n```java\n(参数列表) ‐> { 代码语句 }\n```\n\n```java\n// Lambda表达式的书写形式\nRunnable run = () -> System.out.println(\"Hello World\");// 1\nActionListener listener = event -> System.out.println(\"button clicked\");// 2\nRunnable multiLine = () -> {// 3 代码块\n    System.out.print(\"Hello\");\n    System.out.println(\" Hoolee\");\n};\nBinaryOperator<Long> add = (Long x, Long y) -> x + y;// 4\nBinaryOperator<Long> addImplicit = (x, y) -> x + y;// 5 类型推断\n```\n\n- 类似于匿名方法，一个没有名字的方法\n- 可以忽略写参数类型\n- 坚决不声明返回值类型\n- 没有修饰符\n- 单句表达式，将直接返回值，不用大括号\n- 带return语句， 算多句，必须用大括号\n- 无参数，仅保留括号\n- 一个参数，可省略括号\n\n## 使用前提\n\n- 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法(称之为函数式接口)。 无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一 时，才可以使用Lambda。\n- 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。\n\n> 有且仅有一个抽象方法的接口，称为\"函数式接口\"。\n\n## 函数式接口\n\n- 是一个接口，符合Java接口的定义\n- 只包含一个抽象方法的接口\n- 可以包括其他的default方法、static方法、private方法\n- 由于只有一个未实现的方法，所以Lambda表达式可以自动填上这个尚未实现的方法\n- 采用Lambda表达式，可以自动创建出一个(伪)嵌套类的对象(没有实际的嵌套类class文件产生)，然后使用，比真正嵌套类更加轻量，更加简洁高效\n\n- @FunctionalInterface注解\n\n> 一旦使用该注解来标记接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则编译将会报错。\n\n\n```java\n@FunctionalInterface\npublic interface SuperRunnable {\n    void superRun();\n}\n```\n\n```java\npublic static void main(String[] args) {\n    superRun(()-> System.out.println(\"hello world\"));\n}\nprivate static void superRun(SuperRunnable sr){\n    sr.superRun();\n}\n```\n\n- 尽量使用系统自带的函数式接口，不要自己定义\n\n接口               | 参数   | 返回值     | 示例\n---------------- | ---- | ------- | --------------\n`Predicate<T>`   | T    | Boolean | 接收一个参数，返回一个布尔值\n`Consumer<T>`    | T    | void    | 接受一个参数，无返回\n`Function<T, R>` | T    | R       | 接受一个参数，返回一个值\n`Supplier<T>`    | None | T       | 无参数 返回一个值\n\n## Lambda JVM层实现\n\nJava编译器将Lambda表达式编译成使用表达式的类的一个私有方法，然后通过invokedynamic指令调用该方法。所以在Lambda表达式内，this引用指向的仍是使用表达式的类。\n\n通过一些编译优化技术，如果分析得到这个类可以是无状态，就可以内联优化，否则每次执行就必须创建这个动态类的实例\n\n## 方法引用\n\n- Class::staticMethod，如 Math::abs方法\n  - Math::abs 等价于 x -> Math.abs(x)\n- Class::instanceMethod，如String::compareToIgnoreCase方法\n  - String::compareToIgnoreCase等价于(x,y)->x.compareToIgnoreCase(y)\n- object::instanceMethod，如System.out::println方法\n  - System.out::println等价于x->System.out.println(x)\n  - 支持this::instanceMethod 调用\n  - 支持super::instanceMethod 调用\n- Class::new，调用某类构造函数，支持单个对象构建\n  - `Supplier<Object> ` sp = Object::new\n- Class[]::new，调用某类构造函数，支持数组对象构建\n  - `Function<Integer,Object> ` f = Object[]::new\n\n## 应用\n\n- 类型信息\n  - 被赋值后，可以看作是一个函数式接口的实例(对象)\n  - 但是Lambda表达式没有存储目标类型(target type)的信息\n  - 重载调用，依据重载的规则和类型参数推理\n- 变量遮蔽\n  - Lambda表达式可以访问外部嵌套块的变量\n    - 但是变量要求是final或者是effectively final的\n  - 在Lambda表达式中，不可以声明与(外部嵌套块)局部变量同名的参数或者局部变量\n- 表达式中的this，就是创建这个表达式的方法的this参数\n- 优先级比嵌套类要高\n  - 无法创建命名实例，无法获取自身的引用(this)\n- 方法引用比自定义Lambda表达式的优先级高\n  - 系统自带的方法引用更简洁高效\n  - 对于复杂的Lambda表达式，采用方法引用比内嵌Lambda表达式更清晰，更容易维护\n- 坚持使用标准的函数式接口","metadata":"","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2023-08-20T15:43:00+08:00","author":"MY","message":"✏️JVM","hash":"ec497f7b6e48d763cece8e02546081140ea80280"},{"date":"2021-04-06T14:40:42+08:00","author":"cjiping","message":"✏更新 Java Lambda表达式","hash":"f9801bc57e3e8ed72890117b8d1997068ac9defb"},{"date":"2020-08-04T09:43:36+08:00","author":"MY","message":"✏更新 lambda","hash":"1f6ea7692e89e1f4c962137316a070066f84f2a4"},{"date":"2019-12-01T16:31:00+08:00","author":"MY","message":"新增struts2执行流程&结束lambda表达式","hash":"8cdce22b8263268d608da8fc31b9c1af3432228c"},{"date":"2019-11-30T17:00:48+08:00","author":"MY","message":"方法引用&MYSQL配置优化&MVC","hash":"99739ecaa9277e062a5899e721e8074dccffc933"},{"date":"2019-11-29T17:06:27+08:00","author":"MY","message":"新增MYSQL优化&lambda起步","hash":"cc7c99e49c99680b7e5bb68e69fa52204f4017d6"},{"date":"2019-08-02T17:01:26+08:00","author":"My、","message":"20190802下午","hash":"08ddcb46913450cce3a003ebb6f79586f0215b7d"}],"createTime":"2019-08-02T17:01:26+08:00"}