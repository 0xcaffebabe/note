{"name":"Stream流","id":"编程语言-JAVA-高级-Stream流","content":"# Stream\n\n- sequence of elements: 一个流对外提供一个接口，可以访问到一串特定的数据。流不存储元素，但是可以根据需要进行计算转化\n- source：数据来源，如数据结构，数组，文件等\n- aggregate operation：聚合操作，流支持像SQL操作或者其他函数式语言的操作，如filter/map/reduce/find/match/sorted等\n- Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（ﬂuent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 \n- Internal Iteration： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。\n\n## 处理流程\n\n![20233915651](/assets/20233915651.webp)\n\n- 流的创建\n- 流的转换，将流转换为其他流的中间操作，可包括多个步骤(惰性操作)\n- 流的计算结果。这个操作会强制执行之前的惰性操作。这个步骤以后，流就再也不用了\n\n## 获取流\n\n### Stream类\n\n- of 方法，直接将数组转化\n\n```java\nStream<Integer> integerStream = Stream.of(1, 2, 3);\n```\n\n- empty方法，产生一个空流\n- generate 方法，接收一个Lambda表达式\n\n```java\nStream<Double> stream = Stream.generate(Math::random);\n```\n\n- iterate方法，接收一个种子，和一个Lambda表达式\n\n```java\nStream<BigInteger> iterate = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));\n```\n\n### 根据Collection获取\n\n```java\nStream<String> stream = list.stream(); \n```\n\n### 根据Map获取流 \n\n```java\nStream<String> keyStream = map.keySet().stream(); \nStream<String> valueStream = map.values().stream();\nStream<Map.Entry<String, String>> entryStream = map.entrySet().stream();\n```\n\n### 基本类型流\n\n- IntStream，LongStream，DoubleStream\n\n### 并行流\n\n- 使得所有的中间转换操作都将被并行化\n- Collections.parallelStream()将任何集合转为并行流\n- Stream.parallel()方法，产生一个并行流\n\n### 流的方法\n\n- 延迟方法（中间操作）：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） \n- 终结方法（结束操作）：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。\n\n操作类型 | 接口方法\n---- | -----------------------------------------------------------------------------------------------------------------------------------\n中间操作 | concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()\n结束操作 | allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()\n\n\n#### 转换方法\n\n### 过滤filter\n\n- filter(Predicate<? super T> predicate)\n- 接收一个Lambda表达式，对每个元素进行判定，符合条件留下\n\n### 去重distinct\n\n- 对流的元素进行过滤，去除重复，只留下不重复的元素\n- 对象的判定，先调用hashCode方法，再调用equals方法\n\n### 排序sorted\n\n- 提供Comparator，对流的元素进行排序\n\n### map\n\n>利用方法引用对流每个元素进行函数计算\n\n```java\nStream.of(1,2,3)\n        .map(String::valueOf)\n        .forEach(System.out::println); // [\"1\",\"2\",\"3\"]\n```\n\n#### flatMap\n\n对结果进行展开\n\n### 抽取limit\n\n只取前n个\n\n### 跳过skip\n\n跳过前n个\n\n### 连接concat\n\n```java\nStream.concat(s1,s2); // 连接两个流\n```\n\n### 额外调试peek\n\n可以对流操作，但是不影响它\n\n### Optional\n\n`Optional<T>`\n\n- 一个包装器对象\n- 要么包装了类型T的对象，要么没有包装任何对象\n- 如果T有值，那么直接返回T的对象\n- 如果T是null，那么可以返回一个替代物\n\n### 使用\n\n- get方法，获取值，不安全的用法\n- orElse方法，获取值，如果为null，采用替代物的值\n- orElseGet方法，获取值，如果为null，采用Lambda表达式值返回\n- orElseThrow方法，获取值，如果为null，抛出异常\n- ifPresent方法，判断是否为空，不为空返回true\n- isPresent(Consumer), 判断是否为空，如果不为空，则进行后续Consumer操作,如果为空，则不做任何事情\n- map(Function), 将值传递给Function函数进行计算。如果为空，则不计算\n\n### 注意事项\n\n- 直接使用get，很容易引发NoSuchElementException异常\n- 使用isPresent判断值是否存在，这和判断null是一样的低效\n\n## 终结方法\n\n### 聚合函数\n\n- count(), 计数\n- max(Comparator)，最大值，需要比较器\n- min(Comparator)，最小值，需要比较器\n- findFirst(), 找到第一个元素\n- findAny(), 找到任意一个元素\n- anyMatch(Predicate)，如有任意一个元素满足Predicate，返回true\n- allMatch(Predicate)，如所有元素满足Predicate，返回true\n- noneMatch(Predicate)，如没有任何元素满足Predicate，返回true\n\n### 归约函数\n\nreduce，传递一个二元函数BinaryOperator，对流元素进行计算\n\n如求和、求积、字符串连接\n\n```java\n// 求单词长度之和\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nInteger lengthSum = stream.reduce(0,　// 初始值　// (1)\n        (sum, str) -> sum+str.length(), // 累加器 // (2)\n        (a, b) -> a+b);　// 部分和拼接器，并行执行时才会用到 // (3)\n// int lengthSum = stream.mapToInt(str -> str.length()).sum();\nSystem.out.println(lengthSum);\n```\n\ncollect方法\n\n```java\n// 将Stream转换成容器或Map\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(Collectors.toList()); // (1)\n// Set<String> set = stream.collect(Collectors.toSet()); // (2)\n// Map<String, Integer> map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)\n```\n\n### 迭代函数\n\n- iterator() ：获取一个迭代器\n- forEach(Consumer)，应用一个函数到每个元素上\n\n### 收集函数\n\n- toArray()，将结果转为数组\n- collect(Collectors.toList()),将结果转为List\n- collect(Collectors.toSet()),将结果转为Set\n- collect(Collectors.toMap()), 将结果转为Map\n- collect(Collectors.joining()), 将结果连接起来\n\n## 优点\n\n- 统一转换元素\n- 过滤元素\n- 利用单个操作合并元素\n- 将元素序列存放到某一个集合中\n- 搜索满足某些条件的元素的序列\n- 类似SQL操作，遵循“做什么而非怎么做”原则\n- 简化了串行/并行的大批量操作\n- stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行\n\n### 与循环迭代比较\n\n- Stream广泛使用Lambda表达式，只能读取外围的final或者effectivelyfinal变量，循环迭代代码可以读取/修改任意的局部变量\n- 在循环迭代代码块中，可以随意break/continue/return，或者抛出异常，而Lambda表达式无法完成这些事情\n\n## 注意事项\n\n- 一个流，一次只能一个用途，不能多个用途，用了不能再用\n- Stream只是某种数据源的一个视图\n- 避免创建无限流\n- 注意操作顺序\n- 谨慎使用并行流\n\n## Stream流水线原理\n\n![20214615247](/assets/20214615247.png)\n\nparallelStream 通过默认的ForkJoinPool，可能提高多线程任务的速度\n\n多个parallelStream之间默认使用的是同一个线程池\n","metadata":"","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2023-03-09T07:12:02Z","author":"My","message":"✏Stream","hash":"06edeba74e2731061452c398872d6a6b3629287c"},{"date":"2021-04-06T16:20:30+08:00","author":"cjiping","message":"✏更新 Java Stream","hash":"b58e141b06df93335e6ef726b32bc0fc583e4008"},{"date":"2020-08-04T09:53:04+08:00","author":"MY","message":"✏更新 JAVA stream","hash":"69f03c7192262c8fd52f7fab8a7000b89a6272ef"},{"date":"2019-12-08T14:23:54+08:00","author":"MY","message":"完成了stream相关内容","hash":"4aae4ec20e88ac5d6110387dc82df4dac88d00f5"},{"date":"2019-12-07T14:55:07+08:00","author":"MY","message":"添加stream转换&optional","hash":"57ce4477a28acee6db1f0cfbae1d1aeb9a455754"},{"date":"2019-12-06T17:15:16+08:00","author":"MY","message":"添加JAVA Stream& netty核心api","hash":"572798d92188f9d14fdb2ef3d6ad14175d9b0569"},{"date":"2019-08-04T12:13:16+08:00","author":"My、","message":"20190804上午","hash":"c4ac198813db6607fdf56fec9320bc02cdcaa99e"}],"createTime":"2019-08-04T12:13:16+08:00"}