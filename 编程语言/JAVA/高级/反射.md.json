{"name":"反射","id":"编程语言-JAVA-高级-反射","content":"# 反射\n\n>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制\n\n好处： \n\n- 可以在程序运行过程中，操作这些对象。 \n-  可以解耦，提高程序的可扩展性。\n\n作用：\n\n- 在运行中分析类的能力\n- 在运行中查看和操作对象\n  - 基于反射自由创建对象\n  - 反射构建出无法直接访问的类\n  - set或者get到无法访问的成员变量\n  - 调用不可访问的方法\n- 实现通用的操作代码\n- 类似函数指针的功能\n\n## 使用反射创建对象\n\n```java\nString s = String.class.getConstructor(String.class).newInstance(\"str\");\n```\n\n## 关键类\n\n```mermaid\nstateDiagram-v2\n  direction LR\n  state \"Class\" as c1\n  c1 --> Field: getFields() getDeclaredFields()\n  c1 --> Package: getPackage()\n  c1 --> 接口(Class): getInterfaces()\n  c1 --> Constructor: getConstructors()\n  c1 --> Method: getMethods() getDeclaredMethods()\n  c1 --> 修饰符(int): getModifiers()\n  c1 --> 父类(Class): getSuperclass()\n  c1 --> Annotation: getAnnotations()\n```\n\n### Class\n\n- cast：对象转型\n- isInstance：类型确认\n- isAssignableFrom：是否从某个类派生\n\n```java\nCharSequence.class.isAssignableFrom(String.class)\n```\n\n类型的比较可以通过 instanceof 或者 isInstance接口来进行 这两个接口的比较是有考虑继承关系。\n\n另外一种比较可以通过比较两个class对象，这种方式没有考虑继承关系。\n\n## 安全性\n\n反射提供的 AccessibleObject.setAccessible​(boolean flag) 可以在运行时修改成员访问限制\n\n在后续的版本中，Java 逐渐收紧了这个功能，只有在模块描述文件中开放权限才是合法的：\n\n```java\nmodule MyEntities {\n    // Open for reflection\n    opens com.mycorp to java.persistence;\n}\n```\n\n当然，目前只是报一个警告，只是不知道在哪个版本中就会彻底关闭这个功能\n\n## 应用\n\n- 加载JDBC驱动\n- 任意类型数组扩容\n- 动态方法调用\n- JSON序列化与反序列化\n- Servlet创建\n- ORM\n- Bean容器\n\n## JAVA反射增强\n\n[org.reflections](https://github.com/ronmamo/reflections)\n\n### 功能\n\n- get all subtypes of some type\n- get all types/members annotated with some annotation\n- get all resources matching a regular expression\n- get all methods with specific signature including parameters, parameter annotations and return type\n\n## NoClassDefFoundError 和 ClassNotFoundException\n\n1. 如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError\n2. 如果通过Class.forName 进行加载找不到，则会抛出 ClassNotFoundException\n\n## 反射的实现\n\n一个通过本地方法来实现反射调用，即通过 JNI 来进行方法调用，另一个则使用了委派模式，即动态代理生成对具体类的具体方法方法调用\n\n## 反射的开销\n\n1. 变长参数方法需要创建 Object 数组\n2. 基本类型的自动装箱、拆箱\n3. 方法内联优化失效\n\n","metadata":"","hasMoreCommit":false,"totalCommits":10,"commitList":[{"date":"2024-11-18T16:40:55+08:00","author":"MY","message":"📦Java 高级","hash":"2b21c6566aa4db8dff3d81003dea531cbe044061"},{"date":"2023-08-20T15:43:00+08:00","author":"MY","message":"✏️JVM","hash":"ec497f7b6e48d763cece8e02546081140ea80280"},{"date":"2022-10-13T21:40:59+08:00","author":"MY","message":"✏️Java","hash":"bbaeb90fa7917234d83a4c49ba28753559665e70"},{"date":"2022-10-12T21:49:08+08:00","author":"MY","message":"✏️Java","hash":"0dc1fa35b269f76ec4eb6430d20f667ca134b0ed"},{"date":"2021-06-28T15:17:07+08:00","author":"cjiping","message":"✏更新 Java 反射","hash":"b006abd048303598fb9d1478b5fdb4c442163186"},{"date":"2021-06-23T10:46:08+08:00","author":"cjiping","message":"✏更新 Java 反射","hash":"5a4b6e910ab29945fcf25a762737da06f967bec2"},{"date":"2020-08-04T09:35:57+08:00","author":"MY","message":"✏更新 JAVA 反射","hash":"b75e4f36dca59f19eac0056cd210321d19254f74"},{"date":"2019-11-03T16:34:01+08:00","author":"MY","message":"新增JAVA反射相关内容","hash":"e3f5413a4260cd9ed987feb46f33a8b32a9bd4b5"},{"date":"2019-11-01T17:10:26+08:00","author":"MY","message":"新增了DevOps相关内容","hash":"8dfd17879e8bee6b7e9a1599d48ce46ded00dd5e"},{"date":"2019-08-04T19:13:18+08:00","author":"My、","message":"20190804下午","hash":"42f2cd3a3e1d8b203764307a546a0cafe4c538ee"}],"createTime":"2019-08-04T19:13:18+08:00"}