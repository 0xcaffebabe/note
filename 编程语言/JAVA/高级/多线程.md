
- 并发：指两个或多个事件在同一个时间段内发生。
- 并行：指两个或多个事件在同一时刻发生（同时发生）。

# 线程安全

> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。

## JAVA API中的线程安全问题

- StringBuffer
- Vector

### 原理

> 使用了锁对象，这个锁对象一瞬间只能被一个线程所持有

## 线程间通信

- 等待-唤醒机制

![06_等待唤醒案例分析](/assets/06_等待唤醒案例分析.bmp)

要注意，wait() notify() notifyAll()都需要在synchronized中

wait() 会释放锁，sleep() 不会

```java
Object object = new Object();

new Thread(){
    @Override
    public void run() {
        synchronized (object){
            System.out.println("要5个包子");
            // 进入等待，这时候锁会被释放
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("得到了5个包子");
        }
    }
}.start();

new Thread(){
    @Override
    public void run() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (object){
            System.out.println("包子生产完毕，告诉顾客");
            // 通知等待线程中的任意一个
            object.notify();
        }
    }
}.start();
```

- wait与notify一定要在线程同步中使用,并且是同一个锁的资源
- 在调用sleep()方法的过程中，线程不会释放对象锁

## 线程池

好处：
- 降低资源消耗
- 提高响应速度
- 提高线程的可管理性

### 并发队列

- 阻塞队列与非阻塞队列

>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞

### 线程池分类

- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行

### 线程池原理

![](https://user-gold-cdn.xitu.io/2018/5/6/163349e503061169?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 自定义线程池

```java
BlockingQueue<Runnable> queue = new LinkedBlockingDeque<>(10);
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2/*实际运行线程数*/,
                3/*最多可创建的线程数*/,
                0L /* 让线程存活的时间 0为永久 */,
                TimeUnit.SECONDS,
                queue);
```

- 合理配置
  - CPU密集型，IO密集型

### 使用

```java
ExecutorService executorService = Executors.newFixedThreadPool(6);
for (int i =0;i<100;i++){
    int finalI = i;
    executorService.submit(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("run"+ finalI);
        }
    });
}
executorService.shutdown();
```

## 异步任务

```java
Future<String> future = pool.submit(() -> {
    Thread.sleep(3000);
    return "java";
});
String s = future.get();
```

### Future模式

```java
public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyFuture myFuture = new MyFuture();
        // 在这里 main thread 可以做其他事情
        // 下一行代码将阻塞直到结果可用
        System.out.println(myFuture.getData());
    }
}

class MyFuture{

    private volatile boolean FLAG = false;
    private String data;

    public MyFuture() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("future 任务开始 睡眠 3000ms");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("future 任务结束");
                setData("jntm");
            }
        }).start();
    }

    private synchronized void setData(String data){
        if (FLAG){
            return;
        }
        this.data = data;
        FLAG = true;
        notify();
    }

    public synchronized String getData(){
        while (!FLAG){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return data;
    }
}
```

### 悲观锁 乐观锁

- 乐观锁

总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现

```sql
update table set x=x+1, version=version+1 where id=${id} and version=${version};
```

- 悲观锁

总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起

synchronized是悲观锁

### 自旋锁

>线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待

### 分布式锁

- zookeeper与redis实现

## Disruptor

### 设计方案

- 环形数组结构
  - 为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。
- 元素位置定位
  - 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。
- 无锁设计
  - 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。
