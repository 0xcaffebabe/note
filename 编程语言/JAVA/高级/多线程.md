
- 并发：指两个或多个事件在同一个时间段内发生。
- 并行：指两个或多个事件在同一时刻发生（同时发生）。

# 线程安全

> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。

## JAVA API中的线程安全问题

- StringBuffer
- Vector

## 同步

- 同步代码块

- 锁机制

  - public void lock() :加同步锁。
  - public void unlock() :释放同步锁。

### synchronized vs ReentrantLock 

- synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的
- 新版本java 两者性能大致相同
- ReentrantLock 可中断，而 synchronized 不行
- synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的
-  ReentrantLock 可以同时绑定多个 Condition 对象

应该优先选择synchronized:

- synchronized的锁释放是自动的
- jvm天生支持

### 原理

> 使用了锁对象，这个锁对象一瞬间只能被一个线程所持有

## 线程间通信

- 等待-唤醒机制

![06_等待唤醒案例分析](/assets/06_等待唤醒案例分析.bmp)

要注意，wait() notify() notifyAll()都需要在synchronized中

wait() 会释放锁，sleep() 不会

```java
Object object = new Object();

new Thread(){
    @Override
    public void run() {
        synchronized (object){
            System.out.println("要5个包子");
            // 进入等待，这时候锁会被释放
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("得到了5个包子");
        }
    }
}.start();

new Thread(){
    @Override
    public void run() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (object){
            System.out.println("包子生产完毕，告诉顾客");
            // 通知等待线程中的任意一个
            object.notify();
        }
    }
}.start();
```

- wait与notify一定要在线程同步中使用,并且是同一个锁的资源
- 在调用sleep()方法的过程中，线程不会释放对象锁

## 线程池

好处：
- 降低资源消耗
- 提高响应速度
- 提高线程的可管理性

### 并发队列

- 阻塞队列与非阻塞队列

>阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞

### 线程池分类

- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行

### 线程池原理

![](https://user-gold-cdn.xitu.io/2018/5/6/163349e503061169?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 自定义线程池

```java
BlockingQueue<Runnable> queue = new LinkedBlockingDeque<>(10);
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2/*实际运行线程数*/,
                3/*最多可创建的线程数*/,
                0L /* 让线程存活的时间 0为永久 */,
                TimeUnit.SECONDS,
                queue);
```

- 合理配置
  - CPU密集型，IO密集型

### 使用

```java
ExecutorService executorService = Executors.newFixedThreadPool(6);
for (int i =0;i<100;i++){
    int finalI = i;
    executorService.submit(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("run"+ finalI);
        }
    });
}
executorService.shutdown();
```

## 异步任务

```java
Future<String> future = pool.submit(() -> {
    Thread.sleep(3000);
    return "java";
});
String s = future.get();
```

### Future模式

```java
public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyFuture myFuture = new MyFuture();
        // 在这里 main thread 可以做其他事情
        // 下一行代码将阻塞直到结果可用
        System.out.println(myFuture.getData());
    }
}

class MyFuture{

    private volatile boolean FLAG = false;
    private String data;

    public MyFuture() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("future 任务开始 睡眠 3000ms");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("future 任务结束");
                setData("jntm");
            }
        }).start();
    }

    private synchronized void setData(String data){
        if (FLAG){
            return;
        }
        this.data = data;
        FLAG = true;
        notify();
    }

    public synchronized String getData(){
        while (!FLAG){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return data;
    }
}
```

## 锁机制

轻量级锁与重量级锁

区别：“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的

### 重入锁

 ReentrantLock 和synchronized 都是 可重入锁

- 可重入
  - 是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响

### 读写锁

当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞

当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁

```java
class Cache {
    private Map<String, Object> cache = new HashMap<>();
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {
        ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();
        writeLock.lock();
        System.out.println("写入开始" + key);
        cache.put(key, value);
        System.out.println("写入结束" + key);
        writeLock.unlock();
    }

    public Object get(String key) {
        ReentrantReadWriteLock.ReadLock readLock = lock.readLock();
        readLock.lock();
        System.out.println("读取开始" + key);
        Object value = cache.get(key);
        System.out.println("读取结束" + key);
        readLock.unlock();
        return value;
    }
}
```

### 悲观锁 乐观锁

- 乐观锁

总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现

```sql
update table set x=x+1, version=version+1 where id=${id} and version=${version};
```

- 悲观锁

总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起

synchronized是悲观锁

#### 原子类

- AtomicInteger

#### CAS

![批注 2020-05-12 135356](/assets/批注%202020-05-12%20135356.png)

它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值

- CAS缺点

CAS存在一个很明显的问题，即ABA问题。

如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过

### 自旋锁

>线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待

### 公平锁与非公平锁

- 公平锁：每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁
- 非公平锁：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关

### 分布式锁

- zookeeper与redis实现

## Disruptor

### 设计方案

- 环形数组结构
  - 为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。
- 元素位置定位
  - 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。
- 无锁设计
  - 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。
