{"name":"常用API","id":"编程语言-JAVA-高级-常用API","content":"# 常用API\n\n## Scanner\n\n```java\nScanner scanner = new Scanner(System.in);\nint a = scanner.nextInt();\nint b = scanner.nextInt();\nSystem.out.println(\"max:\" + (a > b ? a : b));\n```\n\n## Random\n\n```java\nRandom random = new Random();\nSystem.out.println(random.nextInt());\n```\n\n## 基本类型与相对应的包装类型\n\n基本类型    | 基本类型包装类\n------- | ---------\nbyte    | Byte\nshort   | Short\nint     | Integer\nlong    | Long\nﬂoat    | Float\ndouble  | Double\nchar    | Character\nboolean | Boolean\n\nLong与Integer一样，都对一定范围内的值做了缓存，所以有些Long对象，数值相同的情况下，直接用==比较会相等，valueOf有做缓存，parseLong则没有\n\n## String\n\n特点：\n\n- 字符串不变：字符串的值在创建后不能被更改。\n  - String内部是实现byte数组实现的\n- 因为String对象是不可变的，所以它们可以被共享。\n\n```java\nprivate final byte[] value;\n```\n\n并且这个数组一旦赋上值，就无法再修改这个数组的引用了，同时String封装的很好，没有提供外部公开接口能直接操作这个数组，并且String类为final的，保证不会被继承，方法也不会被覆写，所以**String不可变**\n\nStringBuilder 线程不安全(效率更高)\n\nStringBuffer 线程安全\n\nString 在 Java 6 以后提供了 intern() 方法，可以通过此方法来返回代表某一字符串的唯一实例，但问题是这个实例会被缓存在永久代中，如果使用不当，OOM 就会光顾\n\n在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题\n\nOracle JDK 8u20 之后，推出了一个新的特性，可以将相同数据的字符串指向同一份数据来做到的，但需要配置`\n-XX:+UseStringDeduplication\n`来开启这个特性\n\nJDK9之后对字符串进行优化，从原来的char数组编程了byte数组，精简了字符串，减少空间占用\n\nJDK对字符串的另外一个优化是对字符串加法语法转换成StringBuilder，在9之后的版本，这个优化手段变成了java.lang.invoke.StringConcatFactory#makeConcatWithConstants 统一了入口，相比之前在javac中硬编码好\n\n### equals原理\n\n```java\nif (this == obj){\n    return true;\n}\nif (obj instanceof String){\n    if (this.value.length == obj.value.length){\n        for(0...obj.length){\n            if (this.value[i] != obj.value[i]){\n                return false;\n            }\n        }\n    }\n}\nreturn false;\n```\n\n### 乱码问题\n\n如何解决 String 乱码\n\n1. 选择可以表示中文的字符集 像iso8859-1就无法表示中文\n2. 在可以指定字符集的地方指定字符集\n\n## Arrays\n\n常用方法：\n\n- toString\n- sort\n- asList\n\n使用的双轴快速排序\n\n- binarySearch\n- copyOf、copyOfRange\n\n## Collections\n\n- min、max\n\n这里可以学习一下最值方法返回值泛型的定义：\n\n```java\npublic static <T extends Object & Comparable<? super T>> T max\n```\n\n代表T必须继承自Object且实现了Comparable接口\n\n- [包装线程安全的集合](/编程语言/JAVA/高级/集合/集合.md#线程安全)\n\nsynchronized打头的方法可以将指定的集合包装成线程安全的集合\n\n具体原理是Collections内部有这些对应的线程安全集合，这些集合内部组合线程不安全的集合，通过synchronized加锁来操作内部的这些集合\n\n- 不可变集合\n\nunmodifiable 打头的方法则是会得到一些不可变集合，这些集合不能执行修改操作，否则会抛异常，也是通过对集合的包装来实现的\n\n## Math\n\n- abs：取绝对值\n- ceil：返回大于等于参数的小的整数（向上取整）\n- floor：返回小于等于参数大的整数（向下取整）\n- roud：四舍五入\n\n## Object\n\n- toString\n- equals\n- hashCode\n- wait\n- notify\n\n## Objects\n\n- equals\n\nObjects的equals内部的比较采用了deepEquals，这样即使两个对象是数组，也能放心比较\n\n一些判空方法：\n\n- isNull\n- nonNull\n- requireNonNull\n\n---\n\n问：如何写好一个工具类\n\n答： static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段\n\n### Clone\n\n对象 clone 方法默认是浅拷贝，若想实现深拷贝需覆写 clone 方法实现域对象的深度遍历式拷贝。\n\n- java天生就对原型模式做了很好的支持，这个支持就是Object中的clone方法\n\n## LocalDateTime\n\n```java\nLocalDateTime.now()\n```\n\n## System\n\n- currentTimeMillis\n- arraycopy\n\n## StringBuilder\n\nString字符串是常量；它们的值在创建之后不能更改。字符串的底层是一个被final修饰的数组，不能改变，是一个常量\n\n```java\nprivate final char value[];\n```\n\nStringBuilder是字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），底层也是一个数组，但是没有被final修饰，可以改变长度\n\n```java\nchar[] value;\n```\n\n```java\nStringBuilder sb = new StringBuilder(\"hello\");\nsb.append(\" \")\n        .append(\"world\");\nSystem.out.println(sb.toString());\n```\n\n## 包装类\n\n基本数据类型，使用起来非常方便但是没有对应的方法来操作这些基本类型的数据\n\n可以使用一个类把基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类\n我们可以使用类中的方法来操作这些基本类型的数据\n\n```mermaid\nstateDiagram-v2\n    state Integer类 {\n        10\n    }\n    state Double类 {\n        8.5\n    }\n```\n\n- 装箱拆箱\n  - 自动装箱拆箱\n\n选择包装类还是基本数据类型：\n\n1. POJO类属性全部使用包装类\n2. RPC方法参数与返回值全部使用包装类\n3. 局部变量尽可能使用基本类型\n\n```java\nInteger integer = 1;\nint unboxing = integer ++;\n```\n\n以上两句代码会被编译成：\n\n```\n1: invokestatic  #2                  // Method\njava/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n8: invokevirtual #3                  // Method\njava/lang/Integer.intValue:()I\n```\n\n### 基本类型与字符串的转换\n\n```java\nSystem.out.println(Double.toString(1.6));\nSystem.out.println(Double.parseDouble(\"1.5\"));\n```\n","metadata":"","hasMoreCommit":false,"totalCommits":9,"commitList":[{"date":"2024-11-18T15:00:13+08:00","author":"MY","message":"📦Java 基础","hash":"270332d69c4b80cb8600b368ecda389c7c95b038"},{"date":"2023-11-24T11:45:52+08:00","author":"MY","message":"📦清理大图","hash":"e3ff900ed2a2e49e9f3bd316935fe853796f7e52"},{"date":"2022-10-13T21:40:59+08:00","author":"MY","message":"✏️Java","hash":"bbaeb90fa7917234d83a4c49ba28753559665e70"},{"date":"2022-06-22T16:40:38+08:00","author":"cjiping","message":"📦整理 Java","hash":"dd8a407d9e17e954526376861d539512ad700daa"},{"date":"2022-06-09T21:51:44+08:00","author":"MY","message":"📦整理 Java","hash":"34c01b44e7566fa54773149765e3dd8420235279"},{"date":"2020-09-16T15:35:24+08:00","author":"MY","message":"✏更新 Java 常用 API","hash":"2f76afee894c19abb2918d9747687ffd498f4a8c"},{"date":"2020-08-03T12:04:49+08:00","author":"MY","message":"✏更新 JAVA 常用 API","hash":"aeb726bb2907191bcd990cbb29afdac25549cc92"},{"date":"2019-08-02T11:59:43+08:00","author":"My、","message":"20190802上午","hash":"7557fcbba6d18f4ba23fac592ef519092183fd3c"},{"date":"2019-08-01T17:04:39+08:00","author":"My、","message":"20190801下午","hash":"8ecb58cdc85b79ac405610f62f88d7804e54a808"}],"createTime":"2019-08-01T17:04:39+08:00"}