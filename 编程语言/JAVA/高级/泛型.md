# 泛型

- 泛型类
- 泛型接口
- 泛型方法

关于泛型的几点：

1. 尖括号里的每个元素都代表一种未知类型
2. 尖括号只能出现在类名之后或者方法返回值之前

使用泛型的好处：

1. 类型安全 避免粗心导致的类转换异常
2. 提升代码可读性 编码阶段即可知道对象类型
3. 提升了代码的复用率

## 泛型类

```java
class Map<K>{
    // 修饰成员变量
    private K key;

    // 修饰参数
    public Map(K key){}

    // 修饰返回值
    public K get(){
        // 修饰局部变量
        K key1 = key;
        return key1;
    }
}
```

## 泛型方法

```java
// <T> 声明的是这个方法的泛型参数 后面的T声明的是方法的返回类型
public static <T> T run(T obj){
    return obj;
}
```

## 泛型限定

```java
// 约定T必须是Comparable的子类
<T extends Comparable> 
// 可同时指定多个父接口
<T extends Comparable&Serializable> 
```

## 通配符

```java
// 只能接受S的自身或子类
<? extends S>
// 能接收S自身及其超类
<? super S>
// 不限制类型，只能使用object接收
<?>
```

## PESC原则

- 上界<? extends T>不能往里存，只能往外取，适合频繁往外面读取内容的场景。
- 下界<? super T>不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景

## 泛型擦除

- 虚拟机中没有泛型，只有普通类和方法
- 在编译阶段，泛型参数被擦除为限定类型，并进行相关类型转换
- 虚拟机也会合成桥方法来保持方法多态

补救：

如果想要在运行时获取泛型的类型 那就必须通过某种手段记录泛型的 Class 对象

## 类型变化关系

![批注 2019-10-30 131946](/assets/批注%202019-10-30%20131946.png)
