{"name":"泛型","id":"编程语言-JAVA-高级-泛型","content":"# 泛型\n\n- 泛型类\n- 泛型接口\n- 泛型方法\n\n关于泛型的几点：\n\n1. 尖括号里的每个元素都代表一种未知类型\n2. 尖括号只能出现在类名之后（作用于类的泛型）或者方法返回值之前（方法泛型）\n\n使用泛型的好处：\n\n1. 类型安全 避免粗心导致的类转换异常\n2. 提升代码可读性 编码阶段即可知道对象类型\n3. 提升了代码的复用率\n\n## 泛型类\n\n```java\nclass Map<K>{\n    // 修饰成员变量\n    private K key;\n\n    // 修饰参数\n    public Map(K key){}\n\n    // 修饰返回值\n    public K get(){\n        // 修饰局部变量\n        K key1 = key;\n        return key1;\n    }\n}\n```\n\n## 泛型方法\n\n```java\n// <T> 声明的是这个方法的泛型参数 后面的T声明的是方法的返回类型\npublic static <T> T run(T obj){\n    return obj;\n}\n```\n\n## 泛型限定\n\n```java\n// 约定T必须是Comparable的子类\n<T extends Comparable> \n// 可同时指定多个父接口\n<T extends Comparable&Serializable> \n```\n\n## 通配符\n\n```java\n// 只能接受S的自身或子类\n<? extends S>\n// 能接收S自身及其超类\n<? super S>\n// 不限制类型，只能使用object接收\n<?>\n```\n\n## PESC原则\n\nProducer Extends Consumer Super\n\n上界<? extends T>不能往里存，只能往外取，适合频繁往外面读取内容的场景。\n\n下界<? super T>不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景\n\n- 上界<? extends T> 当只想从集合中获取元素，请把这个集合看成生产者\n\n```java\nList<Apple> apples = new ArrayList<>();\napples.add(new Apple());\nList<? extends Fruit> basket = apples;//按上一个例子，这个是可行的\nfor (Fruit fruit : basket)\n{\n    System.out.println(fruit);\n}\n\n//basket.add(new Apple()); //编译错误\n//basket.add(new Fruit()); //编译错误\n```\n\n- 下界<? super T> 当你仅仅想增加元素到集合，把这个集合看成消费者\n\n```java\nList<Apple> apples = new ArrayList<>();\napples.add(new Apple());\nList<? super Apple> basket = apples;//这里使用了super\n\nbasket.add(new Apple());\nbasket.add(new RedApple());\n//basket.add(new Fruit()); //编译错误\n\nObject object = basket.get(0);//正确\n//Fruit fruit =basket.get(0);//编译错误\n//Apple apple = basket.get(0);//编译错误\n//RedApple redApple = basket.get(0);//编译错误\n```\n\n出现这个原则的原因是因为 `List<Apple>` 跟 `List<Fruit>` 没有任何关系\n\n如Java API中对集合的复制：\n\n```java\npublic static <T> void copy(List<? super T> dest, List<? extends T> src) {\n  ...\n}\n```\n\n## 泛型擦除\n\n- 虚拟机中没有泛型，只有普通类和方法\n- 在编译阶段，泛型参数被擦除为限定类型，并进行相关类型转换\n- 虚拟机也会合成桥方法来保持方法多态\n\n补救：\n\n如果想要在运行时获取泛型的类型 那就必须通过某种手段记录泛型的 Class 对象\n\n## 类型变化关系\n\n- A、B 是类型，$f(\\cdot)$ 表示类型转换，$\\le$ 表示继承关系，如 $A \\le B$，表示 A 继承于 B  \n\n- $f(\\cdot)$ 是 **协变 (covariant)** 的，如果 $A \\le B$，有 $f(A) \\le f(B)$  \n\n- $f(\\cdot)$ 是 **逆变 (contravariant)** 的，如果 $A \\le B$，有 $f(B) \\le f(A)$  \n\n- $f(\\cdot)$ 是 **不变 (invariant)** 的，当上述两种都不成立，即 $f(A)$ 和 $f(B)$ 没有关系  \n\n- $f(\\cdot)$ 是 **双变 (bivariant)** 的，如果 $A \\le B$，有 $f(B) \\le f(A)$ 和 $f(A) \\le f(B)$ 同时成立  \n\n在 Java 中：\n\n- 不变：`List<T>` 默认情况。\n- 协变：? extends T，适合读。\n- 逆变：? super T，适合写。\n","metadata":"","hasMoreCommit":false,"totalCommits":8,"commitList":[{"date":"2025-09-18T11:51:44+08:00","author":"MY","message":"docs(JAVA): 更新类型变化关系说明文档","hash":"d34034b1eb88fb7a81c2d2aa87b994388c7fb12e"},{"date":"2024-11-18T16:40:55+08:00","author":"MY","message":"📦Java 高级","hash":"2b21c6566aa4db8dff3d81003dea531cbe044061"},{"date":"2021-08-13T15:53:02+08:00","author":"cjiping","message":"✏更新 Java 泛型","hash":"3216f07659fcd9b30affce1a7bedfa4f0f359013"},{"date":"2020-09-16T15:21:23+08:00","author":"MY","message":"✏更新 Java 泛型","hash":"3643aace3c2b03a431f09574d1a9c1aa3ac04b5e"},{"date":"2020-08-04T09:10:50+08:00","author":"MY","message":"✏更新 JAVA 泛型","hash":"ded7b410e40601858403063b3af652fe59e3976a"},{"date":"2019-10-30T14:08:43+08:00","author":"MY","message":"更新完JAVA泛型","hash":"7aead163eded19c1e3a30f3242a87c1740a762ab"},{"date":"2019-10-29T22:49:09+08:00","author":"MY","message":"新增泛型-本质","hash":"357018d3c8f831fb48c2402eb18acf1945cb1b2b"},{"date":"2019-10-28T23:06:11+08:00","author":"MY","message":"新增JAVA泛型","hash":"ca393f9048c77476550888b49330418f8eb4ccca"}],"createTime":"2019-10-28T23:06:11+08:00"}