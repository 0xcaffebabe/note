{"name":"继承与多态","id":"编程语言-JAVA-高级-继承与多态","content":"# 继承与多态\n\n## 类的定义\n\n1. 先定义变量\n2. 后定义方法\n     1. 公有方法\n     2. 保护方法\n     3. 私有方法\n     4. getter/setter方法\n\n## 继承\n\n> 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 访问父类中的非私有的属性和行为。\n\n```java\nclass 父类 {\n     ...      \n}\nclass 子类 extends 父类 {\n     ...      \n}\n```\n\n### 继承后的特点\n\n- 成员变量\n- 成员方法\n- 构造方法\n\n### super与this\n\n- super ：代表父类的存储空间标识(可以理解为父亲的引用)。 \n- this ：代表当前对象的引用(谁调用就代表谁)。 \n\n子类默认的空构造方法默认调用super(), 也就是父类的默认构造函数, 如果父类没有无参构造函数, 则编译会出错. 这个时候需要手动调用父类的构造函数()\n\n```java\nclass Father{\n    public Father(int i) {}\n}\nclass Son extends Father{\n    public Son(){ super(1); }\n}\n```\n\n如果用this()或者super() 调用构造器, 则必须在构造函数内的第一行调用(必须保证父类在子类之前初始化)\n\n### 特点\n\n- 单继承\n- 多层继承\n\n## 抽象类\n\n- 抽象方法 ： 没有方法体的方法。 \n- 抽象类：包含抽象方法的类。 \n\n```java\npublic abstract class Animal {\n         public abstract void run()； \n}\n```\n\n## 接口\n\n>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么 接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法 （JDK 9）\n\n```java\npublic interface 接口名称 {\n         // 抽象方法\n         // 默认方法\n         // 静态方法\n         // 私有方法 \n     \n}\n\nclass 类名 implements 接口名 {\n         // 重写接口中抽象方法【必须\n         // 重写接口中默认方法【可选】    \n     \n} \n```\n\n### 默认方法\n\n```java\npublic interface LiveAble {\n         public default void fly(){\n                  System.out.println(\"天上飞\");     \n          } \n}\n```\n\n### 静态方法\n\n```java\npublic interface LiveAble {\n         public static void run(){\n                  System.out.println(\"跑起来~~~\");     \n          } \n}\n```\n\n### 私有方法\n\n- 私有方法：只有默认方法可以调用。 \n- 私有静态方法：默认方法和静态方法可以调用。\n\n### 多实现\n\n```java\nclass 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {\n         // 重写接口中抽象方法【必须】\n         // 重写接口中默认方法【不重名时可选】    \n} \n```\n\n- 如果默认方法有重名的，必须重写一次。\n\n## 抽象类与接口\n\n抽象类是is-a关系, 是模板式设计 接口是 can-do关系, 是契约式设计\n\n优先定义接口, 避免直接使用继承\n\n## 多态\n\n```java\n父类类型 变量名 = new 子类对象； \n变量名.方法名();\n```\n\n## 多态的好处\n\n## final关键字\n\n- 修饰类 表明该类是无法继承的\n- 修饰方法 表明该方法是无法覆写的\n- 修饰局部变量 说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址\n- 修饰成员变量 同上\n\n## 访问权限控制\n\n访问权限控制符|任何地方|包外子类|包内|类内\n---|---|---|---|---\npublic|√|√|√|√\nprotected|×|√|√|√\ndefault|×|×|√|√\nprivate|×|×|×|√\n\n- 不允许从外部创建对象时 使用private修饰构造方法\n- 工具类不允许有public 或 default 构造器\n- 成员变量非static 需要与子类共享 必须为protected\n- 成员变量非static 仅在内部使用 使用private\n- static成员变量 仅在内部使用 使用 private\n- 定义static成员变量时 考虑加final修饰\n- 成员方法 仅在内部使用 使用private\n- 成员方法仅对继承类公开 使用 protected\n\n","metadata":"","hasMoreCommit":false,"totalCommits":8,"commitList":[{"date":"2024-11-18T15:00:13+08:00","author":"MY","message":"📦Java 基础","hash":"270332d69c4b80cb8600b368ecda389c7c95b038"},{"date":"2022-06-22T16:40:38+08:00","author":"cjiping","message":"📦整理 Java","hash":"dd8a407d9e17e954526376861d539512ad700daa"},{"date":"2020-09-15T10:50:40+08:00","author":"MY","message":"✏更新 Java super与this","hash":"f5615de8675032bdc93469b667ad3951d19b2b54"},{"date":"2020-09-15T10:35:36+08:00","author":"MY","message":"✏更新 Java 访问权限控制","hash":"522c7d6fc524d0eff94c87e85e17c7a988475dad"},{"date":"2020-09-15T10:22:20+08:00","author":"MY","message":"✏更新 Java 继承与多态","hash":"6c32c24943d6adeed2dd8781c903d234491139b1"},{"date":"2020-08-04T08:28:11+08:00","author":"MY","message":"✏更新 JAVA 继承与多态","hash":"6a44cd5cee478f2df737582a7b4fcd5f8ae6451a"},{"date":"2019-08-02T11:59:43+08:00","author":"My、","message":"20190802上午","hash":"7557fcbba6d18f4ba23fac592ef519092183fd3c"},{"date":"2019-08-01T17:04:39+08:00","author":"My、","message":"20190801下午","hash":"8ecb58cdc85b79ac405610f62f88d7804e54a808"}],"createTime":"2019-08-01T17:04:39+08:00"}