# BIO

## Socket

- public InputStream getInputStream() ： 返回此套接字的输入流。
- public OutputStream getOutputStream() ： 返回此套接字的输出流。
- public void close() ：关闭此套接字。
- public void shutdownOutput() ： 禁用此套接字的输出流。

## ServerSocket

- public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信

# NIO

## 与BIO的区别

- IO是面向流的，NIO是面向缓冲区的；
- IO流是阻塞的，NIO流是不阻塞的;
- NIO有选择器，而IO没有。

## 核心类

- Buffer
  - byte容器
  - position limit capacity
- Channel

### 文件输出例子

```java
FileOutputStream fos = new FileOutputStream("file.txt");
FileChannel channel = fos.getChannel();
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put("20191204".getBytes());
// 翻转缓冲区
buffer.flip();
channel.write(buffer);
fos.close();
```

### 文件输入

```java
File file = new File("file.txt");
FileInputStream fis = new FileInputStream(file);
ByteBuffer buffer = ByteBuffer.allocate((int) file.length());
FileChannel channel = fis.getChannel();
channel.read(buffer);
System.out.println(new String(buffer.array()));
fis.close();
```

### 文件复制

```java
FileInputStream fis = new FileInputStream("file.txt");
FileOutputStream fos = new FileOutputStream("file1.txt");
FileChannel source = fis.getChannel();
FileChannel target = fos.getChannel();
target.transferFrom(source,0,source.size());
source.close();
target.close();
```

## 网络编程

- Selector

它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接

![](https://pic3.zhimg.com/80/v2-5458e9182d8e2e002d82327273561172_hd.jpg)

- SelectionKey

一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系

- ServerSocketChannel

Java NIO 中的 ServerSocketChannel 是一个可以监听新进来的 TCP 连接的通道, 就像标准 IO 中的 ServerSocket一样

- SocketChannel

Java NIO 中的 SocketChannel 是一个连接到 TCP 网络套接字的通道

### 客户端

```java
        // 得到一个网络通道
        SocketChannel channel = SocketChannel.open();
        // 设置非阻塞方式
        channel.configureBlocking(false);
        // 提供服务器IP与端口
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 1999);
        // 连接
        if (!channel.connect(address)) {
            while (!channel.finishConnect()) {
                System.out.println("客户端：正在连接服务器");
            }
        }

        // 发送数据
        ByteBuffer buffer = ByteBuffer.wrap("cxk 打篮球".getBytes());
        channel.write(buffer);
```

### 服务端框架

```java
        // 获取网络通道
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 获取选择器
        Selector selector = Selector.open();
        // 绑定端口
        serverSocketChannel.bind(new InetSocketAddress(1999));
        // 设置为非阻塞方式
        serverSocketChannel.configureBlocking(false);
        // 注册选择器，让选择器监听连接事件
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        while (true) {
            // 每2000ms轮询一次，select返回的结果是客户数
            if (selector.select(2000) == 0){
                System.out.println("等待客户连接");
                continue;
            }
            // 获取准备连接的所有客户
            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()){
                SelectionKey key = iterator.next();
                if (key.isAcceptable()){
                    // 客户端连接事件
                    System.out.println("客户端连接");
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));
                }
                if (key.isReadable()){
                    // 读取客户端数据事件
                    SocketChannel channel = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    channel.read(buffer);
                    System.out.println("客户端发来数据:"+new String(buffer.array()));
                }

                // 删除客户key，防止重复处理
                iterator.remove();
            }
        }
```



