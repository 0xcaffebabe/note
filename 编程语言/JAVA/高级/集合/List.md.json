{"name":"List","id":"编程语言-JAVA-高级-集合-List","content":"# List\n\n## ArrayList\n\nArrayList的subList方法会返回一个list视图，对这个SubList的修改都会映射到原来的list\n\n而Arrays.asList返回的arrays包下的ArrayList，这个类并没有重写add,remove等方法，所以修改时会抛出异常\n\n### 结构\n\n![202002191425](/assets/202002191425.jfif)\n\n- DEFAULT_CAPACITY 表示数组的初始大小，默认是 10\n- size 表示当前数组的大小\n- modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1\n\n### 解析\n\n- 初始化\n\n一共有三种方式可以初始化ArrayList\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // 直接将传入的集合转成数组复制给内部数组\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        this.elementData = {};\n    }\n}\n\npublic ArrayList() {\n    this.elementData = {};\n}\n\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = {};\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n```\n\n- 新增与扩容\n\n添加元素时：\n\n- 判断是否需要扩展，如果需要则只需扩容\n- 添加\n\n```java\n// 这个版本是基于JDK13的\nprivate void add(E e, Object[] elementData, int s) {\n    // 当发现现在list的size跟数组容量一样大时，则进行扩容\n    if (s == elementData.length)\n        // 这里扩容完，会产生一个新数组，我们要将新数组保存\n        elementData = grow(size+1);\n    //添加index:size\n    elementData[s] = e;\n    size = s + 1;\n}\n// 扩容核心代码\nprivate Object[] grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    // 只有数组不为空时，才进行扩容，否则直接创建\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // 计算数组的新容量\n        int newCapacity = ArraysSupport.newLength(oldCapacity,\n                minCapacity - oldCapacity, /* minimum growth */\n                oldCapacity >> 1           /* preferred growth */);\n        // 复制老数组到新数组\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\n// 计算容量的方法\npublic static int newLength(int oldLength, int minGrowth, int prefGrowth) {\n    // 判断list的size与elementData的差值如果大于elementData长度的一半\n    // 新数组长度就等于老数组长度加上list的size与elementData的差值\n    // 否则新数组的长度就等于老数组的1.5倍\n    int newLength = Math.max(minGrowth, prefGrowth) + oldLength;\n    if (newLength - MAX_ARRAY_LENGTH <= 0) { // 数组长度不能大于整数最大值\n        return newLength;\n    }\n    return hugeLength(oldLength, minGrowth);\n}\n```\n\n所以扩容的本质就是申请一个更大的数组，将旧数组的内容移过去\n\n**源码扩容过程值得借鉴的地方**\n\n- 通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好\n- 1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快\n- 扩容过程中，注意数组大小溢出的情况\n\n\n- 删除\n\n无论是根据Object删除还是index删除，都必须给出被删除元素的index\n\n```java\nprivate void fastRemove(Object[] es, int i) {\n    modCount++;\n    final int newSize;\n    if ((newSize = size - 1) > i)\n        // 将elementData 下标为i后面的全部元素往前移动一个位\n        System.arraycopy(es, i + 1, es, i, newSize - i);\n    // 如果删除的是最后一个元素，置为null就行\n    es[size = newSize] = null; // 同时记得size-1\n}\n```\n\n![202002191507](/assets/202002191507.jfif)\n\n### 迭代器\n\n- hasNext\n\n```java\npublic boolean hasNext() {\n    return cursor != size;\n}\n```\n\n- next\n\n```java\npublic E next() {\n    // 有点乐观锁的意思，通过版本号来确定持有的数据是否被修改了\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    // 否则每次根据游标获取元素，获取完游标+1\n    int i = cursor;\n    if (i >= size)\n        throw new NoSuchElementException();\n    Object[] elementData = ArrayList.this.elementData;\n    if (i >= elementData.length)\n        throw new ConcurrentModificationException();\n    cursor = i + 1;\n    return (E) elementData[lastRet = i];\n}\n```\n\n- remove\n\n```java\npublic void remove() {\n    if (lastRet < 0)\n        throw new IllegalStateException();\n   if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    // 将当前游标作为下标，删除这个位置的元素\n    try {\n        ArrayList.this.remove(lastRet);\n        // 删除完之后要更新版本号\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n    } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n    }\n}\n```\n\n### 线程安全\n\nArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁\n\n---\n\n问：对 ArrayList 的理解？\n\n答：底层数据结构、对数组的封装、add、remove\n\n问：为什么说扩容会消耗性能\n\n答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重\n\n\n## LinkedList\n\n### 架构\n\nLinkedList 底层数据结构是一个双向链表\n\n![202002191526](/assets/202002191526.jfif)\n\n### 解析\n\n- node的结构\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    \n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n- 尾部追加节点\n\n```java\nvoid linkLast(E e) {\n    final Node<E> l = this.last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    this.last = newNode;\n    // 如果尾节点为空，则代表当前链表是空的，直接把插入节点作为头节点\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode; // 否则就将插入节点设置为尾节点，并且把旧尾节点的next指向插入节点\n    size++;\n    modCount++;\n}\n```\n\n- 头部追加节点\n\n```java\nprivate void linkFirst(E e) {\n    final Node<E> f = this.first;\n    final Node<E> newNode = new Node<>(null, e, f);\n    this.first = newNode;\n    // 如果头节点为空，则代表当前链表是空的，直接把插入节点作为尾节点\n    if (f == null)\n        last = newNode;\n    else\n        f.prev = newNode; // 否则就将插入节点设置为头节点，并且把旧头节点的prev指向插入节点\n    size++;\n    modCount++;\n}\n```\n\n- 删除节点\n\n```java\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n    // 当前删除的是头节点，所以将删除节点的next变为头节点\n    if (prev == null) {\n        first = next;\n    } else {\n        // 否则设置删除节点的上一个节点的next指向删除节点的next\n        prev.next = next;\n        x.prev = null;\n    }\n    // 当前删除的是尾节点，所以将删除节点的prev变为尾节点\n    if (next == null) {\n        last = prev;\n    } else {\n        // 否则设置删除节点的下一个节点的prev指向删除节点的prev\n        next.prev = prev;\n        x.next = null;\n    }\n    \n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n- 根据下标查询节点\n\n```java\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n    if (index < (size >> 1)) { // 在前半部分，所以从头节点迭代查找\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else { // 在后半部分，所以尾头节点迭代查找\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n### 迭代器\n\n```java\n// 双向迭代器\nprivate class ListItr implements ListIterator<E> {\n    private Node<E> lastReturned;//上一次执行 next() 或者 previos() 方法时的节点位置\n    private Node<E> next;//下一个节点\n    private int nextIndex;//下一个节点的位置\n    …………\n}\n```\n\n- 从头到尾迭代\n\n```java\npublic boolean hasNext() {\n    return nextIndex < size;\n}\n    \npublic E next() {\n    checkForComodification();\n    if (!hasNext())\n        throw new NoSuchElementException();\n\n    lastReturned = next;\n    next = next.next; // next指向当前遍历元素的next\n    nextIndex++;\n    return lastReturned.item;\n}\n```\n\n- 从尾到头迭代\n\n```java\npublic boolean hasPrevious() {\n    return nextIndex > 0;\n}\n\npublic E previous() {\n    checkForComodification();\n    if (!hasPrevious())\n        throw new NoSuchElementException();\n    // 主要是判断next为空的情况下要选择last作为遍历节点，否则选择遍历元素的prev\n    lastReturned = next = (next == null) ? last : next.prev;\n    nextIndex--;\n    return lastReturned.item;\n}\n```\n\n- 删除\n\n```java\npublic void remove() {\n    checkForComodification();\n    // lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：\n    // lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错\n    // lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值\n    if (lastReturned == null)\n        throw new IllegalStateException();\n    Node<E> lastNext = lastReturned.next;\n    //删除当前节点\n    unlink(lastReturned);\n    // next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下\n    // 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等\n    if (next == lastReturned)\n        // 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next\n        next = lastNext;\n    else\n        nextIndex--;\n    lastReturned = null;\n    expectedModCount++;\n}\n```\n\n---\n\n问：ArrayList 和 LinkedList 有何不同\n\n答：底层数据结构，数组结构导致的读写差异\n\n问： ArrayList 和 LinkedList 应用场景\n\n答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景\n\n问：ArrayList 和 LinkedList 两者有没有最大容量\n\n答：两个都有最大容量，是int的最大值，原因是ArrayList使用的数组容量不能超过int最大值，LinkedList则是因为size使用int表示的，所以也不能超过int的最大值\n\n问：ArrayList 和 LinkedList 是如何对 null 值进行处理的\n\n答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的\n\n问：ArrayList 和 LinedList 是线程安全的么，为什么\n\n答：都非线程安全，主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况\n\n","metadata":"","hasMoreCommit":false,"totalCommits":5,"commitList":[{"date":"2024-11-18T15:00:13+08:00","author":"MY","message":"📦Java 基础","hash":"270332d69c4b80cb8600b368ecda389c7c95b038"},{"date":"2022-06-09T21:51:44+08:00","author":"MY","message":"📦整理 Java","hash":"34c01b44e7566fa54773149765e3dd8420235279"},{"date":"2021-09-09T15:45:23+08:00","author":"cjiping","message":"📦整理 Java 集合","hash":"252c795143c74614225c05db16d40cdaded2b684"},{"date":"2020-02-20T15:33:45+08:00","author":"MY","message":"JAVA源码解析 增加三个Map","hash":"7d185d655cf7b31f003f92071d3f172fad4f2a9d"},{"date":"2020-02-19T16:25:46+08:00","author":"MY","message":"JAVA源码解析 两个list","hash":"818222e6c60aed7eac4ecbc48fca743d6bde06a3"}],"createTime":"2020-02-19T16:25:46+08:00"}