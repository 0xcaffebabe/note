{"name":"Map","id":"编程语言-JAVA-高级-集合-Map","content":"# Map\n\n```mermaid\nclassDiagram\n    Map <.. HashTable: 实现\n    Dictionary <-- HashTable: 继承\n    HashTable <-- Properties: 继承\n    Map <.. EnumMap: 实现\n    AbstractMap <-- EnumMap: 继承\n    AbstractMap <-- HashMap: 继承\n    AbstractMap <-- TreeMap: 继承\n    HashMap <-- LinkedHashMap: 继承\n    Map <.. HashMap: 实现\n    Map <.. AbstractMap: 实现\n    Map <.. SortedMap: 实现\n    SortedMap <.. NavigableMap: 实现\n    NavigableMap <.. TreeMap: 实现\n```\n\n## HashMap\n\n- 允许 null 值，不同于 HashTable ，是线程不安全的\n- load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值\n- 如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能\n- 在迭代过程中，如果 HashMap 的结构被修改，会快速失败\n\n### 架构\n\n![202002201344](/assets/202002201344.jfif)\n\n### 操作\n\n- 新增\n\n![202002201350](/assets/202002201350.jpg)\n\n1.空数组有无初始化，没有的话初始化；\n2.如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；\n3.如果 hash 冲突，两种解决方案：链表 or 红黑树；\n4.如果是链表，递归循环，把新元素追加到队尾；\n5.如果是红黑树，调用红黑树新增的方法；\n6.通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；\n7.判断是否需要扩容，需要扩容进行扩容，结束。\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 如果数组为空，那就初始化数组\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 如果根据hashCode得到的索引位置为空，直接将新节点放到该节点\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 如果现在索引位置的hash值与key都相等，直接将新节点放在这里\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 否则就需要追加节点到当前索引位置节点的后面（链表或者红黑树）\n        // 如果是红黑树，那就调用红黑树的增加方法\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 否则就是链表，进行遍历\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 当遍历的节点hash值与key都相等时，那新节点就是放在这里\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // 这里的e如果不为null，那就代表插入的这个key中是有值得，根据传入的onlyIfAbsent决定是否覆盖\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    // 维护HashMap的其他状态信息\n    ++modCount;\n    if (++size > threshold)\n        // size达到一定的程度，就需要扩容\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n**链表转为红黑树**\n\n只有当链表长度大于等于8，并且整个数组长度大于等于64时，才会进行链表转红黑树\n\n至于为什么是8，链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，8是最合适的\n\n在元素放置过程中，恶意构造哈希冲突的数据是有可能的，针对于JDK8之前使用链表来存储相同哈希的数据可以进行哈希碰撞拒绝服务攻击，消耗服务端的CPU\n\n**红黑树的插入**\n\n```java\nfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n                               int h, K k, V v) {\n    Class<?> kc = null;\n    boolean searched = false;\n    // 找到根节点\n    TreeNode<K,V> root = (parent != null) ? root() : this;\n    // 遍历\n    for (TreeNode<K,V> p = root;;) {\n        int dir, ph; K pk;\n        // 说明应该插在当前遍历节点的右子树\n        if ((ph = p.hash) > h)\n            dir = -1;\n        // 说明应该插在当前遍历节点的左子树\n        else if (ph < h)\n            dir = 1;\n        // 找到跟插入节点相等的节点，返回\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        // 实现了Comparable，通过compareTo比较\n        else if ((kc == null &&\n                  (kc = comparableClassFor(k)) == null) ||\n                 (dir = compareComparables(kc, k, pk)) == 0) {\n            if (!searched) {\n                TreeNode<K,V> q, ch;\n                searched = true;\n                if (((ch = p.left) != null &&\n                     (q = ch.find(h, k, kc)) != null) ||\n                    ((ch = p.right) != null &&\n                     (q = ch.find(h, k, kc)) != null))\n                    return q;\n            }\n            dir = tieBreakOrder(k, pk);\n        }\n\n        // 插入新节点\n        TreeNode<K,V> xp = p;\n        if ((p = (dir <= 0) ? p.left : p.right) == null) {\n            Node<K,V> xpn = xp.next;\n            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n            if (dir <= 0)\n                xp.left = x;\n            else\n                xp.right = x;\n            xp.next = x;\n            x.parent = x.prev = xp;\n            if (xpn != null)\n                ((TreeNode<K,V>)xpn).prev = x;\n            moveRootToFront(tab, balanceInsertion(root, x));\n            return null;\n        }\n    }\n}\n```\n\n着色是指红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：\n\n1. 节点是红色或黑色\n2. 根是黑色\n3. 所有叶子都是黑色\n4. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点\n5. 从每个叶子到根的所有路径上不能有两个连续的红色节点\n\n- 查找\n\n```\n1.根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。\n2.判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。\n3.分别走链表和红黑树不同类型的查找方法\n```\n\n链表查找\n\n```java\ndo {\n    // 遍历，看遍历的节点的key是否与查找的key相等\n    if (e.hash == hash &&\n        ((k = e.key) == key || (key != null && key.equals(k))))\n        return e;\n} while ((e = e.next) != null);\n```\n\n红黑树查找\n\n```java\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n    TreeNode<K,V> p = this;\n    do {\n        int ph, dir; K pk;\n        TreeNode<K,V> pl = p.left, pr = p.right, q;\n        // hash比当前节点小，往左子树寻找\n        if ((ph = p.hash) > h)\n            p = pl;\n        // hash比当前节点大，往左右树寻找\n        else if (ph < h)\n            p = pr;\n        // 找到了\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        // 左子树为空，所以只能向右子树找\n        else if (pl == null)\n            p = pr;\n        // 右子树为空，所以只能左右子树找\n        else if (pr == null)\n            p = pl;\n        // 使用compareTo比较\n        else if ((kc != null ||\n                  (kc = comparableClassFor(k)) != null) &&\n                 (dir = compareComparables(kc, k, pk)) != 0)\n            p = (dir < 0) ? pl : pr;\n        else if ((q = pr.find(h, k, kc)) != null)\n            return q;\n        else\n            p = pl;\n    } while (p != null);\n    return null;\n}\n```\n\n## TreeMap\n\nTreeMap 底层的数据结构就是红黑树，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系\n\n- 新增\n\n```java\npublic V put(K key, V value) {\n    Entry<K,V> t = root;\n    // 根节点为空，直接将插入节点作为根节点\n    if (t == null) {\n        compare(key, key); // type (and possibly null) check\n        root = new Entry<>(key, value, null);\n        size = 1;\n        modCount++;\n        return null;\n    }\n    int cmp;\n    Entry<K,V> parent;\n    // split comparator and comparable paths\n    Comparator<? super K> cpr = comparator;\n    if (cpr != null) {\n        // 遍历找到插入节点应该插入的位置，parent保存了该位置的父节点\n        do {\n            parent = t;\n            cmp = cpr.compare(key, t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    else {\n        // 实现了Comparable的情况下的比较\n        if (key == null)\n            throw new NullPointerException();\n        @SuppressWarnings(\"unchecked\")\n            Comparable<? super K> k = (Comparable<? super K>) key;\n        do {\n            parent = t;\n            cmp = k.compareTo(t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    Entry<K,V> e = new Entry<>(key, value, parent);\n    if (cmp < 0)\n        parent.left = e;\n    else\n        parent.right = e;\n    fixAfterInsertion(e);\n    size++;\n    modCount++;\n    return null;\n}\n```\n\n## LinkedHashMap\n\nLinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：\n\n- 按照插入顺序进行访问；\n- 实现了访问最少最先删除功能\n\n**按照插入顺序新增**\n\n```java\n// 通过在创建新节点时，把这个节点加到一个链表的最尾部来维护插入顺序\nNode<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n    LinkedHashMap.Entry<K,V> p =\n        new LinkedHashMap.Entry<>(hash, key, value, e);\n    linkNodeLast(p);\n    return p;\n}\nprivate void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n    LinkedHashMap.Entry<K,V> last = tail;\n    tail = p;\n    if (last == null)\n        head = p;\n    else {\n        p.before = last;\n        last.after = p;\n    }\n}\n```\n\n**按照插入顺序访问**\n\n```java\n// 跟链表的迭代器一样\nfinal LinkedHashMap.Entry<K,V> nextNode() {\n    LinkedHashMap.Entry<K,V> e = next;\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    if (e == null)\n        throw new NoSuchElementException();\n    current = e;\n    next = e.after;\n    return e;\n}\n```\n\n**最少访问删除的实现**\n\n在get之后，LinkedHashMap会对获取到的节点执行移到链表尾部的操作\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    if ((e = getNode(hash(key), key)) == null)\n        return null;\n    if (accessOrder)\n        afterNodeAccess(e);\n    return e.value;\n}\n```\n\n```java\n// 这段代码是负责把e移到末尾\n// 这样就队头的元素就是访问最少的元素\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n## 问题\n\n### HashMap 底层数据结构\n\n底层采用了数组、链表、红黑树来实现的\n\n数组的主要作用是查找，时间复杂度为O(1)，默认大小16，元素存放的下标是根据key的hashCode计算出来的\n\n元素存放在Node里面，当key的hashCode一样时，但是key并不相等，Node就会串起来，形成链表，链表的时间复杂度是O(N)\n\n当链表长度大于等于8且数组长度大于等于64时，链表就会转成红黑树，红黑树的时间复杂度为O(lg n)\n\n### HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点\n\n相同点：\n\n- 都使用了红黑树\n- hash算法相同\n- 都非线程安全\n\n不同点：\n\n- HashMap数据结构以数组为主，查询速度快，TreeMap利用了红黑树左小右大的特点，可以实现对key的排序，LinkedHashMap则增加了链表的结构，实现了顺序访问以及最少访问删除\n\n### hash算法\n\n```java\nn=array.length;\ntab[i = (n - 1) & hash]\n```\n\n取模算法的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上\n\n当 b 是 2 的幂次方时，a % b = a &（b-1）\n\n### 解决hash冲突的办法\n\n- 好的hash算法\n- 自动扩容\n- 冲突后使用链表与红黑树\n\n### HashMap 是如何扩容的\n\n- put时，发现数组为空，初始化扩容，默认大小16\n- put成功后，发现数组大于现在数组的容量*0.75，会进行扩容，每次扩容为原来数组大小的两倍\n- 扩容之后，需要对数组中的Node节点重新计算hash值，重新放置\n\n### 对象作为 Map 的 key 时，需要注意的点\n\n一定需要覆写 equals 和 hashCode 方法，如果是 TreeMap 的话，需要实现 Comparable 接口\n","metadata":"","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2024-11-18T15:00:13+08:00","author":"MY","message":"📦Java 基础","hash":"270332d69c4b80cb8600b368ecda389c7c95b038"},{"date":"2022-10-17T20:48:10+08:00","author":"MY","message":"✏️Map","hash":"e50b5c3f8d2492452074933ad046696c785f3fdd"},{"date":"2021-09-09T15:45:23+08:00","author":"cjiping","message":"📦整理 Java 集合","hash":"252c795143c74614225c05db16d40cdaded2b684"},{"date":"2020-08-05T09:59:24+08:00","author":"MY","message":"✏更新 源码解析 Map","hash":"07a3dd3ade9aa09083f9c30ec8d22517291b38c8"},{"date":"2020-02-20T16:04:55+08:00","author":"MY","message":"JAVA源码解析 增加两个Set","hash":"52e1955cc0d1a9daaaf6719e6dcbff6f518d7461"},{"date":"2020-02-20T15:33:45+08:00","author":"MY","message":"JAVA源码解析 增加三个Map","hash":"7d185d655cf7b31f003f92071d3f172fad4f2a9d"},{"date":"2020-02-19T16:25:46+08:00","author":"MY","message":"JAVA源码解析 两个list","hash":"818222e6c60aed7eac4ecbc48fca743d6bde06a3"}],"createTime":"2020-02-19T16:25:46+08:00"}