{"name":"集合","id":"编程语言-JAVA-高级-集合-集合","content":"# 集合\n\n> 集合是java中提供的一种容器，可以用来存储多个数据\n\n## 类层次结构\n\n```mermaid\nmindmap\n    root((容器))\n        Collection\n            List[List]\n                CopyOnWriteList\n                ArrayList\n                Vector\n                    Stack\n                LinkedList\n            Set(Set)\n                HashSet\n                    LinkedHashSet\n                SortedSet\n                    TreeSet\n                CopyOnWriteArraySet\n                ConcurrentSkipListSet\n            Queue((Queue))\n                Deque{{Deque}}\n                    ArrayDeque\n                    BlockingDeque\n                        LinkedBlockingDeque\n                BlockingQueue))BlockingQueue((\n                    ArrayBlockingQueue\n                    PriorityBlockingQueue\n                    LinkedBlockingQueue\n                    TransferQueue\n                        LinkedTransferQueue\n                    SynchronousQueue\n                PriorityQueue\n                ConcurrentLinkedQueue\n                DelayQueue\n        Map \n            HashMap\n                LinkedHashMap\n            TreeMap\n            WeakHashMap\n            IdentityHashMap\n\n```\n\n- List 存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\n- Set 不允许重复的集合。不会有多个元素引用相同的对象\n- Queue 被设计用来可以以某种优先级处理元素的集合\n- Map 使用键值对存储。Map会维护与Key有关联的值\n\n可以学习人家的接口是怎么划分的，这个类虽然接口众多，但是职责却很清晰\n\n以及人家是如何复用已有的代码来实现新功能\n\n## Iterator迭代器\n\n```java\nIterator<String> it = coll.iterator();\nwhile(it.hasNext()){ //判断是否有迭代元素\n    String s = it.next();//获取迭代出的元素\n    System.out.println(s);\n}\n```\n\n## List\n\nList 集合的遍历结果是稳定的\n\n- ArrayList\n    - 非线程安全\n    - 内部使用数组\n    - 快速随机访问 插入删除慢\n- LinkedList\n    - 本质双向链表\n    - 插入删除快 随机访问慢\n    - 内存利用率较高\n\n### 常用方法\n\n- public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。 -\n- public E get(int index) :返回集合中指定位置的元素。\n- public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。\n- public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素\n\n## Queue\n\n- FIFO\n- 阻塞队列阻塞的特性与FIFO结合 适合做Buffer\n\n## [Map集合](/编程语言/JAVA/高级/集合/Map.md)\n\n- Collection 接口定义了单列集合规范，每次存储一个元素\n- Map 接口定义了双列集合的规范，每次存储一对元素\n\n### 常用子类\n\nMap集合类            | Key          | Value        | Super       | JDK | 说明\n----------------- | ------------ | ------------ | ----------- | --- | ------------------\nHashtable         | **不允许为null** | **不允许为null** | Dictionary  | 1.0 | 线程安全（过时）\nConcurrentHashMap | **不允许为null** | **不允许为null** | AbstractMap | 1.5 | 锁分段技术或CAS(JDK8及以上)\nTreeMap           | **不允许为null** | 允许为null      | AbstractMap | 1.2 | 线程不安全(有序)\nHashMap           | 允许为null      | 允许为null      | AbstractMap | 1.2 | 线程不安全( resize死链问题)\n\n在任何Map中 都要避免KV设置为null\n\n- HashMap\n\n并发场景下 数据丢失 \n\n死链问题：并发情况下链表修改导致的不一致问题\n\n- ConcurrentHashMap\n\nJDK11后取消了分段锁机制 引入了红黑树结构 put remove size等操作都是用了CAS\n\n- LinkedHashMap \n- TreeMap key有序 基于红黑树实现\n\n并非一定要覆写hashCode与equals 其内部元素时通过Comparable与Comparator来实现key去重排序的\n\n### 常用方法\n\n- public V put(K key, V value) :  把指定的键与指定的值添加到Map集合中。 \n- public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的 值。 \n- public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 \n- public Set<K> keySet() : 获取Map集合中所有的键，存储到Set集合中。 \n- public Set<Map.Entry<K,V>> entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。\n\n## Set集合\n\n- 不允许出现重复\n\n### HashSet\n\n> 底层使用hashmap\n\n![批注 2019-08-02 095407](/assets/批注%202019-08-02%20095407.png)\n\n存储自定义类型元素时，需要重写对象中的hashCode和equals方法\n\n### TreeSet\n\n底层使用TreeMap 保证Key有序\n\n### LinkedHashSet \n\n> 有序的哈希集合\n\n## Collections 工具类\n\n- public static <T> boolean addAll(Collection<T> c, T... elements) :往集合中添加一些元素。 \n- public static void shuffle(List<?> list) 打乱顺序 :打乱集合顺序。 \n- public static <T> void sort(List<T> list) :将集合中元素按照默认规则排序。 \n- public static <T> void sort(List<T> list，Comparator<? super T> ) :将集合中元素按照指定规则排序\n\n## 集合初始化\n\n- ArrayList的初始值为10 每次扩容以1.5倍的速度进行扩容\n- HashMap的初始值为16 每次扩容以2的幂进行扩容\n\n这样如果存放在集合的元素比较多 就会造成不断扩容 影响性能\n\n所以集合初始化时应该指定好默认值\n\n## 数组与集合\n\n```java\nnew int[-1]; // 运行时异常：NegativeArraySizeException：-1\n```\n\n数组遍历优先使用foreach方式\n\n### 数组转集合\n\n注意转集合的过程中是否使用了视图的方式：\n\nArrays.asList(...)这个方法返回了一个不可变的ArrayList（Arrays的内部类）,不能进行修改操作 否则会抛出异常\n\n### 集合转数组\n\n```java\nObject[] objects = list.toArray();// 泛型丢失\n\nString[] arr1 = new String[2];\nlist.toArray(arr1); // arr1为[null,null]\n\nString[] arr2 = new String[3];\nlist.toArray(arr2); // arr2为[1,2,3]\n```\n\n当toArray传入的数组容量比size小时 该方法就会弃用这个数组 而是自己创建一个数组返回\n\n当数组容量等于size时 运行时最快的,空间效率也是最高的\n\n## 集合与泛型\n\n```java\n//第一段:泛型出现之前的集合定义方式\nList al = new ArrayList();\nal.add (new Object());\nal.add (new Integer(111));\nal.add(new String(\"hello alal\"));\n\n//第二段:把a1引用赋值给a2，注意a2与al的区别是增加了泛型限制<object>\nList<Object> a2 = al;\na2.add (new Object());\na2.add (new Integer(222));\na2.add(new String(\"hello a2a2\")）;\n\n//第三段:把a1引用赋值给a3，注意a3与al的区别是增加了泛型<Integer>\nList<Integer> a3 = al;\na3.add(new Integer (333)）;\n下方两行编译出错，不允许增加非Integer类型进入集合\na3.add(new object());\na3.add(new String(\"hello a3a3\"));\n\n//第四段:把a1引用赋值给a4，al与a4的区别是增加了通配符\nList<?>a4 = al;\n//允许副除和清除元素\nal.remove(O);\na4.clear();\n// 编译出错。不允许增加任何元素\na4.add (new Object());\n```\n\n`<? extends T>` put功能受限 ?只能是T及T的子类型\n\n`<? super T>` get 功能受限 ?只能是T及T的父类型\n\n## 元素的比较\n\nComparable和Comparator两个接口的区别：\n- Comparable：自己与别人比较\n- Comparator：第三方比较两个对象\n\n### hashCode 与 equals\n\n通过哈希将数据分散开来\n\n- equals相等 则hashCode必须相等\n- 覆写equals 必须覆写hashCode\n\n```java\n// HashMap 判断两个key是否相等\nif (e.hash == hash &&\n    ((k = e.key) == key || (key != null && key.equals(k))))\n```\n\n## 快速失败机制\n\n当前线程维护一个expectedModCount 遍历之前这个值等于modCount\n\n如果在遍历的过程中发现 expectedModCount != modCount 就代表集合被别的线程修改了 这时候会跑出一个ConcurrentModificationException\n\n这个时候得使用迭代器来实现在遍历中修改集合的功能\n\n并发集合都是使用快速失败机制实现的 集合修改与遍历没有任何关系 但这种机制会导致读取不到最新的数据 也是CAP理论中 A与P的矛盾\n\n## 注意事项\n\n### 线程安全\n\nCollections 帮我们实现了 List、Set、Map 对应的线程安全的方法\n\nsynchronized打头的方法可以将指定的集合包装成线程安全的集合\n\n### 集合性能\n\n- 批量新增\n\n在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增\n\n- 批量删除\n\nArrayList的remove方法，删除之后都会对被删除位置的元素进行移动，如果进行循环remove，会造成性能问题，可以采用removeAll方法，这个批量删除接口只会对数组的元素移动一次\n\n### 集合的坑\n\n- Arrays.asList(array),当array被修改时，会造成list也被修改\n- toArray 方法如果声明的数组小于list长度，会得到一个空数组\n\n## JAVA7到JAVA8集合的升级\n\n- 所有集合都新增了forEach 方法\n- JAVA7中ArrayList无参初始化是直接初始化10，JAVA8无参初始化则是一个空数组\n- JAVA7中的HashMap无参初始化的大小是16，JAVA8无参初始化则是一个空数组，并且引入了红黑树，并且增加了xxIfAbsent等方法\n- Arrays 提供了很多 parallel 开头的方法，这些方法支持并行计算\n\n## Guava\n\n### 工厂模式初始化\n\n```java\nHashMap<Object, Object> map = Maps.newHashMap();\n```\n\n### Lists\n\n```java\nArrayList<String> list = Lists.newArrayList();\nArrayList<Object> objects = Lists.newArrayListWithCapacity(10);\n// 不知道精确值，给出一个模糊值\nArrayList<Object> objects1 = Lists.newArrayListWithExpectedSize(20);\n// 反转一个list，并非物理反转，而是通过对传入index的处理实现的\nvar list = Lists.reverse(list)\n// list拆分\nvar list = Lists.partition(list,3)\n```\n\n### Maps","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2025-09-21T14:03:43+08:00","author":"MY","message":"docs(mindmap): 统一思维导图根节点格式","hash":"44fc90fa0f22040d171dbf83cd6f2fd8c020444a"},{"date":"2024-11-18T15:00:13+08:00","author":"MY","message":"📦Java 基础","hash":"270332d69c4b80cb8600b368ecda389c7c95b038"},{"date":"2023-11-06T20:07:31+08:00","author":"MY","message":"✏集合&面向对象","hash":"1bc147d8eb110fdddea62531487b7c972fd29f15"},{"date":"2022-10-17T20:48:10+08:00","author":"MY","message":"✏️Map","hash":"e50b5c3f8d2492452074933ad046696c785f3fdd"},{"date":"2021-09-09T15:45:23+08:00","author":"cjiping","message":"📦整理 Java 集合","hash":"252c795143c74614225c05db16d40cdaded2b684"},{"date":"2021-01-22T08:52:26+08:00","author":"cjiping","message":"✏更新 Java 集合","hash":"82c6aa0a5091e8f6833701cb2ee88b1aec5b9db2"},{"date":"2021-01-21T19:32:24+08:00","author":"cjiping","message":"✏更新 Java 集合","hash":"8a20e3ea6d53fa525ded369f54bab4c12a095c7c"},{"date":"2020-09-23T13:40:12+08:00","author":"MY","message":"✏更新 Java 集合","hash":"4b1c1b27c91ff0294c6003b710ddd89c53c73abd"},{"date":"2020-09-22T11:35:28+08:00","author":"MY","message":"✏更新 Java 集合","hash":"383571b060d89dc78077b25d9d9076d3f1d9853b"},{"date":"2020-09-21T11:45:12+08:00","author":"MY","message":"✏更新 Java 集合","hash":"9ac74448d075bac9f1e7587ce5317162ae5bc229"}],"createTime":"2019-08-02T11:59:43+08:00"}