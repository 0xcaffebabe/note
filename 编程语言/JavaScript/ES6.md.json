{"name":"ES6","id":"编程语言-JavaScript-ES6","content":"# ES6\n\n## let\n\n所声明的变量，只在let命令所在的代码块内有效\n\n```javascript\n{\n  let a = 10; // 暂时性死区\n  var b = 1;\n}\n\nb = 1 // 1\na = 1 // ReferenceError: a is not defined.\n```\n\n- 不存在变量提升\n\n```javascript\nconsole.log(a); //  Cannot access 'a' before initialization\nlet a = 20;\n```\n\n### 变量提升\n\n引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”\n\n由于一段JS代码需要先经过编译，此时会将一些声明的变量记录在变量环境中，然后再执行，所以会有变量提升这么个玩意，同时也说明了为什么重复定义的变量会覆盖之前定义的变量\n\n带来的问题：\n\n1. 变量容易在不被察觉的情况下被覆盖掉 在函数内定义一个与全局同名的变量\n2. 本应销毁的变量没有被销毁 for循环中的var i\n\n## const\n\n声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n- 具有块级作用域\n\n```javascript\n{\n    const PI = 3;\n}\nconsole.log(PI); // PI is not defined\n```\n\n- 声明时必须赋值\n\n```javascript\nconst PI; // Missing initializer in const declaration\n```\n\n- 不能重新赋值\n\n```javascript\nconst PI = 3.1415;\nPI = 3; // TypeError: Assignment to constant variable.\n```\n\n## var、let、const\n\nvar    | let     | const\n------ | ------- | -------\n函数级作用域 | 块级作用域   | 块级作用域\n变量提升   | 不存在变量提升 | 不存在变量提升\n值可更改   | 值可更改    | 值不可更改\n\n在早期没有let与const之前，使用的立即执行函数表达式来创建一个作用域：\n\n```js\nfor(var i = 0; i < 20; i ++) {\n    void function(i){\n        var div = document.createElement(\"div\");\n        div.innerHTML = i;\n        div.onclick = function(){\n            console.log(i);\n        }\n        document.body.appendChild(div);\n    }(i);\n}\n```\n\n通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量\n\n![2022101217334](/assets/2022101217334.webp)\n\n![变量查找过程](/assets/20221012173333.webp)\n\n## 模板字符串\n\n```javascript\nlet name = \"cxk\"\n// 模板字符串中可以解析变量\nconsole.log(`your name is ${name}`)\n```\n\n```js\nconst fn = ()=>'fn function ';\n// 模板字符串可以调用函数\nlet text = `fn call: ${fn()}`;\n```\n\n```javascript\n// 模板字符串可以换行\nlet info =`123\n456\n789`\n```\n\n## 解构赋值\n\n解构赋值就是把数据结构分解，然后给变量进行赋值\n\n如果解构不成功，变量跟数值个数不匹配的时候，变量的值为undefined\n\n- 数组\n\n```javascript\nlet [a, b, c] = [1, 2, 3];\n// a=1 b=2 c=3\n```\n\n```javascript\nconst color = [1,2]\nconst color2=[...color,3,4]\n// color2 = [1,2,3,4],同样能用于对象\n```\n\n- 对象\n\n```javascript\nlet {name,age} = {name:\"123\",age:15}\n// name = \"123\" age = 15\nlet {name:myName,age:myAge} = {name:\"123\",age:15}\n// myName = \"123\" myAge = 15\n```\n\n## 函数默认值\n\n```javascript\nfunction a(a = 2){\n    console.log(a);\n}\n```\n\n## 剩余参数\n\n```js\nfunction f(...args){\n  console.log(args); // [1,2,3,4]\n}\nf(1,2,3,4);\n```\n\n## 箭头函数\n\n```javascript\n// 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号\nlet sum = (a,b) => a+b;\n// 如果形参只有一个，可以省略小括号\nlet f = res => res.data;\n```\n\n```js\n// 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this\n// 需要注意的是 如果有多层箭头函数 那么最里层的箭头函数this的指向最其外面一层的this\nvar obj = {\n    f: () => {\n        console.log(this); // Window\n    }\n}\nobj.f();\n```\n\n## Array新增方法\n\n### Arrat.from\n\n```js\n//定义一个集合\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n}; \n//转成数组\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n let arrayLike = { \n     \"0\": 1,\n     \"1\": 2,\n     \"length\": 2\n }\n let newAry = Array.from(arrayLike, item => item *2)//[2,4]\n```\n\n### Array实例方法:find\n\n```js\n[1,2,3].find(i=>i/2==1) // 2\n```\n\n### Array实例方法:findIndex\n\n```js\n[1,2,3].findIndex(i=>i/2==1) // 1\n```\n\n### Array实例方法:includes\n\n```js\n[1,2,3].includes(4) // false\n```\n\n## String新增方法\n\n### 实例方法:startsWith,endsWith\n\n```js\n'javascript'.startsWith('java') // true\n'javascript'.endsWith('script') // true\n```\n\n### 实例方法:repeat\n\n```js\n'x'.repeat(3) // xxx\n```\n\n## 数据结构Set\n\nES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值\n\n```js\nconst set = new Set([1,2,3,4,4]) // set = {1,2,3,4}\n```\n\n### 一些方法\n\n```js\nset.add(1); // 添加元素\nset.delete(1) // 删除元素\nset.has(1) // 判断是否有这个元素\nset.clear() // 清空集合\nset.forEach(v => console.log(v))\n```\n\n","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2022-10-12T17:52:09+08:00","author":"cjiping","message":"✏️es6","hash":"6c26f5104c1eac23152307a54fe8389233ce1d36"},{"date":"2022-10-11T17:27:19+08:00","author":"cjiping","message":"✏️ES6","hash":"f56fe9754511e42729f867bfe06f35c04dd5aebb"},{"date":"2022-06-24T16:49:12+08:00","author":"cjiping","message":"✏️更新 JavaScript","hash":"b6acfb9f3d904dd46d667f03e983083d9668ba62"},{"date":"2022-04-12T16:14:28+08:00","author":"MY","message":"✏️更新 ES6","hash":"e8f20c7bb74cb65899159d347c8ff2484f6015dc"},{"date":"2020-03-22T11:39:28+08:00","author":"MY","message":"增加 js模块化","hash":"41df1c1bf2a10bb3f8beb53b840e4ee529f75584"},{"date":"2020-03-05T16:05:10+08:00","author":"MY","message":"增加 node异步编程","hash":"4cdf1f12cbc76a89da93b3dbb48cc28888c8e75e"},{"date":"2020-03-02T09:02:34+08:00","author":"MY","message":"更新ES6","hash":"d32bffaea9de502510477e7525b0a5b1308a706c"},{"date":"2020-02-14T21:53:58+08:00","author":"MY","message":"完成笔记结构重构","hash":"fa76a092bde3bf674471ba101d7e1d1dd2c7108b"},{"date":"2019-11-07T16:49:06+08:00","author":"MY","message":"新增nodejs npm webpack等内容","hash":"e96623b51d30d187e5cbe81585557337659c232d"},{"date":"2019-09-16T09:09:52+08:00","author":"My、","message":"增加了并发编程 线程安全性","hash":"5d91ada50a2be0c26f212b8119db0da5808625d7"}],"createTime":"2019-09-15T17:35:14+08:00"}