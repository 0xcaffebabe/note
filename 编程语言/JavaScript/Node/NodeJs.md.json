{"name":"NodeJs","id":"编程语言-JavaScript-Node-NodeJs","content":"# node\n\n## 组成\n\n- ECMAScript\n- Node模块API\n\n## 运行js文件\n\n```shell\nnode xxx\n```\n\n## 模块化开发\n\nNode.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到\n模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块\n\n### js开发弊端\n\n- 文件依赖\n- 命名冲突\n\n### 模块导出\n\n```js\n// module.js\nexports.add= (a,b) => a+b\n\n// 另外一种导出方式\nmodule.exports.add =  (a,b) => a+b;\n\n// exports是module.exports的别名(地址引用关系)，当它们指向的部署同一个对象时，导出对象最终以module.exports为准\n```\n\n### 模块导入\n\n```js\n// other.js\nlet demo = require('./module');\ndemo.add(1,2);\n```\n\n## 系统模块\n\n### fs\n\n```js\nconst fs = require('fs')\n\n// 读取文件\nfs.readFile('./index.html',(err,doc)=>{\n    if (!err){\n        console.log(doc.toString())\n    }\n})\n// 文件写入\nfs.writeFile('test.txt','run it',error => {\n    console.log(error);\n})\n```\n\n### path\n\n```js\nconst path = require('path')\n\n// 拼接路径\nconsole.log(path.join(__dirname,'TMP','MY')) // windows: C:\\Users\\MY\\TMP\\web\\TMP\\MY\n// 大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录\n```\n\n## 第三方模块\n\n<http://npmjs.com>\n\n```shell\nnpm install xx # 安装模块（本地安装）\nnpm uninstall xx # 卸载模块\nnpm install xx -g # 全局安装\n```\n\n### nodemon\n\n能监控文件的变化，变化时自动运行它\n\n```shell\nnpm install nodemon -g # 安装\nnodemon test # 使用nodemon代替node执行js文件，当js文件发生变更后，会自动重新运行js文件\n```\n\n### nrm\n\nnpm下载地址切换工具\n\n```shell\nnrm ls # 列出可用源\nnrm use xx # 使用某个源\n```\n\n### gulp\n\n```shell\nnpm install gulp\nnpm install gulp-cli -g\n```\n\n```js\n// 执行 gulp first\nconst gulp = require('gulp');\n\ngulp.task('first', () => {\n    return gulp.src('./src/index.html')\n        .pipe(gulp.dest('./dist'))\n})\n```\n\n#### 插件\n\n- 使用\n\n```js\n// 压缩html\nconst htmlmin = require('gulp-htmlmin')\n\ngulp.task('htmlmin', () => {\n    return gulp.src('./src/*.html')\n        .pipe(htmlmin({collapseWhitespace:true}))\n        .pipe(gulp.dest('./dist'))\n})\n```\n\n## 全局对象\n\n- global\n\n## package.json\n\n项目描述文件,记录了当前项目信息，例如项目名称、版本、作者、github地址、 当前项目依赖了哪些第三方模块等。\n\n使用`npm init -y`命令生成。\n\n- dependencies\n- devDependencies\n- package-lock.json\n  - 锁定包的版本\n  - 记录了包以及依赖的下载地址\n\n### script\n\n```json\n\"scripts\": {\n   \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n   \"build\":\"nodemon a.js\"\n }\n```\n\n```shell\nnpm run build\n```\n\n## 模块加载机制\n\n```js\n// 如果模块后缀省略,先找同名JS文件再找同名JS文件夹\n// 如果找到了同名文件夹，找文件夹中的index.js\n// 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项中的入口文件\n// 如果再找不到就抛出异常\nrequire('./xx')\n\n// Node.js会假设它是 系统模块\n// Node.js会去node_ modules文件夹中\n// 首先看是否有该名字的JS文件\n// 再看是否有该名字的文件夹\n// 如果是文件夹看里面是否有index.js\n// 如果没有index.js查看 该文件夹中的package.json中的main选项确定模块入口文件\n// 否则找不到报错\nrequire('xx')\n```\n\n## 异步编程\n\n- 同步api\n  - 会阻塞\n  - 从返回值拿执行结果\n- 异步api\n  - 不会阻塞\n  - 从回调函数拿执行结果\n\n### 代码执行顺序\n\n```js\nconsole.log('代码开始执行');\nsetTimeout(() => {\n    console.log('2秒后执行的代码');\n}, 2000); \nsetTimeout(() => {\n    console.log('\"0秒\"后执行的代码');\n}, 0);\nconsole.log('代码结束执行');\n```\n\n![批注 2020-03-05 145034](/assets/批注%202020-03-05%20145034.png)\n\n### Promise\n\n- 解决异步编程问题\n\nPromise 是一个对象，它代表了一个异步操作的最终完成或者失败\n\n```javascript\nvar promise = new Promise((resolve, reject) => {\n\n    setTimeout(function () {\n        let condition = true;\n        if (condition) {\n            resolve('foo'); // 回调then里的函数\n        } else {\n            reject('error'); // 回调catch里的函数\n        }\n\n    }, 300);\n});\n\npromise\n    .then(value => { console.log(value); })\n    .catch(error => { console.log(error) })\n```\n\n- 解决回调地狱\n\n```js\npromise\n  .then(v=>{\n    // 如果返回Promise，则这个promise是调用下一个then的promise\n    // 如果不是promise，则就是下一个then的回调函数参数v\n    return new Promise()\n  })\n  .then(v=>{\n    return new Promise()\n  })\n```\n\n**all与race**\n\n```js\n// 所有任务都完成才返回结果\nPromise.all([query(),query(),query()]).then(()=>console.log('all mission complete'));\n// 任一任务都完成就返回结果\nPromise.race([query(),query(),query()]).then(()=>console.log('mission complete'));\n```\n\n**错误捕获**\n\nPromise 对象的错误，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止\n\n### 异步函数\n\n```js\n// 使用async修饰，这个函数会返回一个Promise\nconst fn = async () => {};\nasync function fn () {}\n```\n\n```js\nasync function f() {\n    return 11;\n}\nf()\n    .then(v=>console.log(v))\n```\n\n- await\n\nawait关键字只能出现在异步函数中\n\nawait关键字可暂停异步函数向下执行 直到promise返回结果\n\n```js\nasync function f1() {\n    return 11;\n}\nasync function f2(){\n    return 22;\n}\nasync function f(){\n    // 可以通过await关键字将异步函数转同步执行\n    let i1 = await f1();\n    let i2 = await f2();\n    console.log(i1,i2)\n}\nf()\n```\n\n一个被 async 修饰的函数会被包装为一个 Promise，遇到await关键字时，引擎会把该任务提交给微任务队列，然后暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将await的这个对象返回给父协程，父协程拿到这个对象之后，就是调用then方法了\n\n## web服务器\n\n### 创建\n\n```js\nvar http = require('http')\nhttp.createServer((request,response)=>{\n  const body = \"hello world\";\n  response.writeHead(200,{\n  'Content-Length':Buffer.byteLength(body),\n  'Content-Type':'text/plain'\n  });\n  response.end(body);\n}).listen(8888);\n```\n\n### 请求报文\n\n```js\nconst body = `request method:${request.method}\n              request url:${request.url}\n              request headers ua:${request.headers[\"user-agent\"]}\n`\n```\n\n### 响应报文\n\n```js\nresponse.writeHead(200,{\n    'Content-Type':'application/json'\n})\nresponse.end('{\"result\":\"25\"}')\n```\n\n### 请求参数\n\n- get\n\n```js\nconst url = require('url')\n\nlet { query } = url.parse(request.url, true)\n// 输出name参数与age参数\nresponse.end(query.name + \",\" + query.age)\n```\n\n- post\n\n```js\nlet postData = ''\nrequest.on('data',params=>{\n    postData += params\n})\nrequest.on('end',()=>{\n    let i = querystring.parse(postData)\n    response.end(`name: ${i.name} address: ${i.address}`)\n})\n```\n\n### 路由\n\n```js\nlet { pathname } = url.parse(req.url);\nif (pathname == '/' || pathname == '/index') {\n  response.end('欢迎来到首页');\n} else if (pathname == '/list') {\n  response.end('欢迎来到列表页页');\n} else {\n  response.end('抱歉, 您访问的页面出游了');\n}\n```\n\n### 静态资源\n\n```js\nfs.readFile(__dirname+'/static'+pathname,(error,data)=>{\n    if (!error){\n        let type = pathname.substring(pathname.lastIndexOf('.')+1)\n        response.writeHead(200,{\n            \"Content-Type\":mime.getType(pathname)\n        })\n        response.end(data)\n    }else{\n        response.writeHead(404,{\n            \"Content-Type\":\"text/html;charset=utf8\"\n        })\n        response.end('404 NOT FOUND')\n    }\n})\n```\n","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2022-10-17T15:20:19+08:00","author":"cjiping","message":"✏️NodeJS","hash":"f0a1401b7e29595b4e47c6fd25cc74a1465c9e49"},{"date":"2022-10-14T17:34:45+08:00","author":"cjiping","message":"✏️浏览器","hash":"9b7ecfa592b4d6bfd5f2f41e8f184955d04a9471"},{"date":"2022-06-23T17:48:57+08:00","author":"cjiping","message":"✏️更新 JavaScript Node","hash":"a2638e4a8a4062066a84de0561c9a35fab718c7c"},{"date":"2020-03-20T20:15:33+08:00","author":"MY","message":"更新 promise","hash":"ba1f58ff5b277b575ac22af545ff4afe3fa255f4"},{"date":"2020-03-07T14:38:35+08:00","author":"MY","message":"增加 art-template","hash":"ce42ce35e71dff1faa45d86cc20d82c59cdd62c2"},{"date":"2020-03-05T16:05:10+08:00","author":"MY","message":"增加 node异步编程","hash":"4cdf1f12cbc76a89da93b3dbb48cc28888c8e75e"},{"date":"2020-03-05T14:22:24+08:00","author":"MY","message":"更新 node web服务器","hash":"045622e41cc1890fe3284035563c1fbb175d2ae4"},{"date":"2020-03-04T09:51:08+08:00","author":"MY","message":"更新node ...模块加载机制","hash":"943bffe5396719a5efb1af126c6bad127064ac59"},{"date":"2020-03-03T09:27:24+08:00","author":"MY","message":"更新node基础","hash":"d5c023c3ce846925262f99bf0f92be88e3dd60c3"},{"date":"2020-02-14T21:53:58+08:00","author":"MY","message":"完成笔记结构重构","hash":"fa76a092bde3bf674471ba101d7e1d1dd2c7108b"}],"createTime":"2019-11-07T16:49:06+08:00"}