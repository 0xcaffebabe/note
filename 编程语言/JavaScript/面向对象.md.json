{"name":"面向对象","id":"编程语言-JavaScript-面向对象","content":"# 面向对象\n\n## JavaScript的对象模型\n\nJavaScript 对象的运行时是一个“属性的集合”\n\n属性都具备这两个特征：\n\n- enumerable：决定 for in 能否枚举该属性。\n- configurable：决定该属性能否被删除或者改变特征值\n\n### 数据属性\n\n- value：就是属性的值。\n- writable：决定属性能否被赋值。\n\n### 访问器属性\n\n- getter：函数或 undefined，在取属性值时被调用。\n- setter：函数或 undefined，在设置属性值时被调用。\n\n### 创建对象\n\n```js\n// 字面量创建对象\nvar man = {\n    name: 'cxk',\n    play:function(){\n        console.log('jntm')\n    }\n}\n\n// 实例化对象\nvar man = new Man()\nman.play()\n```\n\n## 构造函数\n\n```js\n// 构造函数创建对象\nfunction Man(){\n    this.name = 'cxk';\n    this.play=function(){\n        console.log('jntm')\n    }\n}\n// 实例化对象\nvar man = new Man()\nman.play()\n```\n\n### 成员\n\n- 实例成员\n\n```js\n// 在函数内容通过this访问的是实例成员\nthis.name = 'cxk';\n```\n\n- 静态成员\n\n```js\n// 静态成员只能通过构造函数访问\nMan.people='70亿'\nconsole.log(Man.people)\n```\n\n### 构造函数的问题\n\n![2020227104859](/assets/2020227104859.png)\n\n## 构造函数原型prototype\n\n每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法\n\n```js\nMan.prototype.people='70亿'\nvar man = new Man()\nconsole.log(man.people)\n```\n\n### 对象原型\n\n对象都会有一个属性 `__proto__` 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 `__proto__` 原型的存在\n\n```js\nman.__proto__ == Man.prototype // true\n```\n\n### constructor构造函数\n\n一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数\n\n```js\nMan.prototype = {\n    constructor:Man,\n    play:function(){\n        console.log('真香')\n    }\n}\n```\n\n### 原型链\n\n![202022711154](/assets/202022711154.png)\n\n当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\n如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）\n如果还没有就查找原型对象的原型（Object的原型对象），依此类推一直找到 Object 为止（null）。\n\n### 原型操作\n\nES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型\n\n```js\n// 根据指定的原型创建新对象，原型可以是 nul\nvar tiger = Object.create(cat, { \n    say:{ \n        writable:true, \n        configurable:true, \n        enumerable:true, \n        value:function(){ console.log(\"roar!\"); \n    } }\n})\n```\n\n- Object.getPrototypeOf 获得一个对象的原型；\n- Object.setPrototypeOf 设置一个对象的原型。\n\n### this指向\n\n构造函数中的this和原型对象的this,都指向我们new出来的实例对象\n\n## 继承\n\n### 构造函数继承\n\n```js\nfunction Animal(){\n    this.run = function(){\n        console.log('animal run')\n    }\n}\nfunction Dog(){\n    // 让父构造函数的this指向当前的this\n    Animal.call(this)\n    this.bark = function(){\n        console.log('wolf wolf')\n    }\n}\nvar dog = new Dog();\ndog.run()\ndog.bark()\n```\n\n### 原型继承\n\n```js\nfunction Animal() { }\nAnimal.prototype.run = function () {\n    console.log('animal run')\n}\nfunction Dog() { }\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog;\nDog.prototype.bark = function () {\n    console.log('wolf wolf')\n}\nvar dog = new Dog()\ndog.run()\ndog.bark()\n```\n\n## 类\n\n在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象\n\n### 创建类\n\n```js\n// 创建一个Man类\nclass Man{\n    // 构造器\n    constructor(){\n        this.name = 'cxk'\n    }\n    // 实例方法\n    play(){\n        console.log('jntm')\n    }\n}\n// 实例化\nvar man = new Man()\nman.play()\n```\n\n### 类继承\n\n```js\nclass Animal {\n    constructor(){\n        console.log('animal create')\n    }\n    run(){\n        console.log('animal run')\n    }\n}\nclass Dog extends Animal {\n    // 创建子类前会调用父类的构造器\n    constructor(){\n        // 必须在第一行手动调用\n        super()\n        console.log('dog create')\n    }\n    // 覆写父类的方法\n    run(){\n        // 调用父类的run方法\n        super.run()\n        console.log('dog run')\n    }\n    // 定义新方法\n    bark(){\n        console.log('wolf wolf')\n    }\n}\nvar dog = new Dog()\ndog.run()\ndog.bark()\n```\n\n### 注意事项\n\n-  ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象\n-  注意this的指向问题,类里面的共有的属性和方法一定要加this使用","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2022-06-23T16:34:48+08:00","author":"cjiping","message":"✏️更新 JavaScript 面向对象","hash":"6f3628ea9726dc8e9ab95921322f829397fbe8c8"},{"date":"2020-02-28T14:31:46+08:00","author":"MY","message":"JS增加 函数高级","hash":"d093e9cc968f162655e779e8f48652a5e92e49dd"},{"date":"2020-02-27T12:10:44+08:00","author":"MY","message":"JS 增加ES6之前的面向对象","hash":"48bfe0e044d3aa9484e6868a703a40699078991e"},{"date":"2020-02-26T11:16:37+08:00","author":"MY","message":"JS面向对象","hash":"be403f3f083c1eeedede6ecc3f7fd786db7ebdda"}],"createTime":"2020-02-26T11:16:37+08:00"}