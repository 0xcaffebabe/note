{"name":"Kotlin","id":"编程语言-Kotlin","content":"# Kotlin\n\n## 类型\n\n### 基本类型\n\n```kotlin\n// 基本类型 Byte Short Int Long Double Float\nval a = 1\n// 同swift 不支持隐式转换\n// val b: Double = a\nprintln(a.toDouble())\n// 字面常量 同 Java 但不支持八进制表示\nprintln(100_000)\nprintln(0b10000000)\n\n// 加减乘除取余跟大部分语言是一样的\n// 位运算\nprintln(1 shl 2)\n// 无符号整数 UByte UShort UInt ULong\n// 布尔运算也是跟Java一样\nprintln(true && false)\n// 字符串\nfor(c in \"cxk,jntm\") {\n    println(c)\n}\n// 原始字符串\nval text = \"\"\"\n    <div>\n        <span>abc</span>\n    </div>\n\"\"\".trimIndent()\n// 字符串模板\nprintln(\"$b --- \")\n\n// 数组\nArray(5) {}.forEach { println(it) }\n// 原生类型数组\nintArrayOf(1,2,3,4).forEach { println(it) }\n```\n\n### 类型检测与转换\n\n```kotlin\nprintln(\"cxk\" is String)\nprintln(\"cxk\" !is String) // 等同于 !(\"cxk\" is String)\nvar str: Any = \"cxk\"\nif (str is String) {\n    // 当编译器能保证变量在检测和使用之间不可改变时，智能转换才有效\n    // 在该分支 str自动被转为String\n    println(str.length)\n}\n// 不安全的转换操作\n//println(str as Int)\n// 安全的可用转换操作 转换失败返回null\nprintln(str as? Int)\nval list: List<String> = listOf(\"\")\nif (list is ArrayList) {\n    // `list` 会智能转换为 `ArrayList<String>`\n}\n```\n\n## 控制流\n\n### 条件与循环\n\n```kotlin\n// if是表达式 会返回一个值\nvar a = if (1 >2) 11 else 999\n\n// when语句\n// 除非编译器能够检测出所有的可能情况都已经覆盖了 否则需要else语句\nvar str = \"cxk\"\nval ans = when(\"cxk\") {\n    \"cxk\" -> \"jntm\"\n    // 多种情况\n    \"jg\", \"ngm\" -> \"cxk\"\n    is String -> println(\"str is String\")\n    else -> \"unknow\"\n}\n\n// for循环遍历迭代器\nfor(item in listOf(\"1\", \"2\", \"3\")){}\n// 通过索引遍历数组\nvar arr = arrayOf(\"1\", \"3\",\"3\")\nfor(i in arr.indices) { println(arr[i])}\n// 数字区间迭代\nfor(item in 1..10 step 2){println(item)}\nfor(item in 10 downTo 0 step 2){println(item)}\n\n// while 和 do-while 循环\nvar i = 0\nwhile (i < 10) {i++}\ndo {\n    i--;\n} while( i >= 0)\n```\n\n### 返回与跳转\n\n```kotlin\n// return 默认从最直接包围它的函数或者匿名函数返回\nfun foo() {\n    listOf(1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // 此时这里直接返回到foo的调用者 而非退出这个lambda表达式\n        print(it)\n    }\n    println(\"this point is unreachable\")\n}\nfoo()\nfun foo1() {\n    listOf(1, 2, 3, 4, 5).forEach a@{\n        if (it == 3) return@a// 此时这里就是退出lambda表达式\n        print(it)\n    }\n    println(\"this point is reachable\")\n}\nfoo1()\n\n// 标签\nloop@ for(i in 1..10) {\n    for(j in 1..10) {\n        if (i == 1 && j == 2) break@loop\n    }\n}\n```\n\n### 异常\n\n```kotlin\n// kotlin 只有非受检异常\ntry {\n    if (2 > 1) throw Exception(\"n\")\n}catch (e: Exception) {\n    println(e)\n} finally {\n    println(\"clean\")\n}\n// try是一个表达式 可以有一个返回值 出现异常返回catch代码块里的返回值\nprintln(try {\"cxk\".toInt()}catch (e: NumberFormatException){null})\n```\n\n## 类\n\n```kotlin\n/ 空类\nclass Empty\n\nclass Person(name: String) {\n    var innerName: String = name.uppercase()\n    init {\n        println(\"init code block ${innerName}\")\n    }\n}\n\n// 如果构造器有修饰符或者注解 则需要constructor关键字\nclass Animal protected constructor(){}\n\nclass Pet(owner: String) {\n    // 次构造函数 将工作委托给主构造函数\n    constructor(): this(\"cxk\")\n}\n\n// 使用open代表该类开放继承\nopen class Remote {\n    open val url = \"baidu.com\"\n    open fun execute(){}\n}\n// 抽象类\nabstract class BaseRemote: Remote() {\n    // 覆盖属性\n    // 可以用一个 var 属性覆盖一个 val 属性，但反之则不行\n    override val url = \"google.com\"\n    // 一个抽象成员覆盖一个非抽象的开放成员\n    abstract override fun execute()\n\n    open fun wrapper(){\n        println(\"BaseRemote wrapper\")\n    }\n}\n\ninterface HTTP {\n    fun wrapper(){\n        println(\"HTTP wrapper\")\n    }\n}\n\nclass WarnRemote: BaseRemote(), HTTP{\n    override fun execute() {\n        TODO(\"Not yet implemented\")\n    }\n    override fun wrapper(){\n        // 调用父类的方法\n        super<BaseRemote>.wrapper();\n        // 调用特定接口的方法\n        super<HTTP>.wrapper();\n        println(\"WarnRemote wrapper\")\n    }\n}\n```\n\n### 属性\n\n```kotlin\n// 编译期常量\nconst val PAGE_SIZE = 100\n\nclass Properties {\n    var key: String = \"\"\n    var value: String = \"\"\n\n    // getter setter\n    // 0是幕后属性\n    var counter : Int = 0\n        set(value) {field = value+1}\n        get() {return ++field }\n\n    // 延迟初始化属性\n    lateinit var item: Item\n\n    fun get(): Item? {\n        if (::item.isInitialized) {\n            return item\n        }\n        return null\n    }\n}\n```\n\n### 接口\n\n```kotlin\ninterface Service{\n    // 接口属性\n    val name: String\n        get() = \"service\"\n\n    fun list()\n\n    // 接口默认方法\n    fun defaultList(){\n        println(this.list())\n    }\n}\n// 接口继承\ninterface BaseService: Service{}\n\nclass UserService: Service {\n    override val name: String = \"user-service\"\n    override fun list() {\n        TODO(\"Not yet implemented\")\n    }\n}\n// 函数式接口\nfun interface Consumer {\n    fun accept(i: Int)\n}\nfun main(){\n    Consumer { println(it)}.accept(1)\n}\n```\n\n### 可见性修饰符\n\n- private：包内可见 类成员内可见\n- internal：模块内可见\n- protected：类成员跟子类可见\n- public：范围最大\n\n### 扩展\n\n```kotlin\n// 一个类扩展新功能而无需继承该类或者使用像装饰者这样的设计模式\n// 扩展一个类的函数\nfun MutableList<Int>.print(){\n    for(i in this) {\n        println(i)\n    }\n}\nfun String?.topPinyin(): String {\n    if (this == null) return \"null\"\n    return toString()\n}\n// 扩展属性\nval String.Int: Int\n    get() = this.toInt()\nfun main() {\n    // 调用的具体方法是由函数调用所在的表达式的类型来决定的\n    mutableListOf(1,2,3,4).print()\n\n    var s: String? = null\n    println(s.topPinyin())\n\n    println(\"1\".Int)\n}\n```\n\n### 数据类\n\n```kotlin\n// 会根据构造函数自动生成equals/hashCode/toString/copy\ndata class User(val name: String, val age: Int)\n\nfun main() {\n    val cxk = User(\"cxk\", 18)\n    val olderCxk = cxk.copy(age = 22)\n    println(cxk == olderCxk)\n    // 解构\n    val (name, age) = cxk\n    println(\"${name},${age}\")\n}\n```\n\n### 密封类\n\n```kotlin\n// 密封类的所有直接子类在编译时都是已知的\nsealed class NetworkError: Error()\nclass ConnectRefusedError: NetworkError()\nclass TimeoutError: NetworkError()\n```\n\n### 泛型\n\n```kotlin\n// 使用out T 来确保它仅从 成员中返回（生产），并从不被消费\n// in T 则相反\nclass Wrapper<out T>(val data: T) {\n    fun get(): T {\n        return data\n    }\n    // 类型投影\n    fun copy(from: Wrapper<out Any>, to: Wrapper<Any>){}\n    // 星投影\n    fun print(w: Wrapper<*>) {}\n}\n\n// 泛型函数\nfun <T> singleList(t: T): List<T> {\n    return Arrays.asList(t)\n}\n\n// 泛型约束\n// 上界\nfun <T: Comparable<T>> sort(list: List<T>){}\n\nfun main() {\n    // 泛型自动推导\n    var wrapper = Wrapper(1)\n}\n```\n\n### 枚举类\n\n```kotlin\nenum class Season(val desc: String) {\n    SPRING(\"春\"),\n    SUMMER(\"夏\"),\n    AUTUMN(\"秋\"),\n    WINTER(\"冬\"),\n\n    // 匿名内部类\n    QUANZHOU_AUTUMN(\"夏秋-秋夏\") {}\n}\n\nfun main() {\n    for (season in Season.values()) {\n        println(\"${season.name} ${season.ordinal} ${season.desc}\")\n    }\n}\n```\n\n### 内联类\n\n```kotlin\n// 内联类：引入了一种新的类型，并且都在运行时表示为基础类型\n// 构造器只允许一个参数 其在使用时会内被编译为其基础类型\n@JvmInline\nvalue class Password(val raw: String)\n```\n","metadata":"","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2022-04-28T15:53:43+08:00","author":"cjiping","message":"✏️更新 kotlin","hash":"c06c31104edf0b80aada1f5599dbfb6f42519c3c"},{"date":"2022-04-27T14:57:43+08:00","author":"cjiping","message":"✏️更新 kotlin","hash":"dc6796df43896e4450bfddad1c4b776987244054"},{"date":"2022-04-26T15:57:11+08:00","author":"cjiping","message":"✏️更新 kotlin","hash":"78cbf69a48090a0df2b61049e9a6317d3970f015"},{"date":"2022-04-25T16:21:55+08:00","author":"cjiping","message":"✏️更新 kotlin","hash":"c10e959279ed8862f3063003a4c97455ce823684"},{"date":"2022-04-22T16:23:24+08:00","author":"cjiping","message":"✏️更新 kotlin","hash":"3244096fb63a74a4ad3474a5e5b59ffce8dbe6da"},{"date":"2022-04-20T16:13:28+08:00","author":"cjiping","message":"➕新增 kotlin","hash":"2b6ee082be4166ead46188986d214fb271fb2343"}],"createTime":"2022-04-20T16:13:28+08:00"}