{"name":"Swift","id":"编程语言-Swift","content":"# Swift\n\n## 变量常量与基本类型\n\n```swift\n// 常量\nlet pi = 3.14\n// 变量\nvar i = 1, j = 2\n// 显式变量类型\nvar url: String = \"www.baidu.com\"\n\n// 整型 取决于机器字长\nprint(Int.max)\n// 无符号整型\nprint(UInt.max)\n// 8位整型\nprint(Int8.max)\n\n// 浮点数\nlet x: Float = 3.1415926\nlet y: Double = 3.155645\nprint(x, y)\n\n// 不支持隐式转换\nprint(x+Float(y))\n\n// 元组\nvar property: (String, Int, (Int, Int, Int)) = (\"cxk\", 18, (35, 35, 35))\nprint(property)\nprint(property.0)\nprint(property.1)\n// 元组的比较\nprint((1,2,3) < (3,2,1))\n// 解构\nlet (name, age, quake) = property\n// 解构忽略部分属性\nlet (name1, age1, _) = property\nprint(name, age, quake)\n// 命名元组属性\nvar point: (x: Int, y: Int) = (1,2)\nvar point1 = (x:1, y: 2)\nprint(\"the point: \\(point), point1: \\(point1)\")\n```\n\n## 运算符\n\n基本的数值逻辑运算符操作跟 Java 一样, 但在 Swift3 之后 ++ -- 已被废弃\n\n=== 与 !== 用来比较对象的引用\n\n### 常量的首次赋值\n\n```swift\nlet i: Int\nvar condition = false\nif condition {\n    i = 1\n}else {\n    i = 2\n}\n```\n\n### 范围运算符\n\n```swift\nlet a = 0..<10 // 前闭后开（0-9）\nprint(a)\n// 前闭后闭（1-10）\nfor index in 1...10 {\n    print(index)\n    // 循环里的index是常量\n    // index += 1\n}\n\n```\n\n## 控制流\n\n### 循环\n\n- for 循环\n\n```swift\n// 忽略下标\nfor _ in 1...10 {\n    print(\"gogogo\")\n}\n```\n\n- while 循环\n\n```swift\nvar i = 1\n// i的后面一定要有空格\nwhile i <= 10 {\n    print(i)\n    i += 2\n}\n\n```\n\n- do-while循环\n\n```swift\nvar j = 1\nrepeat {\n    print(j)\n    j += 2\n}while(j <= 10)\n```\n\n### 选择\n\n- if 同类C语言\n\n- switch\n\n```swift\n// 每条case之间不用加break\nvar rank = \"a\"\nswitch rank {\n// 同时case多个条件\ncase \"a\", \"A\":\n    print(\"jn\")\ncase \"b\":\n    print(\"d\")\ndefault:\n    print(\"defa\")\n// 空语句\n//default:break\n//default:()\n}\n\n// switch与范围\nswitch 5 {\ncase 1...5:\n    print(\"1-5\")\ncase 6...10:\n    print(\"6-10\")\ndefault:()\n}\n// switch与元组\nlet response = (200, \"OK\")\nswitch response {\ncase(200, \"OK\"):\n    print(\"done\")\ncase(200, \"GOON\"):\n    print(\"continue\")\ndefault:()\n}\n// 在case中解构变量\nswitch (0,0) {\ncase(let x, 0):\n    print(\"x is \\(x)\")\ncase (0, let y):\n    print(\"y is \\(y)\")\ndefault:()\n}\n// 继续往下执行\nswitch 5 {\ncase 5:\n    print(\"5\")\n    // 不会判断下面的case是否满足条件 无脑执行\n    fallthrough\ncase 6:\n    print(\"6\")\ndefault:()\n}\n```\n\n### 控制转移\n\n```swift\n// 跳出多重循环\noutter:\nfor index in 1...10{\n    for index1 in 1...10 {\n        if (index == 3 && index1 == 3) {\n                print(\"i got go\")\n                break outter\n        }\n    }\n}\n```\n\n### where\n\n```swift\n// where类似于SQL中的where 是一种条件限定\nswitch (3,3){\ncase let(x,y) where x == y:\n    print(\"x == y\")\ncase let(x,y):\n    ()\n}\n\nfor case let index in 1...10 where index % 3 == 0 {\n    print(index)\n}\n```\n\n### guard\n\n```swift\n// 防御式编程的语义化\n// 只有满足条件才不会进入代码块\nguard num >= 1 else {\n    print(\"stop\")\n    exit(0)\n}\n```\n\n## 字符串\n\n### 基础\n\n```swift\n// 判断是否是空字符串\nprint(str.isEmpty)\n// 插值表达式\nprint(\"name: \\(str)\")\n\n// 字符串拼接 转义字符等同类C语言\n```\n\n### char与unicode\n\n```swift\n// 显式声明单个字符（底层采用unicode存储）\nlet single: Character = \"中\"\nlet single1: Character = \"🐶\"\n// 遍历字符\nfor c in \"中文大萨达🇨🇳\" {\n    print(c)\n}\n// 字符串是可变的\nstr.append(\"jntm\")\nprint(str)\n\n// 字符串长度\nprint(str.count)\n\n```\n\n### 索引\n\n- 挺难用的\n\n```swift\n// 字符串索引\n// [startIndex, endIndedx)\nvar s = \"我如果付费\"\n// 需要根据startIndex 或者endIndex 计算\nprint(s[s.index(s.startIndex, offsetBy: 2)]) // 果 在第一个索引往后的2个\nprint(s[s.index(before: s.endIndex)]) // 费 在最后一个索引之前的一个\n```\n\n### 方法\n\n```swift\nprint(s.uppercased())\nprint(s.lowercased())\nprint(s.capitalized) // 将每个单词转为首字母大写\nprint(s.contains(\"如果\"))\nprint(s.hasPrefix(\"我 \"))\nprint(s.hasSuffix(\"费\"))\n```\n\n### NSString\n\n```swift\nprint(NSString(format: \"%.2f\", 1.0 / 3.0) as String)\n// 截取\nprint(NSString(\"微分去问问\").substring(with: NSMakeRange(1, 3)))\n// 替换两边的字符\nprint(NSString(\"-a-\").trimmingCharacters(in: CharacterSet(charactersIn: \"-\")))\n```\n\n## 可选型\n\n```swift\nvar responseCode : Int? = 404\nvar responseMessage: String? = \"success\"\nresponseCode = nil\nvar code: Int! = 4\nlet a  = code // 此时a的类型是Int?\nlet b: Int = code // 可以转为Int\n```\n\n### 解包\n\n```swift\n// 强制解包\nprint(responseCode!)\n// 在判断中解包\nif let responseCode = responseCode {\n    // 这里出现了变量遮蔽\n    print(responseCode)\n}\n// 同时判断解包多个\nif let responseCode = responseCode,\n   let responseMessage = responseMessage {\n    print(responseCode, responseMessage)\n}\n```\n\n### 可选型链\n\n```swift\nif let responseMessage = responseMessage {\n    print(responseMessage.uppercased)\n}\n// 等同于\nprint(responseMessage?.uppercased)\n\n// 如果是 nil 则 message 的值 为 message null\nlet message = responseMessage ?? \"message null\"\n```\n\n### 在类库中的使用\n\n```swift\n// 类型转换 如果转换失败 就返回 nil\nif let age = Int(\"18\"), age <= 18 {\n    print(age)\n}\n```\n\n### 隐式可选型\n\n```swift\n// 一般用在类中 初始化时为空 当初始化完成 保证对外提供的不为 nil\nvar a: String! = nil\n// a = \"hello\"\n// 执行错误\nprint(a + \"dsds\")\n```\n\n## 数组\n\n### 声明\n\n```swift\nvar nums = [0,1,2,3]\n\n// 指定类型\nvar strings: [String] = [\"0\",\"2\", \"a\"]\n\n// 空数组\nvar es : Array<Int> = []\nvar es1 = [Int]()\n\n// 5个元素初始值 全为5\nvar allZeros = [Int](repeating: 5, count: 5)\n```\n\n### 基本操作\n\n```java\nprint(allZeros.count)\nprint(allZeros.isEmpty)\n// 数组越界会有运行异常\nprint(allZeros[3])\nprint(allZeros.first!, allZeros.last!)\nprint(nums.min()!, nums.max()!)\n\n// 子数组 1,2,3\nprint(nums[1..<4])\nprint(nums.contains(3))\nprint(nums.firstIndex(of: 3)!)\n\n// for-each\nfor number in nums {\n    print(number)\n}\n// 带下标的for-each\nfor (index, item) in strings.enumerated() {\n    print(index, item)\n}\n\n// 值比较\nprint(nums == [0,1,2,3])\n```\n\n### 修改\n\n```swift\nes.append(\"jntm\")\n// 添加两个元素到数组里面\nes += [\"cxk\", \"juki\"]\n// 插入后位于索引2\nes.insert(\"ctrl\", at: 2)\nes.removeLast()\nes.removeFirst()\n// 删除指定下标\nes.remove(at: 1)\nes.removeAll()\n\nnums[0] = 3\n// 区间设置值\nnums[0...2] = [9,9,9]\n// 两边长度可以不一致\nnums[0...2] = [7]\n```\n\n### NSArray\n\n```swift\n// 可以承载不同数据类型\nvar na: NSArray = [1, \"hello\", 3]\n```\n\n## 集合\n\n### 字典\n\n```swift\nvar dict: [String: String] = [\"name\": \"cxk\", \"age\": \"18\"]\nvar dict1: Dictionary<String, String> = [:]\n\nprint(dict[\"name\"]!)\nprint(Array(dict.keys))\nprint(Array(dict.values))\nfor key in dict.keys {\n    print(dict[key]!)\n}\nfor (key, value) in dict {\n    print(key, value)\n}\nprint(dict == [\"name\": \"cxk\", \"age\": \"18\"])\n\n// 更新\ndict[\"name\"] = \"jntm\"\n// 这个方法会返回其之前的值\ndict.updateValue(\"jntm\", forKey: \"name\")\n// 删除\ndict[\"name\"] = nil\ndict.removeValue(forKey: \"name\")\ndict.removeAll()\n```\n\n### Set\n\n```swift\n// 声明\nvar set : Set<String> = [\"a\", \"b\" , \"c\"]\n\nfor i in set {\n    print(i)\n}\nprint(set == [\"b\", \"c\", \"a\"])\nset.insert(\"aa\")\nset.remove(\"c\")\n// 集合运算\nprint(set.union([\"a\",\"aa\"]))\nprint(set.intersection([\"a\", \"aa\"]))\nprint(set.subtracting([\"a\", \"aa\"]))\nprint(set.symmetricDifference([\"a\", \"aa\"]))\n```\n\n## 函数\n\n### 定义\n\n```swift\n// 有参数有返回值\nfunc say(name: String, age: Int) -> String {\n    return \"jntm \\(name) - \\(age)\"\n}\n// 无参数无返回值\nfunc say() {\n    print( \"ctrl\")\n}\n// 返回多个值\nfunc request() -> (message: String, code: Int) {\n    return (\"not found\", 404)\n}\n// 调用时 多个参数必须使用 形参: 实参 的形式\nprint(say(name: \"cxk\", age: 18))\n```\n\n### 外内部参数名\n\n```swift\n// 外部与内部参数名\nfunc request(url getUrl: String) {\n    print(getUrl)\n}\nrequest(url: \"http://baidu.com\")\n\n// 忽略外部参数名\nfunc request(_ url: String, _ method: String) {}\nrequest(\"baidu.com\", \"get\")\n```\n\n### 默认参数、可变参数\n\n```swift\n// 可变参数不像其他语言 可以不放在最后 可变参数本质上也是一个数组\nfunc request(url: String, method: String = \"get\", params: String ...){}\nrequest(url: \"baidu.com\", params: \"sds\", \"dfsds\")\n```\n\n### 引用参数\n\n```swift\n// 默认参数值和可变参数\n// 可变参数不像其他语言 可以不放在最后 可变参数本质上也是一个数组\nfunc request(url: String, method: String = \"get\", params: String ...){}\nrequest(url: \"baidu.com\", params: \"sds\", \"dfsds\")\n\n// 形参默认都是不可变的\n// 使用 inout 关键字 相当于一个指针\nfunc request(url: inout String){\n    url = \"google.com\"\n}\nvar u = \"dsds\"\nrequest(url: &u)\nprint(u)\n```\n\n### 函数式编程\n\n```swift\nfunc submit(runnable: () -> ()) {\n    runnable()\n}\nfunc print(){\n    print(\"running\")\n}\n// 第一种调用\nsubmit(runnable: print)\n// 第二种调用\nsubmit {\n    print(\"hhh\")\n}\n// 传递一个参数\nfunc submit(consumer: (String) -> ()){\n    consumer(\"ikun\")\n}\nsubmit { params in\n    print(params)\n}\n// 函数式编程三大操作\nprint([1,2,3].map{ v in v + 1})\nprint([1,2,3].filter{ v in v % 2 == 0})\nprint([1,2,3].reduce(10, {x, y in x + y}))\n\n// 返回函数类型\nfunc getFuture() -> () -> () {\n    return {\n        print(\"this is future\")\n    }\n}\ngetFuture()()\n// 函数嵌套\nfunc execute(){\n    func innerFunc(){\n        print(\"hello world\")\n    }\n    innerFunc()\n}\nexecute()\n```\n\n## 闭包\n\n```swift\nvar res = [1, 2, 3].sorted(by: { (a: Int, b: Int) -> Bool in\n    return a > b\n})\nprint(res)\n\n// 化简\nprint([1,2,3].sorted(by: {a, b in a > b}))\n// 默认命名\nprint([1, 2, 3].sorted(by: {$0 > $1}))\n// 大于号本身是一个函数\nprint([1,2,3].sorted(by: >))\n\n// 结尾闭包 最后一个参数是闭包的话 可以使用这种语法\nprint([1,2,3].sorted{ a, b in a > b})\nprint([1,2,3].map{v in String(v)})\n\n// 内容捕获\nvar num = 700\nprint([1,2,3].sorted{a , b in abs(a-num) < abs(b-num)})\n\n// @autoclosure 自动将值封装成匿名函数\nfunc test(f: @autoclosure () -> String) -> String {\n    return f()\n}\ntest(f: \"test\")\n```\n\n## 枚举\n\n```swift\nenum Color: String {\n    case Red = \"红色\",Yellow = \"黄色\",Blue = \"蓝色\"\n}\nlet color: Color = .Blue\n\nswitch color {\ncase .Blue:\n    print(color.rawValue)\ncase .Yellow:\n    print(color.rawValue)\ncase .Red:\n    print(color.rawValue)\n}\n\n// 使用rawValue获取枚举值\nprint(Color(rawValue: \"红色\")!)\n\n// 关联值\nenum Status {\n    case Success(message: String, code: Int)\n    case Error(String)\n}\nlet result = Status.Success(message: \"done\", code: 200)\nswitch result {\ncase let .Success(message, _):\n    print(\"sucess \\(message)\")\ncase .Error:\n    print(\"error\")\n}\n\n// 可选型的本质就是使用了关联值的枚举\nlet name: String? = Optional.some(\"jntm\")\nswitch name {\ncase let .some(name):\n    print(name)\ncase .none:\n    print(\"is nil\")\n}\n```\n\n## 结构体\n\n```swift\nstruct Location {\n    // 这里var跟let的区别在于是否可变\n    var x = 0,y: Int = 0\n    var z: Int = 0\n    \n    init() {}\n    init(x: Int, y: Int, z: Int) {}\n    init(x: Int, y: Int) {\n        self.x = x\n        self.y = y\n    }\n    // 可失败的构造函数 返回nil\n    init?(x: Int) {\n        guard x <= 100 else {\n            return nil\n        }\n        self.x = x\n    }\n    \n    func distance() -> Int {\n        return x - y\n    }\n\n    // 如果不加mutating这个关键字 这个方法就没法修改结构体\n    mutating func setX(x: Int) {\n        self.x += 1\n    }\n}\n\nvar home = Location(x: 1, y: 2, z: 3)\n// 如果里面的字段有默认值 在这里的构造可以传参\nvar empty = Location()\nprint(Location(x: 4, y: 3))\nprint(home.x)\nprint(Location(x:101) ?? -1)\nhome.x = 2\nprint(home.distance())\n\n// 结构体和枚举是值类型\nvar p1 = Location(x: 1, y: 2)\nvar p2 = p1\np1.x = 3\nprint(p2.x == 1)\n```\n\n## 类\n\n```swift\nclass Person {\n    static var popilation: Int = 700_0000_0000\n    var name: String\n    var age: Int {\n        // 属性观察器 需要注意的是不会在init阶段被调用\n        // 将要赋值\n        willSet {\n            if newValue > 200 {\n                print(\"太太老\")\n            }\n        }\n        // 已经赋值了\n        didSet {\n            if age == 18 {\n                print(\"貌美如花\")\n            }\n            if age > 100 {\n                print(\"太老了\")\n                age = oldValue\n            }\n        }\n    }\n    // 计算属性\n    var nameAndAge: String {\n        get{\n            return name + \",\" + String(age)\n        }\n        set(nameAndAge) {\n            self.name = nameAndAge.components(separatedBy: \",\")[0]\n            self.age = Int(nameAndAge.components(separatedBy: \",\")[1])!\n        }\n    }\n    var bithYear: Int {\n        return 2022 - self.age\n    }\n    \n    // 延迟属性 首次访问时会被计算后缓存下来\n    lazy var firstDate: Date = {\n        return Date()\n    }()\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    init?(nameAndAge: String) {\n        if !nameAndAge.contains(\",\") {\n            return nil\n        }\n        self.name = nameAndAge.components(separatedBy: \",\")[0]\n        self.age = Int(nameAndAge.components(separatedBy: \",\")[1])!\n    }\n    \n    \n    // 类型方法\n    static func populationBalanced() -> Bool {\n        return popilation <= 7000_0000_0000\n    }\n}\n\n// 类创建的对象是引用类型\nlet cxk = Person(name: \"cxk\", age: 18)\nprint(cxk.age)\nprint(Person(nameAndAge: \"cxk,18\")!.age)\n\n// cxk本身如果是常量 但里面的成员是变量 则可以修改 不像结构体\ncxk.age = 22\n\n// 继承\nclass Student: Person {\n    var grade = 12\n    // 重载构造器\n    // 使用required关键字来强制子类必须重写该构造函数\n    required init(grade: Int) {\n        // 在super.init之前 不能做self初始化之外的操作\n        // self.eat()\n        super.init(name: \"cxk\", age: 17)\n        self.grade = grade\n    }\n    // 便利构造函数 通过一定逻辑调用其他构造函数初始化\n    // 便利构造器无法调用super.init\n    // 如果子类实现了父类所有的指定构造函数，则自动继承父类的所有便利构造函数\n    convenience init(){\n        self.init(name: \"jntm\", age: 22)\n    }\n    // 重写构造器\n    override init(name: String, age: Int) {\n        super.init(name: name, age: age)\n        self.name = name\n        self.age = age\n    }\n    // 重写属性\n    override var bithYear: Int {\n        return 2023 - self.age\n    }\n    // 重写方法\n    override func eat() {\n        print(\"student eat\")\n    }\n}\n// 禁止再继承\nfinal class SuperPerson: Person{}\nlet student = Student(grade: 12)\nprint(student.nameAndAge)\n\n// 多态\nlet persons: [Person] = [SuperPerson(nameAndAge: \"s1,14\")!, Student(grade: 18), Person(nameAndAge: \"s1,32\")!]\n\n```\n\n访问控制：\n\n- public 可在模块外访问\n- internal 默认的控制 可在本模块内访问\n- private 只允许在本文件内访问\n\n## 运算符重载\n\n```swift\n// 自定义运算符需要声明 postfix prefix infix\ninfix operator |||\n\nstruct ReversedList {\n    var data: [Int] = [1,2,3,4,5]\n    \n    // 重载下标运算符\n    subscript(index: Int) -> Int? {\n        get {\n            data[data.count - index - 1]\n        }\n        set {\n            if let newValue = newValue {\n                data[data.count - index - 1] = newValue\n            }\n        }\n    }\n    // 多维下标\n    subscript(index1: Int, index2: Int) -> Int {\n        return data[index1] + index2\n    }\n    \n    // 算术运算符重载\n    static func + (left: ReversedList, right: ReversedList) -> ReversedList {\n        return ReversedList(data: left.data + right.data)\n    }\n    static func + (left: ReversedList, right: Int) -> ReversedList {\n        var left = left\n        for i in 0..<left.data.count {\n            left.data[i] += right\n        }\n        return left\n    }\n    static func += (left: inout ReversedList, right: Int) {\n        left = left + right\n    }\n    prefix static func - (left: ReversedList) -> ReversedList {\n        return ReversedList(data: left.data.map {-$0})\n    }\n    \n    // 比较运算符重载\n    static func == (left: ReversedList, right: ReversedList) -> Bool {\n        guard left.data.count == right.data.count else {\n            return false\n        }\n        for i in 0..<left.data.count {\n            if (left.data[i] != right.data[i]) {\n                return false\n            }\n        }\n        return true\n    }\n    static func < (left: ReversedList, right: ReversedList) -> Bool {\n        for i in 0..<left.data.count {\n            if left.data[i] >= right.data[i] {\n                return false\n            }\n        }\n        return true\n    }\n    \n    // 自定义运算符 /,=,-,+,!,*,%,<,>,&,|,^,~\n    static func ||| (left: ReversedList, right: ReversedList) -> ReversedList {\n        var left = left\n        for i in 0..<left.data.count {\n            left.data[i] = left.data[i] % right.data[i]\n        }\n        return left\n        \n    }\n}\n```\n\n## 扩展\n\n```swift\nextension String {\n    // 如果扩展类的构造方法 则构造方法必须是便利构造方法\n    init(by: String) {\n        self.init(by.uppercased())\n    }\n    \n    // 扩展的属性只能是计算型属性\n    var length: Int {\n        self.count\n    }\n    \n    func firstChar() -> Character {\n        return self[self.startIndex]\n    }\n    \n    // 嵌套类型\n    struct Range {}\n}\n\nlet range : String.Range? = nil\n```\n\n## 泛型\n\n```swift\n// 泛型函数\nfunc swap<T>(a: inout T, b: inout T) {\n    (a,b) = (b,a)\n}\n\nvar a = \"123\"\nvar b = \"321\"\nswap(a: &a, b: &b)\nprint(a,b)\n\n// 泛型类型\nstruct ArrayList<T> {\n    var data: [T] = []\n    \n    mutating func add(e: T) {\n        data += [e]\n    }\n}\n\nvar list = ArrayList<String>()\nlist.add(e: \"123\")\nprint(list)\n```\n\n## 协议\n\n```swift\nprotocol Runnable {\n    \n    // 协议的属性\n    var threadName: String {get set}\n    \n    // 协议的方法\n    func run()\n}\nstruct Task: Runnable {\n    var threadName = \"test\"\n    func run() {\n        print(\"running\")\n    }\n    \n}\n\n// 只有类才能实现该协议\nprotocol Future: AnyObject {}\nclass MyFuture: Future{}\n\n// 如果既需要继承有需要协议 则继承类要放在协议的前面\nclass Callable: NSObject, Future {}\n\n// 类型别名\ntypealias Length = Int\nlet length: Length = 123\n\n// 类型参数化\nprotocol WeightCalacuable {\n    associatedtype WightType\n    var weight: WightType {get}\n}\n\nclass Phone: WeightCalacuable {\n    typealias WightType = Double\n    var weight = 0.114\n}\nclass Boat: WeightCalacuable {\n    typealias WightType = Int\n    var weight = 100_0000\n}\n```\n\n标准库的常用协议：Equatable, Comparable, CustomStringCovertible\n\n### 面向协议编程\n\n```swift\n// 扩展协议\nprotocol Callable: Runnable{\n    func call() -> Int\n    \n}\n// 协议的默认实现\nextension Callable {\n    func run() {\n        let _ = self.call()\n    }\n}\n// 限定扩展：只有同时实现Callable和WeightCalacuable才应用\nextension Callable where Self: WeightCalacuable {\n    func run() {\n        print(\"calc run\")\n    }\n}\nstruct Computer: Callable, WeightCalacuable {\n    var weight: Int\n    func call() -> Int {\n        return 0\n    }\n    \n    typealias WightType = Int\n    var threadName: String\n    \n}\nComputer(weight: 1, threadName: \"test\").run()\n// 协议聚合：同时实现两种协议的参数才被接受\nfunc run(computeable: Callable & CustomStringConvertible){}\n// 泛型约束\nfunc topOne<T: Comparable & CustomStringConvertible>(seq: [T]) -> T {\n    let ans = seq.sorted()[0]\n    print(ans.description)\n    return ans\n}\nprint(topOne(seq: [67,6,4,23,45,2,1]))\n\n// 协议的可选方法\n@objc protocol Service {\n    @objc optional func start()\n}\nclass UserService: Service{}\nlet service: Service = UserService()\nif let start = service.start {\n    start()\n}\n```\n\n## 错误处理\n\n```swift\nenum RuntimeError: Error{\n    case NetWorkError(String)\n    case ReadTimeOutError\n}\n\nfunc main(a: Int) throws -> Void {\n    // 函数执行结束后才会执行\n    defer {\n        print(\"finally2 execute\")\n    }\n    defer {\n        print(\"finally1 execute\")\n    }\n    if a == 1 {\n        throw RuntimeError.NetWorkError(\"unknow host\")\n    }\n}\n// 强制忽略异常 发生异常程序就会崩\ntry! main(a:2)\n// 忽略异常 发生异常不会蹦\ntry? main(a: 1)\n\ndo {\n    try main(a: 1)\n}catch RuntimeError.NetWorkError(let e) {\n    print(\"error\", e)\n}catch let e as RuntimeError {\n    print(e)\n}catch {\n    print(\"unknow error\")\n}\n// 使用Nerver代表异常情况\nfunc errorHandle() -> Never {\n    print(\"!!!\")\n    fatalError()\n}\nvar aaa = 1\nguard aaa != 1 else {\n    errorHandle()\n}\n\n```\n\n## 内存管理\n\n```swift\nclass Pet {\n    var owner: Person?\n    init(owner: Person) {\n        self.owner = owner\n    }\n    deinit{\n        print(\"pet clean\")\n    }\n}\n\nclass Person {\n    // 没有加weak时会出现相互引用导致内存泄漏 加了weak后不会增加pet的引用数\n    // weak要求类型是可选型并且是var的 如果不满足这个条件 需要使用unowned\n    // 但unowned有一定的风险 如果一个unowned被回收后被使用 则会发生致命错误\n    weak var pet: Pet?\n    init() {\n        pet = Pet(owner: self)\n    }\n    deinit {\n        print(\"person clean\")\n    }\n}\n\n// swift 使用引用计数\nvar p: Person? = Person()\np = nil\n```\n\n对于闭包循环引用 可以使用 [unoned xxx] 的方式来声明闭包内的变量为弱引用\n\n## 类型检查与转换\n\n```swift\nclass Animal{}\nclass Duck: Animal{}\nclass Dog: Animal{}\n\nlet dog: Animal = Dog()\n// 类型检查\nprint(dog is Dog)\n// 尝试强制转型 失败返回nil\nprint((dog as? Dog)!)\n```\n\nAny > AnyObject > NSObject\n","metadata":"","hasMoreCommit":true,"totalCommits":21,"commitList":[{"date":"2022-05-01T14:51:44+08:00","author":"MY","message":"✏️更新 swift","hash":"8034468cdf26cd5071420395d69776f306064c29"},{"date":"2022-04-27T21:19:08+08:00","author":"MY","message":"✏️更新 swift","hash":"20b44a478e875e18a2b8340c58edb8cab8e297a2"},{"date":"2022-04-26T20:59:28+08:00","author":"MY","message":"✏️更新 swift","hash":"eae954e75475748ba562c44b3faa5a75d2c8da4f"},{"date":"2022-04-25T20:59:30+08:00","author":"MY","message":"✏️更新 swift","hash":"ab3daad3352b6d869cfabc37c53abe80c37fa8af"},{"date":"2022-04-24T21:03:28+08:00","author":"MY","message":"✏️更新 swift","hash":"096f45981787652c8b602a99e11782c9123bba80"},{"date":"2022-04-23T21:27:58+08:00","author":"MY","message":"✏️更新 swift","hash":"f79e6f7b2a045519e1cd67ad2709452c19a8a87f"},{"date":"2022-04-21T21:06:59+08:00","author":"MY","message":"✏️更新 swift","hash":"1f12b75ccd1f4e0e9cb6c6f32ee6d23ef194581a"},{"date":"2022-04-19T21:21:11+08:00","author":"MY","message":"✏️更新 swift","hash":"cd2058286b171da4371ba885a22cf9495bf7d90c"},{"date":"2022-04-18T21:18:35+08:00","author":"MY","message":"✏️更新 swift","hash":"41eeeaee1e6d1ec7de4e395438562be1d82f2a67"},{"date":"2022-04-15T16:19:07+08:00","author":"MY","message":"✏️更新 swift","hash":"2797d82fdb684466430eb9380b91fcfa09f8ceb9"}],"createTime":"2022-04-05T15:31:34+08:00"}