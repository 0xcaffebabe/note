{"name":"WebAssembly","id":"编程语言-WebAssembly","content":"\n# WebAssembly\n\n- 一种基于堆栈式虚拟机的二进制指令集\n\n对于可以应用在诸如 i386、X86-64 等实际存在的物理系统架构上的指令集，我们一般称之为 ISA（Instruction Set Architecture，指令集架构）。而对另外一种使用在虚拟架构体系中的指令集，我们通常称之为 V-ISA，也就是 Virtual（虚拟）的 ISA，JVM 跟 WASM 都属于后者\n\n## 模块组成\n\n每一个不同的 Section 都描述了关于这个 Wasm 模块的一部分信息。而模块内的所有 Section 放在一起，便描述了整个模块在二进制层面的组成结构\n\n### Type Section\n\n存放了 Wasm 模块使用到的所有函数类型（签名）\n\n### Start Section\n\n通过这个 Section，我们可以为模块指定在其初始化过程完成后，需要首先被宿主环境执行的函数\n\n### Global Section\n\n主要存放了整个模块中使用到的全局数据（变量）信息\n\n### Custom Section\n\n主要用来存放一些与模块本身主体结构无关的数据，比如调试信息、source-map 信息等等\n\n### Import Section 和 Export Section\n\nImport 定义了所有从外界宿主环境导入到模块对象中的资源，这些资源将会在模块的内部被使用，能够在 Wasm 模块之间，以及 Wasm 模块与宿主环境之间共享代码和数据\n\nExport 可以将一些资源导出到虚拟机所在的宿主环境中\n\n### Function Section 和 Code Section\n\nFunction Section 存放了模块内每个函数对应的函数类型，即具体的函数与类型对应关系；而在 Code Section 中存放的则是每个函数的具体定义，也就是实现部分\n\n### Table Section 和 Element Section\n\n目前 Table Section 的作用并不大，你只需要知道我们可以在其对应的 Table 结构中存放类型为 “anyfunc” 的函数指针，并且还可以通过指令 “call_indirect” 来调用这些函数指针所指向的函数\n\n通过 Element Section，我们便可以为 Table Section 所描述的 Table 对象填充实际的数据\n\n### Memory Section 和 Data Section\n\nMemory Section 可以描述一个 Wasm 模块内所使用的线性内存段的基本情况，比如这段内存的初始大小、以及最大可用大小等等\n\n使用 Data Section 为线性内存段填充实际的二进制数据\n\n### 魔数和版本号\n\n开头的前四个字节分别为 “（高地址）0x6d 0x73 0x61 0x0（低地址）”\n\n四个字节对应的 ASCII 可见字符为 “asm”\n\n接下来的四个字节，用来表示当前 Wasm 二进制文件所使用的 Wasm 标准版本号，版本号1即为 0x0 0x0 0x0 0x1\n\n## 数字类型\n\nWasm 将其模块内部所使用到的数字值分为以下三种类型：\n\n1. uintN（N = 8 / 16 / 32） 表示了一个占用 N 个 bit 的无符号整数。该整数由 N/8 个字节组成，并以小端模式进行存储\n2. varuintN（N = 1 / 7 / 32） 使用 Unsigned LEB-128 编码，具有 N 个 bit 长度的可变长无符号整数\n3. varintN（N = 7 / 32 / 64） 表示的是使用 Signed LEB-128 编码，具有 N 个 bit 长度的可变长有符号整数\n\n## WAT\n\n- WebAssembly 可读文本格式\n\n一种与 Wasm 字节码格式完全等价，可用于编码 Wasm 模块及其相关定义的文本格式\n\n```wasm\n(func $factorial (; 0 ;) (param $0 i32) (result i32)\n (local $1 i32)\n (local $2 i32)\n (block $label$0\n  (br_if $label$0\n   (i32.eqz\n    (get_local $0)\n   )\n  )\n  (set_local $2\n   (i32.const 1)\n  )\n  (loop $label$1\n   (set_local $2\n    (i32.mul\n     (get_local $0)\n     (get_local $2)\n    )\n   )\n   (set_local $0\n    (tee_local $1\n     (i32.add\n      (get_local $0)\n      (i32.const -1)\n     )\n    )\n   )\n   (br_if $label$1\n    (get_local $1)\n   )\n  )\n  (return\n   (get_local $2)\n  )\n )\n (i32.const 1)\n)\n```\n\n### S表达式\n\n求值会从最内层的括号表达式开始，类似于Lisp\n\n### Flat-WAT\n\n平铺即通过“嵌套”与“小括号”的方式指定了各个表达式的求值顺序\n\n```wasm\n\n(func $factorial (param $0 i32) (result i32)\n block $label$0\n  local.get $0\n  i32.eqz\n  br_if $label$0\n  local.get $0\n  i32.const 255\n  i32.add\n  i32.const 255\n  i32.and\n  call $factorial\n  local.get $0\n  i32.mul\n  i32.const 255\n  i32.and\n  return\n end\n i32.const 1)\n```\n\n### 模块结构\n\n```wasm\n\n(module\n (table 0 anyfunc)\n (memory $0 1)\n (export \"memory\" (memory $0))\n (export \"factorial\" (func $factorial))\n ...\n)\n```\n\n### 相关工具\n\n- wasm2wat：该工具主要用于将指定文件内的 Wasm 二进制代码转译为对应的 WAT 可读文本代码\n- wat2wasm：该工具的作用恰好与 wasm2wat 相反。它可以将输入文件内的 WAT 可读文本代码转译为对应的 Wasm 二进制代码\n- wat-desugar：该工具主要用于将输入文件内的，基于 “S- 表达式” 形式表达的 WAT 可读文本代码“拍平”成对应的 Flat-WAT 代码\n\n## WASI\n\n- 这个抽象层允许了在 Web 场景之外使用 Wasm\n\n![20221129103749](/assets/20221129103749.webp)\n\nWASI 在 Wasm 字节码与虚拟机之间，增加了一层“系统调用抽象层”提供了可移植性\n\n另外一点，基础设施，即虚拟机在实现WASI标准时，便会采用 “Capability-based Security” 的方式来控制每一个 Wasm 模块实例所拥有的 capability\n\n## 浏览器加载\n\n能够使用 Wasm 来实现的功能，现阶段都可以通过 JavaScript 来实现\n\n- fetch 将被使用到的 Wasm 二进制模块，从网络上的某个位置通过 HTTP 请求的方式，加载到浏览器中\n- compile 将从远程位置获取到的 Wasm 模块二进制代码，编译为可执行的平台相关代码和数据结构\n- instantiate 浏览器引擎开始执行在上一步中生成的代码\n- call 可以直接通过上一阶段生成的动态 Wasm 模块对象，来调用从 Wasm 模块内导出的方法\n\n对应的 js 方法：\n\n```js\nbufferSource = new Int8Array([...]); \nlet module = new WebAssembly.Module(bufferSource);\n\nlet memory = new WebAssembly.Memory({\n  initial:10, \n  maximum:100,\n});\n\nWebAssembly.compile(bufferSource)\n\nWebAssembly.instantiate(bufferSource, importObject)\n```\n\n### Web API\n\n- 流式实例化 WebAssembly.instantiateStreaming(source, importObject)\n- 流式编译 WebAssembly.compileStreaming(source)\n\n### 运行时\n\n- 每一个经过实例化的 Wasm 模块对象，都会在运行时维护自己唯一的“调用栈”\n- 每一个实例化的 Wasm 模块对象都有着自己的（在 MVP 下只能有一个）线性内存段\n\n![20221129114714](/assets/20221129114714.webp)\n\n### 内存模型\n\n在 Web 浏览器这个宿主环境中，一个内存实例通常可以由 JavaScript 中的 ArrayBuffer 类型来进行表示\n\n![20221129115134](/assets/20221129115134.webp)\n\n### 局限\n\n- 想要在Wasm 二进制模块内引用外部 DOM，目前需要通过封装导入对象来实现\n- 复杂数据类型需要进行编解码\n\n## 应用\n\n- 作为一种中间表示的字节码格式\n- 在浏览器中适合计算密集型的操作\n\n## 纳米进程\n\n每一个模块实例都拥有着自己独立的数据资源及可用权限，因此我们可以称每一个实例化的模块为一个独立的 “nanoprocess”\n\n为了避免依赖的第三方模块是恶意模块，每个模块拥有的权限，都是来源于其调用者，即全部来自于最上层的调用者\n\n![20221130112341](/assets/20221130112341.webp)\n\n## 运行时\n\n- wasmtime 可以被独立作为 CLI 命令行工具进行使用，或者是被嵌入到其他的应用程序或系统中 可以被应用到IoT 与云原生领域\n- WAMR 基于 C 语言开发，更倾向于被应用在诸如 IoT、嵌入式芯片等对功耗和硬件资源要求较为严格的 Wasm 场景中\n- Wasmer 提供了对多达数十种编程语言的 Wasm 运行时绑定支持\n- WasmEdge \n\n## 编译\n\n利用 LLVM 的能力，可以将许多语言的源代码先转为 LLVM 的中间产物，通过LLVM的llc 编译为 WASM\n","metadata":"","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2022-11-30T17:06:22+08:00","author":"cjiping","message":"✏️wasm","hash":"cc344486ece0f3518cdde17a00184b55d790ceed"},{"date":"2022-11-29T15:20:34+08:00","author":"cjiping","message":"✏️wasm","hash":"f1c153f8751648af2f91f80486f9b0d46d2013b0"},{"date":"2022-11-28T15:06:25+08:00","author":"cjiping","message":"➕wasm","hash":"45403fd551cc1f5954ad883c6977e3da2c98a49f"}],"createTime":"2022-11-28T15:06:25+08:00"}