{"name":"python","id":"编程语言-python","content":"# Python\n\n## 数据类型\n\n- 整数型\n- 浮点型\n- 字符串\n- 布尔型\n- None\n\n### 数据结构\n\n#### 列表\n\n```python\n# 列表中的元素可以是任意类型的\nlist = [1,'2',3.0]\n# 通过下标来获取/修改元素\nlist[0]='a'\nprint(list[0])\n# 通过len函数来获取列表长度\nprint(len(list))\n# 通过list的append函数来添加元素\nlist.append('xx')\n# 查看元素在列表中的下标\nprint(list.index(3.0))\n# 查看元素是否在列表中\nprint('2' in list)\n# 统计列表中某元素的数量\nprint(list.count(1))\n# 向某位置插入元素,如果提供的下标超出列表的大小，会插在最后\nlist.insert(0,'x')\n# 添加一个列表\nlist.extend([5,5,5])\n# 根据下标删除元素并返回\nx = list.pop(0)\n# 直接删除指定下标位置的元素\ndel list[0]\n# 删除并返回最后一个元素\nx = list.pop()\n# 直接删除元素\nlist.remove('2')\n# 反转列表\nlist.reverse()\n# 排序\nlist.sort()\n# 清空列表\nlist.clear()\n```\n\n#### 元组\n\n元组创建完成后，便不能向其中添加元素，也不能修改和删除其中的任何一个元素\n\n```python\n# 空元祖\nitems = ()\n# 一个元素的元组，需要在最后加一个(,)，如果括号中只有一个元素，那么 Python 会将这个括号当作优先级符号进行处理\nitems=(1,)\n# 多个元素的元组\nitems=(1,2,3)\n# 获取元素\nprint(items[2])\n# 获取下标\nprint(items.index(2))\n# 是否存在\nprint(2 in items)\n# 统计元素个数\nprint(items.count(1))\n```\n\n#### 字符串\n\n字符串是字符的有序序列，所以也具有索引。也可以根据索引取出其中某一个字符\n\n```python\nprint('cxk'[2])\n# 字符串是不可变的，所以不能通过下标修改\n# 'cxk'[2]='b'\n# 同样可以用len获取长度\nprint(len('cxk'))\nstr = 'java language'\n# 查找子串\nprint(str.find('ang'))\n# 判断子串\nprint('ava' in str)\n# 统计子串数\nprint(str.count('a'))\n# 是否以某子串开头\nprint(str.startswith('ja'))\n# 是否以某子串结尾\nprint(str.endswith('ge'))\n# 字符串替换\nprint(str.replace('java','python'))\n# 去除字符串前后空白字符\nprint(str.strip())\n# 分割字符串，返回list\nprint(str.split(' '))\n# 拼接字符串\nprint(str.join(['so','good']))\n# 转成大写形式\nprint(str.upper())\n# 转成小写形式\nprint(str.lower())\n```\n\n- 字符转义\n\n常用的转义字符 | 含义\n------- | --------\n`\\'`    | 单引号\n`\\\"`    | 双引号\n`\\\\`    | 反斜杠\n`\\n`    | 换行符\n`\\t`    | 制表符（Tab）\n`\\r`    | 回车\n\n- 原始字符串\n\n```python\n# 原始字符串，有啥就是啥\nprint(r'java \\t no.1')\n```\n\n- 多行字符串\n\n```python\n# 多行字符串，输出的字符串不换行\nprint('java no.1\\\n    yes!\\\n    ')\n# 输出的字符串换行\nprint(\"\"\"\njava\nno.1\n\"\"\")\n```\n\n### 列表、元组、字符串的通用操作\n\n```python\n# 长度\nprint(len(str))\n# 获取子序列\nprint(str[1:10])\n# 拼接子序列\nprint(str + '?')\n# 重复序列中的元素\nprint(str*3)\n```\n\n### 字典\n\n也就是map,显著优势是可以通过键快速地查询数据\n\n```python\n# 创建空字典\nmap = {}\n# 创建有内容的字典\nmap = {'key1': 1, 'key2': 2}\n# 增加键值对/修改键所对应的值\nmap['key3'] = 3\n# 通过键获取值,若键不存在则将抛出 KeyError 异常\nprint(map['key2'])\n# 通过方法来获取，不存在返回None\nprint(map.get('key1'))\n# 不存在返回默认值0\nprint(map.get('keyx', 0))\n# 是否包含某个键\nprint('x' in map)\n# 获取所有键，返回迭代器\nprint(map.keys())\n# 获取所有值，返回迭代器\nprint(map.values())\n# 获取键值对迭代器，每一对都是元组\nprint(map.items())\n# 根据键删除,返回值，如果键不存在，则会抛出 KeyError 异常\nmap.pop('key1')\n# 键不存在返回默认值，不会抛异常\nmap.pop('key1', 'x')\n# 键不存在会抛异常\ndel map['key2']\n# 随机弹出一个键值对\nprint(map.popitem())\n# 用字典更新字典\nmap = {'key1': 'x'}\nmap.update({'key1': 1})\n```\n\n### 集合\n\n其中的元素没有顺序关系。集合中的元素没有重复，重复的元素将被自动剔除最终只留下一个，集合也是用花括号（{}）来表示，不同于字典的是，花括号中放的是一个个数据，而不是键值对\n\n```python\n# 创建空集合\ns = set()\n# 创建集合\ns = {1, 2, 3, 4, 5}\n# 添加元素\ns.add(0)\n# 并集\ns.update({7, 8, 9})\n# 查看元素是否在集合中\nprint(0 in s)\n# 弹出一个元素\nprint(s.pop())\n# 删除指定元素,如果要删除的元素不存在，则抛出 KeyError 异常\ns.remove(1)\n# 删除，但不抛出异常\ns.discard(1)\n# 求交集\nprint({1, 2, 3}.intersection({3, 4, 5}))\nprint({1, 2, 3} & {3, 4, 5})\n# 求并集\nprint({1, 2, 3}.union({3, 4, 5}))\nprint({1, 2, 3} | {3, 4, 5})\n# 求差集\nprint({1, 2, 3}.difference({3, 4, 5}))\nprint({1, 2, 3} - {3, 4, 5})\n# 是否为子集\nprint({1, 2}.issubset({1, 2, 3}))\n# 是否为超集\nprint({1, 2, 3}.issuperset({1, 2}))\n# 清空集合\ns.clear()\n```\n\n## 数值运算\n\n```python\n# 加法\nprint(33+725)\n# 减法\nprint(33-11)\n# 乘法\nprint(33*25)\n# 除法\nprint(33/22)\n# 取余\nprint(33 % 11)\n# 次方\nprint(33**2)\n# 整除\nprint(33//22)\n```\n\n## 比较运算\n\n```python\nprint(2>3)\nprint(2==3)\nprint(2<=3)\nprint(2!=3)\n```\n\n### is 与 ==\n\nis 判断的时内存地址\n\n== 会去调用类的 `__eq__` 函数来进行比较\n\n## 变量与赋值\n\n```python\na=5\n```\n\n### 值传递与引用传递\n\npython 的引用机制同 java，本质上都是值传递，无法实现类似于 c++ 的引用传递效果\n\n## 函数\n\n- 抽象\n- 代码复用\n\n### 函数定义\n\n```python\ndef sum(a,b):\n    return a+b\n```\n\n### 副作用\n\n函数包含一些会引起程序或系统状态变化的操作，如修改全局变量、命令行输入输出、读写文件等，这样的变化叫做函数的副作用\n\n### 几个内置函数\n\n```python\n# 获取终端的一个输入\nstr = input('input str')\n# 将str转为int类型\na = int(str)\n# 输出\nprint(a)\n```\n\n### python内置函数\n\n- 数据类型相关\n\n内置函数    | 功能                      | 示例                  | 示例结果\n------- | ----------------------- | ------------------- | ------------------------\ndict()  | 将参数转换为字典类型              | dict(a=1, b=2, c=3) | {'a': 1, 'b': 2, 'c': 3}\nfloat() | 将字符串或数字转换为浮点型           | float('0.22')       | 0.22\nint()   | 将字符串或数字转换为整数型           | int(1.23)           | 1\nlist()  | 将元组、字符串等可迭代对象转换为列表      | list('abc')         | ['a', 'b', 'c']\ntuple() | 将列表、字符串等可迭代对象转换为元组      | tuple([1, 2, 3])    | (1, 2, 3)\nset()   | 1.创建空集合；2.将可迭代对象转换为列表集合 | set('abc')          | {'b', 'a', 'c'}\nstr()   | 将参数转换为字符串               | str(3.14)           | '3.14'\nbytes() | 将参数转换为字节序列              | bytes(4)            | b'\\x00\\x00\\x00\\x00\n\n- 数值计算相关\n\n内置函数    | 功能      | 示例                        | 示例结果\n------- | ------- | ------------------------- | ----------------------\nmax()   | 求最大值    | max([13, 2, 0.6, -51, 7]) | 13\nmin()   | 求最小值    | min([13, 2, 0.6, -51, 7]) | -51\nsum()   | 求和      | sum([13, 2, 0.6, -51, 7]) | -28.4\nabs()   | 求绝对值    | abs(-51)                  | 51\npow()   | 求次方     | pow(2, 10)                | 1024\nbin()   | 转换为二进制  | bin(77)                   | '0b1001101' （注意结果为字符串）\nhex()   | 转换为十六进制 | hex(77)                   | '0x4d' （注意结果为字符串）\nround() | 浮点数四舍五入 | round(4.5678, 2)          | （第二个参数为小数精度） 4.57\n\n- bool 值判断相关\n\n内置函数   | 功能\n------ | -------------------------------------------------------------------------\nbool() | 判断参数是否为真，为真则返回 True，否则返回 False。「为真」指的是，表达式的结果为布尔值 True，或非零数字，或非空字符串，或非空列表\nall()  | 如果可迭代对象中的所有值，在逐一应用 bool(值) 后结果都为 True，则返回 True，否则返回 False\nany()  | 如果可迭代对象中的任意一个或多个值，在应用 bool(值) 后结果为 True，则返回 True，否则返回 False\n\n- IO 相关\n\n内置函数    | 功能\n------- | --------------------\ninput() | 从标准输入中读取字符串\nprint() | 将内容写入标准输出中\nopen()  | 打开一个文件。之后便可以对文件做读写操作\n\n- 元数据相关\n\n内置函数         | 功能\n------------ | ------------------------------------------------\ntype()       | 获取对象的类型\nisinstance() | 判断对象是否是某个类（或其子类）的对象\ndir()        | 获取类或对象中的所有方法和属性；无参数时获取当前作用域下的所有名字\nid()         | 返回一个对象的唯一标识。在我们所使用的 CPython 中这个唯一标识实际为该对象在内存中的地址\n\n- help\n\n```py\n# 得到有关int函数的相关信息\nhelp(int)\n```\n\n- sorted\n\n```py\n# 排序\nprint(sorted([3,5,7,1]))\n```\n\n- range\n\n```py\n# 获取一个整数序列\nprint(range(100))\n```\n\n### 函数进阶\n\n- 参数默认值\n\n```py\n# 如果省略a，则a的默认值为10\ndef f(a=10):\n    print(a)\n```\n\n- 关键字参数\n\n```py\ndef f(x,y):\n    print(x)\n    print(y)\n# 这里通过指定参数名，可以颠倒参数的顺序\nf(y=1,x=2)\n```\n```py\n# 使用这种方式，kw能把接收到参数组合成一个map\ndef f(**kw):\n    print(kw)\n    \nf(x=1,y=2,z=3)\n```\n\n- 任意参数列表\n\n```py\n# 类似于java的可变参数\ndef f(*kw):\n    print(kw)\n    \nf(1,2,3)\n```\n\n- 多返回值\n\n```py\ndef f():\n    x=1\n    y=2\n    return x,y\n    \na,b=f()\n```\n\n## 逻辑关键字\n\n- and\n- or\n- not\n\n## 分支语句\n\n需要注意的是，python使用的缩进来代表c/java中的花括号\n\n```python\nif a<18:\n    print('未成年')\nelif a>=18 and a<=20:\n    print('还年轻')\nelse:\n    print('成年')\n```\n\n## 循环语句\n\n- while循环\n\n```python\nwhile a>=0:\n    print(a)\n    a = a-1\n```\n\n- for循环\n\n```python\nlist = [1,2,3]\nfor i in list:\n    print(i)\n```\n\n## 错误处理与异常机制\n\n### 异常捕获\n\n```python\n# 捕获所有异常\ntry:\n    b=a/0\nexcept:\n    print('catch exception')\n# 捕获某个异常\ntry:\n    b=a/0\nexcept ZeroDivisionError as e:\n    print('catch exception:',e)\n# 捕获多个异常\ntry:\n    b=a/0\nexcept (ZeroDivisionError,IndexError) as e:\n    print('catch exception:',e)\n# 增加finally语句，finally语句无论是否发生异常都会执行\ntry:\n    b=a/0\nexcept:\n    print('catch exception')\nfinally:\n    print(\"finally\")\n```\n\npython常见的内置异常\n\n异常名               | 含义\n----------------- | ---------------\nException         | 大多数异常的基类\nSyntaxError       | 无效语法\nNameError         | 名字（变量、函数、类等）不存在\nValueError        | 不合适的值\nIndexError        | 索引超过范围\nImportError       | 模块不存在\nIOError           | I/O 相关错误\nTypeError         | 不合适的类型\nAttributeError    | 属性不存在\nKeyError          | 字典的键值不存在\nZeroDivisionError | 除法中被除数为 0\n\n### 抛出异常\n\n```python\ntry:\n    raise ValueError(\"参数错误\")\nexcept ValueError as e:\n    print('catch exception:',e)\n```\n\n## 面向对象\n\n### 查看数据类型\n\n```python\nprint(type(''))\n```\n\n### 类的定义\n\n```python\nclass Person:\n    pass # pass是占位符\n```\n\n### 实例化\n\n```python\np = Person()\n```\n\n### 属性\n\n```python\nclass Person:\n    # 增加构造器参数,self，定义时必须有这个参数，但是调用时不必传递，等同于this\n    def __init__(self,firstName,lastName):\n        self.firstName = firstName\n        self.lastName = lastName\n# 创建对象时传入参数\np = Person('c','xk')\n# 访问属性\nprint(p.firstName)\n```\n\n### 方法\n\n```python\nclass Person:\n    # 省略...\n    def say(self):\n        print(self.firstName+self.lastName)\n# 调用方法\np.say()\n```\n\n### 进阶\n\n- 类属性与类方法\n\n```py\nclass Person:\n    # 定义一个类变量\n    people = '70亿'\n    # 定义一个类方法\n    @classmethod\n    def go(klass):\n        print(str(klass)+'go')\n# 使用\nprint(Person.people)\nPerson.go()\n```\n\n- 静态方法\n\n```py\nclass Person:\n    ...\n    # 定义一个静态方法，区别在于不用传入klass\n    @staticmethod\n    def go0():\n        print('static go')\n```\n\n- 私有属性\n\n```py\nclass Person:\n    # 定义一个类私有属性\n    __people = '70'\n    @classmethod\n    def f(klass):\n        print(Person.__people)\n    def f1(self):\n        # 私有成员变量\n        self.__age=15\n        return self.__age\n\nPerson.f()\np = Person()\nprint(p.f1())\n# 会抛异常\np.__age\n# 会抛出异常\nprint(Person._people)\n```\n\n- 特殊方法\n\n头尾有双下划线的方法都是特殊方法\n\n`__init__()`用于对象的初始化。在实例化类的过程中，被自动调用,就是构造器\n\n`__next__()` 对迭代器调用 next() 函数，便能生成下一个值。这个过程的背后，next() 调用了迭代器的 `__next__()` 方法\n\n`__len__()` 实现了 `__len__()` 方法，调用 len() 函数时将自动调用容器的` __len__() `方法\n\n`__str__() ` 在使用 print() 函数时将自动调用类的 `__str__()` 方法,toString()\n\n`__getitem__()` 'abc'[2] 即等同于 'abc'.`__getitem__(2)`\n\n- 类继承\n\n```py\nclass Animal:\n    def run(self):\n        print('animal run')\n\nclass Dog(Animal):\n    def __init__(self):\n        # 调用父类的构造器\n        super().__init__()\n    # 覆写父类的方法\n    def run(self):\n        print('dog run')\n    def bark(self):\n        print('wolf wolf')\ndog = Dog()\ndog.run()\ndog.bark()\n```\n\n- 多继承\n\n```py\nclass MachineDog:\n    def kill(self):\n        print('machine dog kill you')\nclass Dog(Animal):\n   ...\nclass KillingMachineDog(Dog,MachineDog):\n    pass\nsuperDog = KillingMachineDog()\nsuperDog.bark()\nsuperDog.kill()\n```\n\n## 模块和包\n\n### 模块的导入\n\n```python\n# 导入模块\nimport random\n# 使用模块\nprint(random.randint(1,9))\n```\n\n### 包\n\n```\n/\n├── main.py\n├── 模块1.py\n├── 模块2.py\n├── 子包1/\n    ├── __init__.py\n    ├── 模块3.py\n    └── 模块4.py\n└── 子包2/\n    ├── __init__.py\n    ├── 模块5.py\n    └── 孙子包1/\n        ├── __init__.py\n        └── 模块6.py\n```\n\n包的导入\n\n```python\nimport 子包1.模块3.py\nfrom 子包1.模块3 import *\n```\n\n`__init__.py` 在 python3 中不是必须的\n\n## 迭代器\n\n迭代指的是通过重复执行某个操作，不断获取被迭代对象中的数据。这样的每一次操作就是就是一次 **迭代**\n\n迭代器可以提供迭代功能，当我们需要逐一获取数据集合中的数据时，使用迭代器可以达成这个目的\n\n迭代器可以不保存数据，它的数据可以在需要时被计算出来（这一特性也叫做惰性计算）\n\n```py\n# 将容器包装成一个迭代器\niterator = iter([1,2,3,4])\n# 不断迭代，直至迭代完抛出异常\nwhile True:\n    print(next(iterator))\n```\n\npython的for循环迭代就是通过使用迭代器完成的\n\n- 对一个容器调用 iter() 函数，获取到该容器的迭代器\n- 每次循环时对迭代器调用 next() 函数，以获取一个值\n- 若捕获到 StopIteration 异常则结束循环\n\n### 可迭代\n\n定义了 `__iter__()` 方法的类对象就是可迭代的。当这个类对象被 iter() 函数使用时，将返回一个迭代器对象\n\n### 自定义迭代器\n\n```py\nclass MyIterator:\n    # 定义了这个方法就代表是可迭代的\n    def __iter__(self):\n        self.count=0\n        return self\n    # 实现可迭代对象的接口\n    def __next__(self):\n        self.count = self.count+1\n        return self.count\n# 使用\ni = MyIterator()\nfor i in i:\n    print(i)\n```\n\n## 生成器\n\nyield 语句的作用和 return 语句有几分相似，都可以将结果返回。不同在于，生成器函数执行至 yield 语句，返回结果的同时记录下函数内的状态，下次执行这个生成器函数，将从上次退出的位置（yield 的下一句代码）继续执行\n\n```py\n# 另外一种定义迭代器的方式\ndef f():\n    for i in range(10):\n        yield i\n\n# 使用\ni = f()\nfor j in i:\n    print(j)\n```\n\n### 生成器表达式\n\n```py\n生成器 = (针对项的操作 for 项 in 可迭代对象)\n```\n\n```py\n# 输出0-9每个数的平方\nfor i in (j**2 for j in range(10)):\n    print(i)\n```\n\n也可以加上if语句\n\n```py\n# 输出0-100中偶数的平方\nfor i in (j**2 for j in range(100) if j%2==0):\n    print(i)\n```\n\n### 字典生成式\n\n```py\n{键: 值 for 项 in 可迭代对象}\n```\n\n```py\n# 生成0-10的键为i，值为i的平方的map\nmap = {i:i**2 for i in range(10)}\n```\n\n### 集合生成式\n\n```py\n# 生成0-10的集合\nset = {i for i in range(10)}\n```\n\n## 协程\n\n```py\nimport asyncio\nasync def web():\n  return requests.get('http://baidu.com').text\n\nasync def main():\n  print(await web())\n\nasyncio.run(main())\n```\n\nasyncio 的原理是维护一个 eventloop，每次遍历协程任务，当协程任务让出控制权，eventloop会继续遍历其他协程任务\n\n## future\n\n```py\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n  fut = executor.submit(web)\n  while not fut.done():\n    continue\n  print(fut.result())\n```\n\n## 函数式编程\n\n```py\ndef say():\n    print('say')\n# 函数可赋值给变量并调用\nf = say\nf()\n```\n\n### 函数作为参数\n\n```py\ndef f(callback):\n    callback('date')\ndef f1(x):\n    print(x)\n\nf(f1)\n```\n\n### lambda表达式\n\n```py\n# 上面的函数调用也可以缩写成\nf(lambda x: print(x))\n```\n\n### 函数作为返回值\n\n```py\ndef f():\n    return lambda x,y: x+y\n\nprint(f()(1,2))\n```\n\n### map与filter\n\n```py\n# filter函数可对一个可迭代对象做过滤，符合过滤lambda的元素会被返回\nl = filter(lambda x: x%2==0,[1,2,3,4,5])\nprint(list(l))\n```\n\n```py\nl = [1,2,3,4,5]\n# map函数则是对可迭代对象中的每个元素做处理，然后返回\nret = map(lambda x: x**2,l)\nprint(list(ret))\n```\n\n## 装饰器\n\n### 自定义装饰器\n\n```py\ndef aop(fun):\n    # 对fun进行包装，在其外层拦截参数\n    def wrapper(*args,**kw):\n        print(\"aop拦截参数:\",args[1],kw)\n        fun(*args,**kw)\n    return wrapper\n\nclass A:\n    # 加上这一行等于 m = aop(m)\n    @aop\n    def m(self, name):\n        print('method invoke ' + name)\n\na = A()\na.m('a')\n# 输出\n# aop拦截参数: a {}\n# method invokea\n```\n\n## 一些语言特性\n\n### 切片\n\n```py\nl = [1,2,3,4,5]\n# 负数代表倒数第几个\nprint(l[-2])\n# 起始索引跟结束索引默认不写就代表是第一个/最后一个\nprint(l[:])\n# 代表从0到最后一个，步长为2取一个元素\nprint(l[0:-1:2])\n```\n\n### 赋值\n\n```py\n# 连续赋值\na = b = c = 1\n# 拆包\nx, y = 1, 2\n# 拆包一次接收多个元素\nx, *y = 1, 2, 3, 4\n# 交换两个元素\nx, y = y, x\n# or的使用\nprint('' or '1') # 结果为'1' 类似于js\n```\n\n### 控制语句\n\n```py\n# 三元表达式\n# 如果1=1,ret=1 否则ret=2\nret = 1 if 1==1 else 2\n# for...else\n# 如果可迭代对象全部都被迭代了，就会执行else语句，否则不执行else语句，while...else同理\nfor i in range(5):\n    print(i)\nelse:\n    print('all used')\n# try except else,没有发生异常时，else语句会被调用\ntry:\n    pass\nexcept:\n    print('发生异常')\nelse:\n    print('没有发生异常')\n```\n\n### 类\n\n```py\n# 自定义异常\nclass BussinessException(Exception):\n    pass\n```\n\n### 函数\n\n```py\n#     参数类型标注   返回值类型标注\ndef f(name:str) -> str:\n    return 'hello'\n```\n\n### metaclass\n\n通过在创建类时指定 metaclass，可以控制类的创建过程\n\n```py\n\nclass Mymeta(type):\n    def __init__(self, name, bases, dic):\n        # 当 Foo 创建时，会进入到这里\n        super().__init__(name, bases, dic)\n        print('===>Mymeta.__init__')\n        print(self.__name__)\n        print(dic)\n        print(self.yaml_tag)\n    \nclass Foo(metaclass=Mymeta):\n    yaml_tag = '!Foo'\n\n    def __init__(self, name):\n        print('Foo.__init__')\n        self.name = name\n\nfoo = Foo('foo')\n```\n\n## IO\n\n### 打开文件\n\n```py\nf = open('test.py','r')\n# 指定编码\nf = open('test.py','r',encoding='gbk')\n```\n\n**读写模式**\n\n'r'：只读，若文件不存在则抛出 FileNotFoundError 异常\n'rb': 以二进制的形式\n'w'：只写，将覆盖所有原有内容，若文件不存在则创建文件\n'a'：只写，以追加的形式写入内容，若文件不存在则创建文件\n'r+'：可读可写，若文件不存在则抛出 FileNotFoundError 异常\n'w+'：可读可写，若文件不存在则创建文件\n'a+'：可读可写，写入时使用追加模式，若文件不存在则创建文件\n\n### 文件写入\n\n```py\nf = open('a.txt','w')\nf.write('a dog')\n```\n\n### 文件读取\n\n```py\nf = open('test.py','r',encoding='utf8')\n# 读出全部内容\nprint(f.read())\n# 读出文件行的列表\nprint(f.readlines())\n```\n\n### 文件关闭\n\n```py\nf.close()\n```\n\n### 文件系统操作\n\n```py\nimport os\n# 创建目录\nos.mkdir('./test')\n# 枚举目录下的文件\nfor i in os.listdir('./'):\n    print(i)\n# 删除目录\nos.rmdir('./test')\n# 删除文件\nos.remove('a.txt')\n# 重命名文件\nos.rename('test.py','test1.py')\n```\n\n### 上下文管理器\n\nPython 的 with 语句，类似于 Java 的 try(...)，在离开作用域后会自动释放资源\n\n在被创建时，首先会调用`__init__` 方法，然后会调用 `__enter__` 方法，由 `__enter__` 方法返回需要被管理的对象，在离开作用域时，会调用 `__exit__` 方法\n\n## 全局解释锁\n\n为了实现多线程下内存管理（尤其是垃圾回收机制）的线程安全，同时 Python 通过引用计数来管理对象的生命周期，但引用计数在多线程环境中容易引发竞争条件（race conditions）。GIL 可以确保引用计数的操作是原子性的，从而避免这些竞争条件\n\nCPython大量使用C语言库，但大部分C语言库都不是线程安全的\n\n## 垃圾回收\n\nPython 将所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收\n\n为了解决引用计数在发生循环引用无法回收的问题，Python 引入了一个基于跟踪的垃圾收集器 gc.collect()，其原理是通过图搜索来发现不可达的对象\n\n## 序列化\n\n- pickle(python独有)\n\n```py\nimport pickle\n\n# 序列化成二进制\nret = pickle.dumps([1,2,3])\nprint(ret)\n# 反序列化\nprint(pickle.loads(ret))\n```\n\n- json\n\n```py\nimport json\n# 序列化成json\nstr = json.dumps({'a':1,'b':2})\nprint(str)\n# 反序列化\nprint(json.loads(str))\n```\n\n## 进程与线程\n\n### 进程\n\n```py\nimport multiprocessing\nimport os\ndef f():\n    print('子进程')\n    print('pid',os.getpid())\n    print('ppid',os.getppid())\n\n# 只有主进程才创建子进程\nif __name__ == '__main__':\n    # 创建一个子进程\n    p = multiprocessing.Process(target=f)\n    p.start()\n    # 等待子线程运行完毕才会继续往下走\n    p.join()\n```\n\n### 线程\n\n```py\nimport threading\n\ndef f():\n    print('sub thread')\n\n# 创建线程并启动\nt = threading.Thread(target=f)\nt.start()\n# 等待子线程执行完毕才继续往下执行\nt.join()\nprint('main thread')\n```\n\n- 锁\n\n```py\nimport threading\ncount = 0\n# 创建一个锁\nlock = threading.Lock()\ndef add():\n    for i in range(2000000):\n        global count\n        # 获取锁\n        lock.acquire()\n        count = count+1\n        # 释放锁\n        lock.release()\n    print('执行完成：当前结果:',count)\nfor i in range(10):\n    threading.Thread(target=add).start()\n```\n\n## 安装第三方包\n\n```js\npip install requests --user\n```\n\n## pbd\n\n```py\nimport pdb\n\na = 1\npdb.set_trace() # 在此处暂停后可以执行一些 pbd 的脚本 比如输出变量、修改变量、跳转代码等\nprint(a)\n```\n\n## cProfile\n\n使用 cProfile 可以统计代码运行的性能\n\n```py\nimport cProfile\n# def fib(n)\n# def fib_seq(n):\ncProfile.run('fib_seq(30)')\n```\n\n```text\n         7049218 function calls (96 primitive calls) in 12.151 seconds\n\n   Ordered by: standard name\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        1    0.000    0.000   12.151   12.151 <string>:1(<module>)\n7049123/31   12.151    0.000   12.151    0.392 main.py:1(fib)\n     31/1    0.000    0.000   12.151   12.151 main.py:9(fib_seq)\n        1    0.000    0.000   12.151   12.151 {built-in method builtins.exec}\n       31    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n       30    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}\n```\n\n## python编码风格\n\n### 变量和函数\n\n「全小写+下划线」\n\n```py\nmax_capacity = 10\n```\n\n### 类名\n\n「驼峰写法」\n\n```py\nclass CodeGenerator:\n    pass\n```\n\n### 异常名\n\n「驼峰写法」\n\n```py\nValueError\n```\n\n### 常量\n\n「全大写+下划线」\n\n```py\nMAX_VALUE=100\n```\n\n### 模块名和包名\n\n模块可使用「小写 + 下划线」\n\n```py\nopen_api\n```\n\n包名仅使用小写字母命名\n\n```py\nrequests\n```\n\n### 缩进\n\n每级缩进应使用 4 个空格\n\n### 换行\n\n每行代码的最大字符数为 79。若某一行代码过长，可以将其换行书写\n\n定义函数和类时，多个函数或类之间使用两个空行进行分隔\n\n### 导入\n\nimport 按下列类型和顺序使用：\n\n- 标准库导入\n- 第三方库导入\n- 本地库导入\n\n### 注释\n\n注释以 # 及一个空格开始\n行内注释和代码间至少要有两个空格分隔","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2024-07-22T14:36:31+08:00","author":"MY","message":"✏Python","hash":"bbf034e20a60f145b6190dca1b44788ade1e8846"},{"date":"2024-07-17T20:12:15+08:00","author":"MY","message":"✏Python","hash":"e97158f5a4b3aa3d04bed6b8e37cd93874a60439"},{"date":"2024-07-16T19:52:49+08:00","author":"MY","message":"✏Python","hash":"fbd534606f7b6ff4a737538b3d7d00a0f4d1ff2b"},{"date":"2020-02-29T12:47:26+08:00","author":"MY","message":"增加python编码风格","hash":"7dd1122c78ac727f9ed2b177115dbfbcabcb3918"},{"date":"2020-02-27T10:20:10+08:00","author":"MY","message":"更新python io 进程与线程","hash":"e0da1dc0b1c3fd595d0e819db0663cb6eccffa09"},{"date":"2020-02-25T20:00:15+08:00","author":"MY","message":"python 增加 函数式编程...一些语言特性","hash":"4991df1aba129db812ddc6880e24f7af9521000a"},{"date":"2020-02-24T18:43:12+08:00","author":"MY","message":"更新python ...多继承","hash":"a26fe728ea7d74d579f9505177938ca4f5026a21"},{"date":"2020-02-23T13:44:26+08:00","author":"MY","message":"增加迭代器与生成器","hash":"18c55506e30c04f7792715b3e7685d4afa118dfb"},{"date":"2020-02-23T12:05:03+08:00","author":"MY","message":"python增加内置函数","hash":"af3bbc933cf0d3711afc6440384557a300d10018"},{"date":"2020-02-23T11:32:27+08:00","author":"MY","message":"python增加map与set数据结构","hash":"d4ea81849446e8aa5151a42c4a41b473d92b12ed"}],"createTime":"2020-02-21T19:00:57+08:00"}