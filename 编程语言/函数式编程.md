# 函数式编程

数式语言提倡在有限的几种关键数据结构（如 list 、 set 、 map ）上运用针对这些数据结构高度优化过的操作，以此构成基本的运转机构以达到重用的目的。

- 命令式编程是按照“程序是一系列改变状态的命令”来建模的一种编程风格
- 函数式编程将程序描述为表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态 一种更高层次的抽象

函数式思维的好处之一，是能够将低层次细节（如垃圾收集）的控制权移交给运行时，从而消弭了一大批注定会发生的程序错误

函数式编程几大基本操作：

- filter 过滤

![屏幕截图 2021-05-10 152401](/assets/屏幕截图%202021-05-10%20152401.png)

- map 映射

![屏幕截图 2021-05-10 152429](/assets/屏幕截图%202021-05-10%20152429.png)

- reduce/fold 规约/折叠 用一个累积量（accumulator）来“收集”集合元素

![屏幕截图 2021-05-10 152800](/assets/屏幕截图%202021-05-10%20152800.png)

函数式语言将一些权责让位于运行时：

1. 底层迭代的权责转移到高阶函数 map filter ...
2. 状态管理的权责转移到闭包 让语言自己去管理状态
3. 柯里化
  - 函数 process(x, y, z) 完全柯里化之后将变成 process(x)(y)(z) 的形式
4. 部分施用  
  -  process(x, y, z) 上部分施用一个参数，那么我们将得到还剩下两个参数的函数： process(y, z)

从迭代到递归：

![屏幕截图 2021-05-11 104506](/assets/屏幕截图%202021-05-11%20104506.png)

![屏幕截图 2021-05-11 104525](/assets/屏幕截图%202021-05-11%20104525.png)

尾递归：

```js
function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}
function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}
```
