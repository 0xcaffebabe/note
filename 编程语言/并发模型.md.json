{"name":"并发模型","id":"编程语言-并发模型","content":"# 并发模型\n\n并发编程可以抽象为：\n\n- 分工\n- 同步\n- 互斥\n\n```mermaid\nstateDiagram-v2\n  state 并发模型 {\n    性能需求 --> 并发产生: 促使\n    并发产生 --> 并发问题: 导致\n    并发产生 --> 任务编排: 需要\n    互斥 --> 并发问题: 解决\n    互斥 --> 无锁并发: 更高的性能需求\n    同步 --> 任务编排: 解决\n  }\n```\n\n- 并发与并行\n\n并行架构：\n\n- bit-level并行：从32位到64位\n- 指令级并行：流水线技术、乱序执行\n- 数据级并行：GPU的几百个核心并行对图像处理\n- 任务级并行：多处理机系统\n\n## 线程与锁\n\n该模型是对底层硬件运行过程的形式化 适用面很广\n\n没有为并行提供直接的支持\n\n- 竞态条件\n- 内存可见性\n- 死锁\n\n## 函数式编程\n\n- 可变状态造成的风险\n\n函数式代码可以随意改变其执行顺序 所以可以让相互独立的函数并行执行\n\n## 协程\n\n## Actor\n\n```mermaid\ngraph TD\n    subgraph Thread\n        subgraph Actor\n            数据[\"数据\"]\n            行为[\"行为\"]\n        end\n        mailbox[\"mailbox\"]\n        Actor --> mailbox\n    end\n\n```\n\n- 保留了可变状态 只是不共享（每个Actor只存在于属于自己的线程内）\n- 单条不可变消息传输（使用mailbox）\n- Actor之间通过消息交互\n- 任其崩溃\n- 天生分布式\n\n```\nActor 是一种基础的计算单元，包含三种能力：\n\n- 处理能力，处理接收到的消息\n- 存储能力，Actor 可以存储自己的内部状态，并且内部状态在不同 Actor 之间是绝对隔离的\n- 通信能力，Actor 可以和其他 Actor 之间通信\n一个 Actor 接收的一条消息之后，这个 Actor 可以做以下三件事：\n1. 创建更多的 Actor\n2. 发消息给其他 Actor\n3. 确定如何处理下一条消息。\n```\n\n### 操作\n\n#### Create\n\n父Actor创建管理子Actor，父Actor需要决定子Actor崩溃时采取的措施\n\n![ASctor树](/assets/屏幕截图%202021-11-30%20220253.png)\n\n#### Send\n\n- 发送消息\n\n#### Become\n\n- 状态机\n\n## 软件事务内存\n\n借鉴数据库事务，借助 MVCC 等思想，使得能在编程语言层支持 ACI 三种特性，但由于诸如 IO 等操作无法回滚，所以这种模型应用是有局限性的\n\n```java\nclass Account{\n  //余额\n  private TxnLong balance;\n  //构造函数\n  public Account(long balance){\n    this.balance = StmUtils.newTxnLong(balance);\n  }\n  //转账\n  public void transfer(Account to, int amt){\n    //原子化操作\n    atomic(()->{\n      if (this.balance.get() > amt) {\n        this.balance.decrement(amt);\n        to.balance.increment(amt);\n      }\n    });\n  }\n}\n```\n\n## 通信顺序进程（CSP）\n\n解决了 Actor 模型之间无法共享内存的问题，比如 Go 引入了一个 channel，实现了一个生产者消费者的阻塞通信模型，相较于 Actor 的 mailbox 明确归属于一个特定的 Actor，是 Actor 模型中的内部机制，而 channel 则是 Actor 之间共用的。第二个区别是 Actor 模型中发送消息是非阻塞的，而 CSP 模型中是阻塞的\n\n## 数据并行\n\n- opencl\n\n![屏幕截图 2020-12-31 160516](/assets/屏幕截图%202020-12-31%20160516.png)\n\n## Lambda架构\n\n## 并发编程设计模式\n\n### 单线程执行模式（Single Threaded Execution）\n\n- 临界区\n\n通过对代码块进行同步，使之同一时刻只能有一个线程执行，以此确保安全性\n\n### 不可变模式（Immutable）\n\n将对象的所有状态设计成无法变化就可以确保安全性。\n\n达到这个目的的常用手段有final修饰类、变量以及不暴露相关修改状态的接口。\n\n不可变模式所有的修改操作都创建一个新的不可变对象，可以通过享元模式避免创建重复对象提升性能\n\n### 写时复制模式（Copy on Write）\n\n在真正需要复制的时候才复制出一份数据的副本，最大的应用领域在函数式编程，为了减少每次 Write 的性能损耗，Write 可以不 Write 全部，而是只 Write 一部分\n\n### 守卫暂停模式（Guarded Suspension）\n\n本质上是一种等待唤醒机制的实现，通过让线程进行等待来保证对象实例的安全性，只有当状态满足某个条件时，等待的线程才能解除阻塞\n\n锁获取 阻塞队列等都是属于这种模式\n\n等待可以通过Object.wait方法 获取也可以使用自旋锁的忙等待\n\n### Balking\n\n通过维护一个守护条件，当守护条件不满足时，将直接返回，后续的所有操作放弃，值得注意的是这个守护条件要保证内存可见性\n\n与守卫暂停模式的区别在守卫暂停会一直等待守护条件成立，而Balking当不成立时就放弃\n\n在这两者之间可以存在一种等待一段时间放弃的做法，叫做超时\n\n### 生产者-消费者模式（Prdocer-Consumer）\n\n通过加入一个中间层，来消除数据生产者与获取者之间的速度差异带来的安全问题，同时也能支持异步及批量以提升性能\n\n平衡问题：数据不堆积、不浪费消费者资源 调度算法\n\n事件驱动架构关注的是事件触发、传递整体流程 生产者消费者关注的数据的传递与存储处理具体流程\n\n三个角色：\n\n1. 生产者：系统运转的动力来源 重点关注发送数据到容器 与消费者彻底解耦。需要考虑的一些问题：发送确认、重试机制、同步异步、序列化、异常处理\n2. 消费者：所做的事是获取数据，进行处理，同时向容器确认数据被消费。需要考虑的一些问题\n   - 消费方式 poll push\n   - 分发方式 queue topic\n   - 消费策略\n   - 消费幂等性\n   - 反序列化\n   - 多消费者\n     - 复制\n     - 非复制\n3. 容器：存储生产者发送的数据，同时为消费者提供数据获取服务。需要考虑的一些问题\n   - 存多久（时效性） 存哪里\n   - 如何调度数据给消费者\n   - [消费可靠性](/中间件/消息队列/消息队列.md#可靠性)\n     - at least once\n     - at most once\n     - exactly once\n   - 传送的数据单元：数据单元是传输的最小单位，可以理解为消息。应该具备业务含义、传输过程保证数据单元完整性、尽量保证单元之间无依赖\n\n**优点**\n\n- 三者之间低耦合、异步\n- 天生可以分布式\n- 协调生产与消费速度不一致\n- 生产数据与消费数据的分离\n\n**缺点**\n\n多线程异步的模式会带来编程与调试的复杂性，同时同步机制也会带来一定的性能开销\n\n### 读写锁模式（Read-Write Lock）\n\n数据并发读写没有问题，但要想修改它只能有一个线程，并且没有其他线程进行读操作\n\n适合读多写少的场景，可以有效提升性能\n\n### 每消息一线程模式（Thread-Per-Message）\n\n为每个任务分配一个独立的线程。这是一种最简单的分工方法，实现起来也非常简单\n\n传统的socket编程就采用的这种方式 一个请求进来 开启一个新线程来处理\n\n但创建线程是一个重量级的操作，引入协程可以避免创建线程的大量开销\n\n### 工作线程模式（Worker Thread）\n\n为了解决每消息一线程频繁开启新新线程带来的开销，通过维护几个工作线程，任务一来直接交给这些工作线程来处理\n\n线程池就属于该模式\n\n### Future模式\n\n持有一个引用 在等待结果时可以不进行阻塞\n\n### 两阶段终结模式（Tow-Phase-Termination）\n\n![屏幕截图 2021-04-02 102529](/assets/屏幕截图%202021-04-02%20102529.png)\n\n通过检查线程中断状态以及自己设计的停止标志配合使用来达到清理与提升吞吐量的目的\n\n检查标志可在进行长时间处理操作之前检查，检查标志也需要保证可见性\n\n是一种实现优雅关闭的手段\n\n```java\nvolatile stop = false\nwhile(!stop) {\n  doSomething()\n}\n\nfunc stop() {\n  this.stop = true\n}\n```\n\n### 线程特有存储模式（Thread-Specific Storage）\n\n为每个线程分配属于线程自己的存储空间 避免竞争带来的数据安全问题\n\n- 存储在线程外：ThreadLocal\n- 存储在线程内：Thread成员变量\n\n### 活跃对象模式（Active Object）\n\n- Actor模式\n\n会通过自己特有的线程在合适的时机消费外部接收到的额异步请求\n\n## Reactor 模型\n\nReactor 模型是一种处理并发服务请求的事件设计模式，当主流程收到请求后，通过多路分离处理的方式，把请求分发给相应的请求处理器处理\n\n- Reactor：负责监听和分配事件。收到事件后分派给对应的 Handler 处理，事件包括连接建立就绪、读就绪、写就绪等\n- Acceptor：负责处理客户端新连接。Reactor 接收到客户端的连接事件后，会转发给 Acceptor，Acceptor 接收客户端的连接，然后创建对应的 Handler，并向 Reactor 注册此 Handler\n- Handler：请求处理器，负责业务逻辑的处理，即业务处理线程\n\n单 Reactor 单线程模型，特点是 Reactor 和 Handler 都是单线程的串行处理：\n\n```mermaid\nstateDiagram-v2\n  client1 --> 服务端\n  client2 --> 服务端\n  client3 --> 服务端\n  state 服务端 {\n    Reactor --> Acceptor\n    Reactor --> Handler\n    state Handler {\n      read\n      write\n      process\n    }\n  }\n```\n\n单 Reactor 多线程模型，业务逻辑处理 Handler 变成了多线程：\n\n```mermaid\nstateDiagram-v2\n  client1 --> 服务端\n  client2 --> 服务端\n  client3 --> 服务端\n  state 服务端 {\n    Reactor --> Acceptor\n    Reactor --> Handler1\n    Reactor --> Handler2\n    state Handler1 {\n      read1\n      write1\n      process1\n    }\n    state Handler2 {\n      read2\n      write2\n      process2\n    }\n  }\n```\n\n主从 Reactor 多线程模型，在单 Reactor 多线程模型的基础上让 Reactor 也变成多线程：\n\n```mermaid\nstateDiagram-v2\n  client1 --> 服务端\n  client2 --> 服务端\n  client3 --> 服务端\n  state 服务端 {\n    state Acceptor {\n      Acceptor1\n      Acceptor2\n    }\n    Reactor --> Acceptor\n    Acceptor --> Reactor1\n    Acceptor --> Reactor2\n    Reactor1 --> Handler1\n    Reactor1 --> Handler2\n    Reactor2 --> Handler1\n    Reactor2 --> Handler2\n    state Handler1 {\n      read1\n      write1\n      process1\n    }\n    state Handler2 {\n      read2\n      write2\n      process2\n    }\n  }\n```\n","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2024-10-25T11:43:52+08:00","author":"MY","message":"📦架构模式","hash":"7a4552433037b568c78fb856bbb5268f027deae4"},{"date":"2024-07-29T20:00:44+08:00","author":"MY","message":"✏分布式","hash":"7ec38398a8550648031b84713613cc582d8e3e3c"},{"date":"2023-11-13T20:03:30+08:00","author":"MY","message":"✏netty","hash":"f0435a62810ce052636f6f6b0ba7750fd084c155"},{"date":"2023-09-13T19:12:08+08:00","author":"MY","message":"✏并发模型","hash":"a90edd40ad29448518d296ce954743602000faeb"},{"date":"2023-08-27T17:09:19+08:00","author":"MY","message":"✏️并发模型","hash":"48a826177040f51e14d4e1258cc53a9afca35b70"},{"date":"2023-08-20T23:16:04+08:00","author":"MY","message":"✏️并发模型","hash":"deda3c11dba4089fd0353e1506c9381779583208"},{"date":"2021-11-30T22:15:48+08:00","author":"MY","message":"✏️更新 响应式编程","hash":"93c97a09b873a425dd245600588298028a28b0b5"},{"date":"2020-12-31T16:12:50+08:00","author":"cjiping","message":"✏更新 并发模型","hash":"2b19daab73df6be776ae418e82ac579024c6c07c"},{"date":"2020-12-28T14:57:29+08:00","author":"cjiping","message":"✏更新 并发模型","hash":"1c3d4a9c933305ea3c3bac10a19fb9bfa5475f77"},{"date":"2020-12-28T10:25:13+08:00","author":"cjiping","message":"✏更新 并发模型","hash":"cd54622a3e415062ed9454440500842dcd5a2344"}],"createTime":"2020-12-25T11:01:56+08:00"}