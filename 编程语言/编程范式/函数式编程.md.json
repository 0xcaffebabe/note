{"name":"函数式编程","id":"编程语言-编程范式-函数式编程","content":"\n# 函数式编程（Functional Programming）\n\n> 函数式编程是一种**以数学函数为核心抽象**、以**不可变数据**和**无副作用计算**为基础的编程范式。\n> 它将程序视为表达式之间的组合，而非一系列修改状态的命令。\n\n---\n\n## 一、命令式 vs 函数式：两种思维模型\n\n* **命令式编程（Imperative Programming）**\n  按照“程序是一系列改变状态的命令”来建模。\n  核心是 **“怎么做”** —— 你一步步告诉计算机执行什么操作。\n\n* **函数式编程（Functional Programming）**\n  将程序描述为**表达式的组合**和**数据的变换**。\n  核心是 **“是什么”** —— 定义数据之间的映射关系，而非操作过程。\n\n> 换句话说，命令式编程像是“指挥演员演戏”，\n> 函数式编程更像是“定义剧情规则，让演员自然演绎”。\n\n---\n\n## 二、核心思想：表达式与不可变性\n\n函数式编程鼓励：\n\n* 使用表达式（expression）而非语句（statement）；\n* 数据不可变（immutable data）；\n* 无副作用（pure function）；\n* 函数为“一等公民”（First-class Function）。\n\n它把底层细节（如内存管理、状态更新）交给运行时去优化，\n开发者只需专注于描述**输入与输出的关系**。\n\n这种思维带来的最大好处是：\n\n> 控制权的上移 —— 从控制“怎么执行”，变成控制“怎么定义逻辑”。\n\n---\n\n## 三、函数式编程的三大核心操作\n\n函数式编程往往围绕几种基础操作展开（以 List / Set / Map 为核心数据结构）：\n\n### 1️⃣ filter（过滤）\n\n保留满足条件的元素：\n\n```js\n[1, 2, 3, 4, 5].filter(x => x % 2 === 0)\n// → [2, 4]\n```\n\n### 2️⃣ map（映射）\n\n将集合中的每个元素“映射”为新的值：\n\n```js\n[1, 2, 3].map(x => x * 2)\n// → [2, 4, 6]\n```\n\n### 3️⃣ reduce / fold（规约 / 折叠）\n\n通过累加器把集合折叠为单个值：\n\n```js\n[1, 2, 3, 4].reduce((acc, x) => acc + x, 0)\n// → 10\n```\n\n> filter / map / reduce 是函数式世界的“for 循环 + if + sum”三件套，\n> 用声明式的方式表达数据转换。\n\n---\n\n## 四、函数式语言的权责转移\n\n在函数式语言中，许多“命令式责任”被转移到语言运行时：\n\n1. **底层迭代 → 高阶函数**\n\n   * 用 `map`、`filter`、`reduce` 替代显式 for 循环。\n\n2. **状态管理 → 闭包与不可变变量**\n\n   * 不再维护共享变量，而是通过闭包捕获作用域。\n\n3. **参数控制 → 柯里化（Currying）**\n\n   * `process(x, y, z)` 变为 `process(x)(y)(z)`。\n     每次调用返回一个新函数，就像“逐层工厂”。\n\n4. **灵活复用 → 部分施用（Partial Application）**\n\n   * 给函数固定一部分参数，得到一个“定制版函数”：\n     `sum = add(5)` → `sum(3) = 8`。\n\n---\n\n## 五、从迭代到递归：让逻辑自洽\n\n函数式编程不鼓励显式循环，而使用递归表达重复。\n\n### 传统迭代：\n\n```js\nlet sum = 0;\nfor (let i = 1; i <= 3; i++) sum += i;\n```\n\n### 函数式递归：\n\n```js\nfunction sum(n) {\n  return n === 0 ? 0 : n + sum(n - 1);\n}\n```\n\n### 尾递归优化（Tail Recursion）\n\n尾递归允许编译器复用调用栈，避免堆栈溢出：\n\n```js\nfunction story() {\n  // 尾递归：下一次调用不依赖当前栈\n  return story(); \n}\n```\n\n与非尾递归的区别在于：\n\n> 尾递归调用后没有额外逻辑 → 可直接返回结果。\n\n---\n\n## 六、函数式语言常见特性\n\n### 1️⃣ 记忆（Memoization）\n\n缓存函数结果以避免重复计算。\n仅适用于**纯函数（Pure Function）**——即同输入、同输出、无副作用。\n\n```js\nfunction memoize(fn) {\n  const cache = {};\n  return (...args) => {\n    const key = JSON.stringify(args);\n    return cache[key] ?? (cache[key] = fn(...args));\n  };\n}\n```\n\n函数式语言通常能天然支持记忆化，如：\n\n```lisp\n(memoize (hash \"homer\"))\n```\n\n> 纯函数 + 不可变性 = 缓存安全。\n\n---\n\n### 2️⃣ 惰性求值（Lazy Evaluation）\n\n表达式不会立即求值，而是**在需要时才计算**。\n优点是节省资源、支持无限数据结构。\n\n在 Java 中，可用 `Stream` 实现：\n\n```java\nStream.of(1, 2, 3)\n      .filter(x -> x > 1)\n      .map(x -> x * 2);\n```\n\n直到 `.collect()` 执行前，上述操作都不会真正运行。\n\n---\n\n## 七、函数式的重用机制\n\n在 OOP 中，**复用的单元是类或对象**。\n在 FP 中，**复用的单元是函数**。\n\n由于函数式语言的核心数据结构少（多为 List / Map），\n重用往往通过“函数组合”完成。\n\n例如：\n\n```js\nconst pipeline = compose(\n  filter(isValid),\n  map(parse),\n  reduce(sum)\n);\n```\n\n> 这种组合模式比继承更轻量、更安全。\n\n---\n\n## 八、设计模式在函数式世界的变形\n\n在函数式语言中，许多 OOP 设计模式变得不再必要，\n因为语言特性本身已经提供了解决方案。\n\n| 面向对象模式                | 在函数式中的替代                    |\n| --------------------- | --------------------------- |\n| 模板方法（Template Method） | 高阶函数（Higher-order Function） |\n| 工厂方法（Factory）         | 部分施用 / 柯里化                  |\n| 策略模式（Strategy）        | 函数作为参数传入                    |\n| 观察者模式（Observer）       | 响应式流（Reactive Stream）       |\n\n示例：\n\n```groovy\nclass CustomerBlocks {\n  def checkCredit, checkInventory, ship\n  def process() {\n    checkCredit()\n    checkInventory()\n    ship()\n  }\n}\n```\n\n在函数式中，这等价于：\n\n```js\nconst process = compose(checkCredit, checkInventory, ship);\n```\n\n> OOP 通过“封装不确定因素”让代码易懂，\n> FP 则通过“消除不确定因素”让代码易懂。\n\n---\n\n## 九、从函数式编程到函数式基础设施\n\n函数式编程的哲学已渗透到现代架构中：\n\n| 领域                            | 函数式思想体现      |\n| ----------------------------- | ------------ |\n| **不可变值（Immutable Value）**     | 函数式的基础假设     |\n| **CQRS / Event Sourcing**     | 状态不可变、通过事件推导 |\n| **函数式 Web 编程（WebFlux, Akka）** | 无共享状态的并发     |\n| **日志数据库（如 Kafka）**            | 事件流即系统真相     |\n| **Serverless 架构**             | 函数即服务（FaaS）  |\n\n> 从“函数式编程”到“函数式基础设施”，\n> 是软件工程抽象层次的一次跃迁。\n\n---\n\n## 🔚 十、总结\n\n| 关键特性                            | 说明               |\n| ------------------------------- | ---------------- |\n| **纯函数（Pure Function）**          | 相同输入 → 相同输出，无副作用 |\n| **不可变性（Immutability）**          | 数据不可修改，只能创建新版本   |\n| **高阶函数（Higher-order Function）** | 函数可作为参数或返回值      |\n| **组合（Composition）**             | 函数间可像积木一样拼接      |\n| **惰性与记忆（Lazy + Memoization）**   | 高性能与确定性          |\n\n> 函数式编程不只是“另一种写法”，\n> 而是一种**从状态到变换**、从**控制到描述**的思想转变。\n> 它让我们更接近“数学意义上的确定性程序”。\n\n\n","metadata":"","hasMoreCommit":false,"totalCommits":7,"commitList":[{"date":"2025-10-23T11:39:49+08:00","author":"MY","message":"docs(fp): 重构函数式编程文档内容与结构","hash":"8593355dc2d82450eaf5f89dddc9814b1ff53656"},{"date":"2021-08-05T21:37:17+08:00","author":"MY","message":"📦整理 编程范式","hash":"5797e4e654e615ab9b65412c48ac2132b116e651"},{"date":"2021-05-14T16:44:44+08:00","author":"cjiping","message":"✏更新 函数式编程","hash":"fa202ca250d6cab39026176f7f3b5265e3d81306"},{"date":"2021-05-13T16:06:46+08:00","author":"cjiping","message":"✏更新 函数式编程","hash":"61302a75ec31c35ae850e3305c50390f4b6fbd28"},{"date":"2021-05-12T15:06:41+08:00","author":"cjiping","message":"✏更新 函数式编程","hash":"ce8247bff530cd83c0b830828c6a3cbd463bf834"},{"date":"2021-05-11T10:52:34+08:00","author":"cjiping","message":"✏更新 函数式编程","hash":"7ca7bdf505b894501d261e4476a706d0610f26ab"},{"date":"2021-05-10T15:33:52+08:00","author":"cjiping","message":"➕增加 函数式编程","hash":"11e6821f84840879956426357255adf184c77ee8"}],"createTime":"2021-05-10T15:33:52+08:00"}