
# 面向对象（Object-Oriented）

## 一、哲学层：世界观与本体论

面向对象不仅是一种编程方法，更是一种**认识世界与管理复杂性**的思想。
它的核心世界观是：**“一切皆对象”**。

### 1. 世界的对象化视角

现实世界由无数“事物”构成，每个事物既有**状态（数据）**，也有**行为（方法）**。
当我们用程序描述世界时，就是在为这些事物建立数字化的“投影”：

```java
class Person {
    Date birthday;
    int getAge();
}
```

> 对象是数据与行为的统一体。
> 类是对象的蓝图，是对世界中“共性”的抽象。
> 通过封装接口，隐藏内部变化，实现模块化与解耦。

### 2. 抽象的本质

抽象不是“省略细节”，而是“聚焦本质”。
在复杂系统中，抽象的目标是——**隔离变化、控制复杂性、表达语义**。

> 只暴露稳定的接口，让内部变化不影响外部世界。
> —— 这正是“封装”思想的哲学根基。

---

## 二、技术层：OOP的结构与机制

### 1. 三大特性

#### （1）封装（Encapsulation）

> 将数据与操作打包成一个最小可维护单元，屏蔽内部实现。

**作用：**

* 降低模块间耦合度
* 隐藏实现细节
* 降低变更影响范围
* 提高可维护性与安全性

```java
class Account {
    private double balance;
    public void deposit(double amount) { ... }
    public void withdraw(double amount) { ... }
}
```

#### （2）继承（Inheritance）

> 子类继承父类的属性与行为，形成 **IS-A** 关系。

继承带来**复用与抽象**，但也可能引发**脆弱性**。
继承应当体现语义上的一致性，而非仅仅为了代码复用。

```java
Animal dog = new Dog();  // 向上转型
```

> ✅ 用继承表达概念层次
> ⚠️ 用组合表达行为复用

#### （3）多态（Polymorphism）

> 同一接口，不同实现。

* **编译时多态**：方法重载
* **运行时多态**：方法重写 + 动态绑定

多态使得上层依赖抽象，而非具体实现，从而实现**扩展而不修改（Open-Closed Principle）**。

---

### 2. 组合 vs 继承

继承表达“是一种”（is-a），组合表达“拥有一种”（has-a）。
在现代设计原则中，组合往往比继承更灵活、更安全：

> **“优先使用组合，而不是继承。”**

```java
class Car {
    Engine engine;
    void run() { engine.start(); }
}
```

---

### 3. 类与协作

类是对象的定义，而对象之间的**协作**构成系统行为。

| 方向   | 含义            |
| ---- | ------------- |
| 自底向上 | 职责聚合，形成更高层抽象  |
| 自顶向下 | 职责分解，形成更小粒度模块 |

#### 确定类的原则

* 找出需求中的名词 → 候选类
* 分析其**状态**与**行为**

  * 有状态有行为 → 概念类
  * 有状态无行为 → 数据类
  * 无状态有行为 → 工具类
  * 无状态无行为 → 可舍弃

---

## 三、技术层延伸：UML 类图关系

| 关系     | 含义     | UML符号 |       |
| ------ | ------ | ----- | ----- |
| 泛化（继承） | IS-A   | `A <  | -- B` |
| 实现     | 接口实现   | `<    | ..`   |
| 聚合     | 弱整体-部分 | `o--` |       |
| 组合     | 强整体-部分 | `*--` |       |
| 关联     | 静态引用关系 | `--`  |       |
| 依赖     | 临时使用关系 | `..>` |       |

示例：

```mermaid
classDiagram
    Company *-- Department
    Computer o-- Mouse
    School "1" -- "n" Student
    Vehicle ..> MoveBehavior
```

---

## 四、实践层：面向对象分析与设计（OOA/OOD）

### 1. 面向对象分析（OOA）

目标：**从需求到模型**，回答“系统要做什么”。

#### 层次结构

* **对象层**：识别问题域中的关键对象
* **特征层**：定义属性与操作
* **关系层**：描述对象间关联（继承、依赖、聚合）

#### 流程

1. 从用例（Use Case）出发，分析需求
2. 识别领域对象与类
3. 定义属性、行为与约束
4. 建立关系与包结构
5. 通过顺序图、状态图描述动态行为
6. 不断原型验证与迭代

---

### 2. 面向对象设计（OOD）

目标：**从模型到实现**，回答“系统应如何实现”。

主要关注：

* 模块划分与接口设计
* 抽象层次的组织
* 可复用结构（框架、组件）
* 持久化与性能优化

#### 子系统划分

* **人机交互层**：强调易用性与容错性
* **控制层**：协调流程逻辑
* **数据管理层**：管理持久化与一致性

> 面向对象设计的核心任务，是在抽象与实现之间架起桥梁。

---

### 3. 面向对象编程（OOP）

当分析与设计模型落实到编程语言中，就形成了 OOP 实践。

#### 程序设计范型演进

| 范型   | 核心思想  |
| ---- | ----- |
| 面向过程 | 按步骤执行 |
| 模块化  | 按功能分块 |
| 面向对象 | 按职责建模 |

OOP语言的好坏标准：

* 支持类与对象的抽象表达
* 支持继承、组合、多态
* 支持消息传递与封装

---

## 五、进化层：设计原则与模式

### 1. 面向对象设计原则

| 原则         | 核心思想            |
| ---------- | --------------- |
| **迪米特法则**  | 最少知识原则，只与“朋友”交流 |
| **合成复用原则** | 多用组合，少用继承       |
| **共同闭包原则** | 一起修改的类应放在同一模块   |
| **稳定抽象原则** | 稳定的模块应更抽象       |
| **稳定依赖原则** | 依赖方向应指向更稳定的模块   |

这些原则共同构成了 **面向变化设计的哲学基础**。

---

### 2. DCI 架构思想

> DCI：Data（数据） + Context（上下文） + Interaction（交互）

* **Data**：对象的状态与属性
* **Context**：对象在场景中的角色
* **Interaction**：对象之间的行为协作

DCI 强调从“行为视角”理解对象，使系统更贴近人类的思维方式（故事化建模）。

---

## 六、总结：从对象到系统的思维闭环

| 层次         | 关注点      | 目标      |
| ---------- | -------- | ------- |
| 世界观（哲学层）   | 抽象与封装    | 控制复杂性   |
| 技术机制（语言层）  | 封装、继承、多态 | 提供结构与语义 |
| 分析设计（方法层）  | 从需求到模型   | 建立系统蓝图  |
| 实践与原则（演化层） | 复用与稳定    | 实现可持续演进 |

> 面向对象的精髓，不仅在于“代码的组织”，更在于“思维的组织”。
> 它让我们以对象的视角理解世界、抽象系统、驾驭复杂。

