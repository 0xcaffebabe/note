{"name":"面向对象","id":"编程语言-编程范式-面向对象","content":"\n# 面向对象（Object-Oriented）\n\n## 一、哲学层：世界观与本体论\n\n面向对象不仅是一种编程方法，更是一种**认识世界与管理复杂性**的思想。\n它的核心世界观是：**“一切皆对象”**。\n\n### 1. 世界的对象化视角\n\n现实世界由无数“事物”构成，每个事物既有**状态（数据）**，也有**行为（方法）**。\n当我们用程序描述世界时，就是在为这些事物建立数字化的“投影”：\n\n```java\nclass Person {\n    Date birthday;\n    int getAge();\n}\n```\n\n> 对象是数据与行为的统一体。\n> 类是对象的蓝图，是对世界中“共性”的抽象。\n> 通过封装接口，隐藏内部变化，实现模块化与解耦。\n\n### 2. 抽象的本质\n\n抽象不是“省略细节”，而是“聚焦本质”。\n在复杂系统中，抽象的目标是——**隔离变化、控制复杂性、表达语义**。\n\n> 只暴露稳定的接口，让内部变化不影响外部世界。\n> —— 这正是“封装”思想的哲学根基。\n\n---\n\n## 二、技术层：OOP的结构与机制\n\n### 1. 三大特性\n\n#### （1）封装（Encapsulation）\n\n> 将数据与操作打包成一个最小可维护单元，屏蔽内部实现。\n\n**作用：**\n\n* 降低模块间耦合度\n* 隐藏实现细节\n* 降低变更影响范围\n* 提高可维护性与安全性\n\n```java\nclass Account {\n    private double balance;\n    public void deposit(double amount) { ... }\n    public void withdraw(double amount) { ... }\n}\n```\n\n#### （2）继承（Inheritance）\n\n> 子类继承父类的属性与行为，形成 **IS-A** 关系。\n\n继承带来**复用与抽象**，但也可能引发**脆弱性**。\n继承应当体现语义上的一致性，而非仅仅为了代码复用。\n\n```java\nAnimal dog = new Dog();  // 向上转型\n```\n\n> ✅ 用继承表达概念层次\n> ⚠️ 用组合表达行为复用\n\n#### （3）多态（Polymorphism）\n\n> 同一接口，不同实现。\n\n* **编译时多态**：方法重载\n* **运行时多态**：方法重写 + 动态绑定\n\n多态使得上层依赖抽象，而非具体实现，从而实现**扩展而不修改（Open-Closed Principle）**。\n\n---\n\n### 2. 组合 vs 继承\n\n继承表达“是一种”（is-a），组合表达“拥有一种”（has-a）。\n在现代设计原则中，组合往往比继承更灵活、更安全：\n\n> **“优先使用组合，而不是继承。”**\n\n```java\nclass Car {\n    Engine engine;\n    void run() { engine.start(); }\n}\n```\n\n---\n\n### 3. 类与协作\n\n类是对象的定义，而对象之间的**协作**构成系统行为。\n\n| 方向   | 含义            |\n| ---- | ------------- |\n| 自底向上 | 职责聚合，形成更高层抽象  |\n| 自顶向下 | 职责分解，形成更小粒度模块 |\n\n#### 确定类的原则\n\n* 找出需求中的名词 → 候选类\n* 分析其**状态**与**行为**\n\n  * 有状态有行为 → 概念类\n  * 有状态无行为 → 数据类\n  * 无状态有行为 → 工具类\n  * 无状态无行为 → 可舍弃\n\n---\n\n## 三、技术层延伸：UML 类图关系\n\n| 关系     | 含义     | UML符号 |       |\n| ------ | ------ | ----- | ----- |\n| 泛化（继承） | IS-A   | `A <  | -- B` |\n| 实现     | 接口实现   | `<    | ..`   |\n| 聚合     | 弱整体-部分 | `o--` |       |\n| 组合     | 强整体-部分 | `*--` |       |\n| 关联     | 静态引用关系 | `--`  |       |\n| 依赖     | 临时使用关系 | `..>` |       |\n\n示例：\n\n```mermaid\nclassDiagram\n    Company *-- Department\n    Computer o-- Mouse\n    School \"1\" -- \"n\" Student\n    Vehicle ..> MoveBehavior\n```\n\n---\n\n## 四、实践层：面向对象分析与设计（OOA/OOD）\n\n### 1. 面向对象分析（OOA）\n\n目标：**从需求到模型**，回答“系统要做什么”。\n\n#### 层次结构\n\n* **对象层**：识别问题域中的关键对象\n* **特征层**：定义属性与操作\n* **关系层**：描述对象间关联（继承、依赖、聚合）\n\n#### 流程\n\n1. 从用例（Use Case）出发，分析需求\n2. 识别领域对象与类\n3. 定义属性、行为与约束\n4. 建立关系与包结构\n5. 通过顺序图、状态图描述动态行为\n6. 不断原型验证与迭代\n\n---\n\n### 2. 面向对象设计（OOD）\n\n目标：**从模型到实现**，回答“系统应如何实现”。\n\n主要关注：\n\n* 模块划分与接口设计\n* 抽象层次的组织\n* 可复用结构（框架、组件）\n* 持久化与性能优化\n\n#### 子系统划分\n\n* **人机交互层**：强调易用性与容错性\n* **控制层**：协调流程逻辑\n* **数据管理层**：管理持久化与一致性\n\n> 面向对象设计的核心任务，是在抽象与实现之间架起桥梁。\n\n---\n\n### 3. 面向对象编程（OOP）\n\n当分析与设计模型落实到编程语言中，就形成了 OOP 实践。\n\n#### 程序设计范型演进\n\n| 范型   | 核心思想  |\n| ---- | ----- |\n| 面向过程 | 按步骤执行 |\n| 模块化  | 按功能分块 |\n| 面向对象 | 按职责建模 |\n\nOOP语言的好坏标准：\n\n* 支持类与对象的抽象表达\n* 支持继承、组合、多态\n* 支持消息传递与封装\n\n---\n\n## 五、进化层：设计原则与模式\n\n### 1. 面向对象设计原则\n\n| 原则         | 核心思想            |\n| ---------- | --------------- |\n| **迪米特法则**  | 最少知识原则，只与“朋友”交流 |\n| **合成复用原则** | 多用组合，少用继承       |\n| **共同闭包原则** | 一起修改的类应放在同一模块   |\n| **稳定抽象原则** | 稳定的模块应更抽象       |\n| **稳定依赖原则** | 依赖方向应指向更稳定的模块   |\n\n这些原则共同构成了 **面向变化设计的哲学基础**。\n\n---\n\n### 2. DCI 架构思想\n\n> DCI：Data（数据） + Context（上下文） + Interaction（交互）\n\n* **Data**：对象的状态与属性\n* **Context**：对象在场景中的角色\n* **Interaction**：对象之间的行为协作\n\nDCI 强调从“行为视角”理解对象，使系统更贴近人类的思维方式（故事化建模）。\n\n---\n\n## 六、总结：从对象到系统的思维闭环\n\n| 层次         | 关注点      | 目标      |\n| ---------- | -------- | ------- |\n| 世界观（哲学层）   | 抽象与封装    | 控制复杂性   |\n| 技术机制（语言层）  | 封装、继承、多态 | 提供结构与语义 |\n| 分析设计（方法层）  | 从需求到模型   | 建立系统蓝图  |\n| 实践与原则（演化层） | 复用与稳定    | 实现可持续演进 |\n\n> 面向对象的精髓，不仅在于“代码的组织”，更在于“思维的组织”。\n> 它让我们以对象的视角理解世界、抽象系统、驾驭复杂。\n\n","metadata":"","hasMoreCommit":true,"totalCommits":11,"commitList":[{"date":"2025-10-30T10:42:20+08:00","author":"MY","message":"docs(oop): 重构面向对象编程文档结构与内容","hash":"faaa6941bcd6b4597589b313250254c4ee797d53"},{"date":"2024-02-20T19:56:50+08:00","author":"MY","message":"✏面向对象","hash":"dbc98f116cdb5d69b486c9a1b0207b27c11668a6"},{"date":"2023-12-13T18:54:27+08:00","author":"MY","message":"✏面向对象","hash":"38ce5781c725d419707db601b99a229c7d373724"},{"date":"2023-11-06T20:07:31+08:00","author":"MY","message":"✏集合&面向对象","hash":"1bc147d8eb110fdddea62531487b7c972fd29f15"},{"date":"2023-03-09T07:30:15Z","author":"My","message":"✏面向对象","hash":"c5252b5cbc183510d5ba60f33428619fdbbe5d61"},{"date":"2021-08-09T17:50:52+08:00","author":"cjiping","message":"✏更新 面向对象","hash":"9535c46c5cb2010d80e9589857c726b5f036a285"},{"date":"2021-08-05T21:37:17+08:00","author":"MY","message":"📦整理 编程范式","hash":"5797e4e654e615ab9b65412c48ac2132b116e651"},{"date":"2021-08-03T19:50:20+08:00","author":"cjiping","message":"✏更新 设计原则","hash":"3e1d285a6dac88c5a5f5a3179c5b777517ee55c9"},{"date":"2021-03-17T17:37:58+08:00","author":"cjiping","message":"📦整理 软件工程 理论","hash":"4bdaf047b41bfd74136bca4ac79055ecf91a8392"},{"date":"2020-07-09T14:59:47+08:00","author":"MY","message":"✏更新 面向对象","hash":"815b1966ee1566eb98f6e13ae5bb0ca52bfe9076"}],"createTime":"2020-03-08T19:26:08+08:00"}