# 编程语言

- 语言的类型模型
  - 强类型弱类型 静态类型静态类型
- 语言的泛型
  - 面向对象 函数式 过程式
- 怎样与语言交互
  - 编译还是解释
- 判断结构与数据结构
- 核心特性

## 语言学习

- 在比较中学习：编程语言的规则并不具有普遍意义，只是因为“在当前的特定情况下，做此规定能更方便
- 在历史中学习：了解历史条件，以及历史变迁，能加深理解

## 编程语言的历史

从纸条打孔到高级语言

各种各样编程语言出现的原因：懒惰 急躁 傲慢

## 语法

语法是语言设计者制定的规则，怎么方便就怎么来

基于栈：

```forth
1 2 + 3 *
```

基于树：

```lisp
(+ 1 2)
```

设计不存在任何解析矛盾的语法体系是十分困难的。随后要再融入新的语法时不与既有的语法发生冲突，这个尤其困难

## 流程控制

else语句的：goto 的危害

while语句的：让反复执行的if更加简洁

for语句：让数值建增的while语句更简洁

for-wach语句：让for遍历更简洁

## 函数

作用：缩小关注点 代码复用

返回：调用栈

递归：递归完成的操作都可以转换为迭代操作

## 错误处理

程序所依赖的外部凡是可能出错的最后总会出错

- 用特殊返回值表示错误
  - 不需要编程语言的支持
  - 这种方式并非强制 错误很容易被忽略
  - 同时正常代码跟异常处理代码会混杂在一起
- 统一跳转
- 异常

异常的使用：

- 何时抛出异常
- 异常的出口
- 异常的传递

## 名字与作用域

为什么要名字？可读性

为什么要作用域？管理名字

作用域的演变：

- 全局作用域

```perl
$i
```

- 动态作用域

```perl
local $i
```

- 静态作用域

```perl
my $x
```

## 类型

类型是数据的元数据

```asm
cvtsi2ssq %rax, %xmm1
```

类型的扩展：

- 用户自定义（结构体）
- 面向对象
- 泛型或模板
- 动态类型
- 类型推断

## 容器与字符串

## 并发处理

交替运行：

- 协作式
- 抢占式

## 对象与类

面向对象在不同语言下不一样

模型的建立方法：

- 模块/包
- 函数
- 闭包
- 类

### 闭包

函数对象：
- C中的函数指针
- 其他语言中的高阶函数

从函数对象中能够对外部变量进行访问（引用、更新），是闭包的构成要件之一

从属于外部作用域中的局部变量，被函数对象给“封闭”在里面了

## 继承与代码复用

继承的实现策略：

- 一般化与特殊化
- 提取共同部分
- 差异实现

多重继承带来命名冲突的解决:

- 禁止
- 按某种顺序搜索

## DSL

> 利用为特定领域（Domain）所专门设计的词汇和语法，简化程序设计过程，提高生产效率的技术，同时也让非编程领域专家的人直接描述逻辑成为可能

- 外部DSL：独立于开发语言存在
- 内部DSL：依赖于一门宿主开发语言而存在, 这要求宿主语言必须足够简洁且灵活

> 库设计就是语言设计（Library design is language design）

```java
// 用流畅接口在Java中实现DSL
private void makeOrder(Customer
  customer) {
    customer.newOrder()
      .with(6, "TAL")
      .with(5, "HPK").skippable()
      .with(3, "LGV")
      .priorityRush();
}
```

### DSL构成要素

- 上下文
- 语句
- 单位
- 词汇
- 层次结构

## 内存管理

- 手动
- 自动
  - 根扫描
  - 引用计数

GC大一统理论：目前的GC收集方法只有根扫描和引用计数，两者相互对立，对一方有用的技术，对另一方跟定也有用。如根扫描的写屏障机制，以及引用计数的堆局部变量进行分代

