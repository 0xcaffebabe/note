{"name":"编译原理","id":"编译原理-编译原理","content":"# 编译原理\n\n## 一、编译的第一性原理\n\n### 1. 编译的本质是什么？\n\n**编译的本质，是把不确定的、模糊的人类表达，转换为确定的、可执行的机器结构。**\n\n这一过程解决三个根本问题：\n\n1. **结构识别（Structure Recognition）**\n   从字符流中识别“有意义的结构”。\n2. **语义约束（Semantic Constraints）**\n   判断结构在语义层面是否“合理”。\n3. **执行映射（Execution Mapping）**\n   将语义映射为某种可执行形式。\n\n所有编译器设计，无论语言、工具、平台如何变化，都围绕这三点展开。\n\n---\n\n## 二、编译器的稳定整体结构\n\n### 1. 经典编译器分层模型\n\n```mermaid\nstateDiagram-v2\n    源代码 --> 词法分析\n    state 前端 {\n        词法分析 --> 语法分析\n        语法分析 --> 语义分析\n    }\n    语义分析 --> 中间表示(IR)\n    state 后端 {\n        中间表示(IR) --> 优化\n        优化 --> 目标代码\n    }\n```\n\n> **分层不是实现习惯，而是复杂性控制手段。**\n\n每一层只解决一个不可回避的本质问题，并向下游提供稳定输出。\n\n---\n\n### 2. 各阶段的输入、输出与不变量\n\n| 阶段   | 输入      | 输出          | 不变量（稳定知识）    |\n| ---- | ------- | ----------- | ------------ |\n| 词法分析 | 字符流     | Token 流     | 正则语言 / 有限自动机 |\n| 语法分析 | Token 流 | AST         | 上下文无关文法      |\n| 语义分析 | AST     | 注解 AST / IR | 类型系统、作用域     |\n| 中间表示 | AST     | IR          | 语言无关抽象       |\n| 优化   | IR      | IR          | 语义等价         |\n| 代码生成 | IR      | 目标代码        | 指令模型         |\n\n这张表是**高度稳定的知识资产**，几乎不随语言或工具变化。\n\n---\n\n## 三、词法分析：从字符到符号\n\n### 1. 词法分析解决什么问题？\n\n> **问题本质：字符本身没有语义，必须先被分组成“符号”。**\n\n词法分析的目标不是“理解程序”，而是：\n\n* 把连续字符切分为最小有意义单元（Token）\n* 丢弃无语义内容（空白、注释）\n\n---\n\n### 2. 为什么有限自动机可以胜任？\n\n* 编程语言的词法规则 = **正则语言**\n* 正则语言 ⇔ 有限自动机（DFA / NFA）\n\n因此：\n\n> **词法分析是一个纯粹的状态迁移问题。**\n\n---\n\n### 3. 示例：`age >= 45`\n\n```mermaid\nstateDiagram-v2\n    初始 --> GT: >\n    GT --> GE: =\n    初始 --> ID: 字母\n    ID --> ID: 字母或数字\n    初始 --> INT: 数字\n    INT --> INT: 数字\n```\n\n> 这里不存在“上下文”“嵌套”“优先级”等复杂问题。\n\n---\n\n### 4. 正则表达式只是另一种描述方式\n\n```text\nId          : [a-zA-Z_] ([a-zA-Z_] | [0-9])*\nIntLiteral  : [0-9]+\nGE          : '>='\n```\n\n**正则 ≠ 实现方式，只是规则描述语言。**\n\n---\n\n## 四、语法分析：从符号到结构\n\n### 1. 为什么需要语法分析？\n\nToken 序列本身仍然是线性的，而程序结构是**层次化的**。\n\n语法分析解决的问题是：\n\n> **这些符号是否能组成合法的结构？**\n\n---\n\n### 2. 上下文无关文法（CFG）\n\n上下文无关的含义是：\n\n> 一个产生式的使用，不依赖它所处的位置。\n\n```text\nadd ::= mul | add + mul\nmul ::= pri | mul * pri\npri ::= Id | Num | (add)\n```\n\nCFG 是结构化语言的最低必要表达能力。\n\n---\n\n### 3. AST：结构的最终载体\n\n以 `2 + 3 * 5` 为例：\n\n```text\nadditive\n├── Int(2)\n└── multiplicative\n    ├── Int(3)\n    └── Int(5)\n```\n\n> AST 不关心如何写，只关心**是什么结构**。\n\n---\n\n### 4. 递归下降与左递归消除\n\n递归下降的本质：\n\n> **文法结构 = 函数调用结构**\n\n左递归问题不是语法问题，而是**实现问题**。\n\n```text\nadd  -> mul add'\nadd' -> + mul add' | ε\n```\n\nEBNF 本质是对 CFG 的一种工程友好扩展。\n\n---\n\n## 五、语义分析：结构是否“合理”\n\n### 1. 语义分析解决什么？\n\n语法正确 ≠ 语义正确。\n\n```text\nint a = \"hello\";   // 语法正确，语义错误\n```\n\n语义分析关注：\n\n* 类型系统\n* 作用域\n* 符号绑定\n* 运算合法性\n\n---\n\n### 2. 语义的结果不是“报错”，而是**信息补全**\n\n语义分析通常产生：\n\n* 类型注解 AST\n* 或直接生成 IR\n\n---\n\n## 六、中间表示（IR）：编译器的核心资产\n\n### 1. 为什么一定要 IR？\n\n> **IR 是前端与后端的解耦边界。**\n\n* 前端复杂、多样\n* 后端依赖平台\n\nIR 是稳定核心。\n\n---\n\n### 2. IR 的关键特征\n\n* 语言无关\n* 明确控制流 / 数据流\n* 易于分析与优化\n\nLLVM IR 是经典实践，但 IR 这一思想本身是稳定知识。\n\n---\n\n## 七、优化：在不改变语义的前提下\n\n优化的唯一约束：\n\n> **语义等价**\n\n优化不是“更快”，而是：\n\n* 删除冗余\n* 合并等价结构\n* 改写执行路径\n\n---\n\n## 八、ANTLR：解析器生成器的工程形态（非稳定层）\n\n### 1. 抽象视角下的 ANTLR\n\nANTLR ≠ 编译原理本身，而是：\n\n> **形式化文法 + 自动代码生成**\n\nYacc / Bison / ANTLR 本质相同。\n\n---\n\n### 2. 工程示例的定位\n\n* g4 文件\n* Java 代码\n* 命令行工具\n\n都属于：\n\n> **工程实现示例（不稳定知识）**\n\n理解思想即可，无需长期记忆细节。\n\n---\n\n## 九、编译思想的泛化应用\n\n编译原理不是“写语言”的专利。\n\n| 场景  | 编译思想          |\n| --- | ------------- |\n| SQL | 查询 → 执行计划     |\n| 前端  | AST → 转译 / 优化 |\n| DSL | 规则 → 执行模型     |\n| 正则  | 模式 → 自动机      |\n\n> **凡是“表达 → 结构 → 执行”的系统，都是编译问题。**\n\n---\n\n## 十、总结：稳定认知地图\n\n* 编译 ≠ 技术细节\n* 编译 = 一种复杂系统拆解方法\n* 分层、抽象、约束，是其不变内核\n\n**学会编译原理，真正得到的是：**\n\n> 如何把混乱的问题，拆解为可验证、可演进、可执行的结构。\n\n## 关联内容（自动生成）\n\n- [/编程语言/JAVA/JVM/字节码.md](/编程语言/JAVA/JVM/字节码.md) 这篇文档详细介绍了JVM字节码的结构和指令，与编译原理中的中间表示和代码生成阶段密切相关\n- [/编程语言/JAVA/JVM/字节码执行引擎.md](/编程语言/JAVA/JVM/字节码执行引擎.md) 介绍了字节码执行引擎的实现，与编译原理中编译后代码的执行相关联\n- [/DSL/正则表达式.md](/DSL/正则表达式.md) 正则表达式与编译原理中的词法分析密切相关，是实现词法分析器的重要工具\n- [/编程语言/JAVA/JVM/JAVA内存模型.md](/编程语言/JAVA/JVM/JAVA内存模型.md) 介绍了Java内存模型，与编译器实现和优化中涉及的并发和内存访问问题相关\n","metadata":"tags: ['编程语言', '编译器模型']","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2025-12-19T20:57:47+08:00","author":"MY","message":"docs(compiler): 完善编译原理文档结构与内容","hash":"7007b8f8e6d66687d2119fa545d2da7ab00c0c04"},{"date":"2023-03-19T16:33:10+08:00","author":"MY","message":"更新 编译原理","hash":"819aece925cd3204766ba468a4a4a47d82971faa"},{"date":"2023-03-16T22:03:20+08:00","author":"MY","message":"更新 编译原理","hash":"83065ee9e60dc5e4174a5f51764b49e11f6b598f"},{"date":"2023-03-15T21:42:27+08:00","author":"MY","message":"更新 编译原理","hash":"b61fe32fdd8145fd4a18cafd982769d4340bea4e"},{"date":"2023-03-14T21:50:52+08:00","author":"MY","message":"➕编译原理","hash":"f3ac108f41c1d73595a75a6c43e2da09d03ddf09"}],"createTime":"2023-03-14T21:50:52+08:00"}