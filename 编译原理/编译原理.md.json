{"name":"编译原理","id":"编译原理-编译原理","content":"# 编译原理\n\n```mermaid\nstateDiagram-v2\n  源代码 --> 词法分析\n  state 前端 {\n    词法分析 --> 语法分析\n    语法分析 --> 语义分析\n  }\n  语义分析 --> 生成中间代码\n  state 后端 {\n    生成中间代码 --> 优化\n    优化 --> 生成目标代码\n  }\n```\n\n## 词法分析\n\n### 有限自动机\n\n要实现一个词法分析器，首先需要写出每个词法的正则表达式，并画出有限自动机，之后，只要用代码表示这种状态迁移过程就可以了\n\nage >= 45 的此法解析自动机：\n\n```mermaid\nstateDiagram-v2\n  初始 --> 比较操作符>: >\n  比较操作符> --> 比较操作符>=: =\n  初始 --> ID: 字母\n  ID --> ID: 字母或数字\n  初始 --> 数字字面量: 数字\n  数字字面量 --> 数字字面量: 数字\n```\n\n```java\nDfaState newState = DfaState.Initial;\nif (isAlpha(ch)) {              //第一个字符是字母\n    newState = DfaState.Id; //进入Id状态\n    token.type = TokenType.Identifier;\n    tokenText.append(ch);\n} else if (isDigit(ch)) {       //第一个字符是数字\n    newState = DfaState.IntLiteral;\n    token.type = TokenType.IntLiteral;\n    tokenText.append(ch);\n} else if (ch == '>') {         //第一个字符是>\n    newState = DfaState.GT;\n    token.type = TokenType.GT;\n    tokenText.append(ch);\n}\n```\n\n使用正则表达式描述词法：\n\n```js\nId :        [a-zA-Z_] ([a-zA-Z_] | [0-9])*\nIntLiteral: [0-9]+\nGT :        '>'\nGE :        '>='\n```\n\n## 语法分析\n\n### 语法规则描述\n\nBNF:\n\n```js\nadd ::= mul | add + mul\nmul ::= pri | mul * pri\npri ::= Id | Num | (add) \n```\n\n扩展BNF（EBNF）：\n\n```js\n// 会用到类似正则表达式的一些写法\nadd -> mul (+ mul)*\n```\n\n\n### 上下文无关文法\n\n上下文无关指的是无论在任何情况下，文法的推导规则都是一样的\n\n描述整数加法与乘法的文法，在解析后，可以形成一颗AST：\n\n```regx\nadditiveExpression\n    :   multiplicativeExpression\n    |   additiveExpression Plus multiplicativeExpression\n    ;\n\nmultiplicativeExpression\n    :   IntLiteral\n    |   multiplicativeExpression Star IntLiteral\n    ;\n```\n“2+3*5” 的推导过程：\n```regx\n-->additiveExpression + multiplicativeExpression\n-->multiplicativeExpression + multiplicativeExpression\n-->IntLiteral + multiplicativeExpression\n-->IntLiteral + multiplicativeExpression * IntLiteral \n-->IntLiteral + IntLiteral * IntLiteral\n```\n\n### 递归下降\n\n上级文法嵌套下级文法，上级的算法调用下级的算法\n\n消除左递归：\n\n对于加法与乘法的文法：\n\n```js\nadd -> mul | add + mul   \n```\n\n会陷入无限递归，那就引入一个终止条件，也就是空集来终止递归：\n\n```js\nadd -> mul add'\nadd' -> + mul add' | ε\n```\n```js\n// EBNP表达\nadd -> mul (+ mul)* \n```\n\n## Antlr\n\n词法规则文件：\n\n```g4\nlexer grammar Hello;  //lexer关键字意味着这是一个词法规则文件，要与文件名相同。\n\n@header {\npackage antlrtest;\n}\n\n//关键字\nIf :               'if' | '如果';   //可以在程序里用‘如果’来代替'if'\nInt :              'int';\n\n//常量\nIntLiteral:        [0-9]+;\nStringLiteral:      '\"' .*? '\"' ;  //字符串常量\n\n//操作符\nAssignmentOP:       '=' ;    \nRelationalOP:       '=='|'>'|'>='|'<' |'<=' ;    \nStar:               '*';\nPlus:               '+';\nSharp:              '#';\nSemiColon:          ';';\nDot:                '.';\nComm:               ',';\nLeftBracket :       '[';\nRightBracket:       ']';\nLeftBrace:          '{';\nRightBrace:         '}';\nLeftParen:          '(';\nRightParen:         ')';\n\n//标识符\nId :                [a-zA-Z_] ([a-zA-Z_] | [0-9])*;\n\n//空白字符，抛弃\nWhitespace:         [ \\t]+ -> skip;\nNewline:            ( '\\r' '\\n'?|'\\n')-> skip;\n```\n\n```g4\n// 语法分析器\nexpression\n    :   assignmentExpression\n    |   expression ',' assignmentExpression\n    ;\n\nassignmentExpression\n    :   additiveExpression\n    |   Identifier assignmentOperator additiveExpression\n    ;\n\nassignmentOperator\n    :   '='\n    |   '*='\n    |  '/='\n    |   '%='\n    |   '+='\n    |   '-='\n    ;\n\nadditiveExpression\n    :   multiplicativeExpression\n    |   additiveExpression '+' multiplicativeExpression\n    |   additiveExpression '-' multiplicativeExpression\n    ;\n\nmultiplicativeExpression\n    :   primaryExpression\n    |   multiplicativeExpression '*' primaryExpression\n    |   multiplicativeExpression '/' primaryExpression\n    |   multiplicativeExpression '%' primaryExpression\n    ;\n```\n\n```sh\n# 生成词法分析器的java源码\nantlr Hello.g4\n# 生成语法分析器\nantlr PlayScript.g4\n# 输入表达式查看AST\ngrun antlrtest.PlayScript expression -gui\n```\n","metadata":"","hasMoreCommit":false,"totalCommits":4,"commitList":[{"date":"2023-03-19T16:33:10+08:00","author":"MY","message":"更新 编译原理","hash":"819aece925cd3204766ba468a4a4a47d82971faa"},{"date":"2023-03-16T22:03:20+08:00","author":"MY","message":"更新 编译原理","hash":"83065ee9e60dc5e4174a5f51764b49e11f6b598f"},{"date":"2023-03-15T21:42:27+08:00","author":"MY","message":"更新 编译原理","hash":"b61fe32fdd8145fd4a18cafd982769d4340bea4e"},{"date":"2023-03-14T21:50:52+08:00","author":"MY","message":"➕编译原理","hash":"f3ac108f41c1d73595a75a6c43e2da09d03ddf09"}],"createTime":"2023-03-14T21:50:52+08:00"}