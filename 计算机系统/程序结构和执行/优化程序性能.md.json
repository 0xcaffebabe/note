{"name":"优化程序性能","id":"计算机系统-程序结构和执行-优化程序性能","content":"# 优化程序性能\n\n编写高效程序需要注意的：\n\n- 合适的算法与数据结构\n- 编写出能让编译器转换为高效机器代码的源代码\n\n## 编译器优化的能力和局限性\n\ngcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast\n\n- 0 为没有任何优化\n- -O1、-O2、-O3 中，随着数字变大，代码的优化程度也越高, 是以牺牲程序的可调试性为代价的\n- -Os 是在 -O2 的基础上，去掉了那些会导致最终可执行程序增大的优化\n- -Ofast 是在 -O3 的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的\n\n在执行优化的过程，编译期所考虑的是必须执行安全的优化，所以必须考虑所有的情况，这样优化的选择就比较少了\n\n如内存别名，看似优化能减少几次内存读写成本，但如果两个指针都指向同一块内存，那么看似可以优化的操作就会导致程序结果执行出错\n\n```c\n// 如果x与y都指向同一块内存\nvoid func(int *x, int *y) {\n    *x += *y;\n    *x += *y;\n}\n// 那么如果编译期将代码优化成这样, 程序的执行结果就错了\nvoid func(int *x, int *y) {\n    *x += 2 * *y;\n}\n```\n\n对于函数内联优化，也就是将原本的函数调用提取出来，将代码展开到调用处，不仅可以减少函数调用成本，同时展开之后也方便做其他优化, 这种优化方式在JVM的[后端编译优化](/编程语言/JAVA/JVM/后端编译与优化.md#方法内联)中也得到了较好的执行\n\n内存的读写成本大概是在百纳秒这个级别，而函数的调用成本不仅需要将内存中的帧指针移位到堆栈上,并在其上添加新帧.函数参数被移入本地寄存器以供使用,并且堆栈指针被前进到堆栈的新顶部以执行该函数，需要多条指令来完成，这还只是针对C的函数调用，像OOP语言多态的虚方法之类的东西，调用之前需要进行查表，或者Java语言这种动态方法调用，需要做的事更多，过程调用不仅带来了开销，同时也会妨碍大多数的优化\n\n## 表示程序性能\n\n- 每元素周期数(CPE)\n\n也就是执行的CPU周期数\n\n### 循环展开\n\n通过诸如循环展开等的优化方法，可以使得用更少的循环完成计算\n\n```c\n// 未展开前\nfor (i = 1; i <= 60; i++) \n   a[i] = a[i] * b + c;\n// 展开后\nfor (i = 1; i <= 58; i+=3)\n{\n  a[i] = a[i] * b + c;\n  a[i+1] = a[i+1] * b + c;\n  a[i+2] = a[i+2] * b + c;\n}\n```\n\n大部分编译器在将优化级别设的足够高都能支持循环展开\n\n## 消除循环的低效率\n\n- 代码移动\n\n```c\nvoid f1(int a[]){\n    // 将长度的计算提取到变量, 避免每次循环都进行计算\n    int i = length(a);\n    int j;\n    for(j=0;j<i;j++){\n        // DO SOMETHING\n    }\n}\n\nvoid f2(int a[]){\n\n    int j;\n    for(j=0;j< length(a);j++){\n        // DO SOMETHING\n    }\n}\n```\n\n这种优化操作编译器无法帮助程序员完成，因为编译器必须假设length这个函数是可能具有副作用\n\n## 消除不必要的内存引用\n\n```c\nvoid sum1(int a[],int n,int *ret){\n    int i=0;\n    for(;i<n;i++){\n        // 每次操作需要读两次内存(ret跟a[i]) 一次写内存(ret)\n        *ret += a[i];\n    }\n}\n\nvoid sum2(int a[],int n,int *ret){\n    int i=0;\n    int tmp=0;\n    for(;i<n;i++){\n        // 使用一个临时变量, 每次操作需要读一次内存(a[i]) 一次写寄存器(tmp)\n        tmp += a[i];\n    }\n    *ret = tmp;\n}\n```\n\n## 理解现代处理器\n\n- 想进一步优化程序性能，必须考虑利用处理器为体系结构的优化\n\n指令级并行：多条指令在物理上是乱序并行的，但在程序视角是顺序一条条，但肯定会出现一系列指令都必须在物理上顺序执行，这是**延迟界限**，处理器计算能力也是有上限的，称为**吞吐量界限**\n\n### 整体操作\n\n![乱序处理器框图](/assets/屏幕截图%202022-03-31%20164213.png)\n\nCPU在执行指令之前就已经对后续的指令进行取值与译码，当遇到分支时，会执行**分支预测**，其会执行CPU选定分支的相关指令，如果预测错误，就会恢复相关状态，执行另一条分支的指令\n\n_寄存器重命名_\n\n### 功能单元的性能\n\n- CPU的每个功能单元（加法、除法等）都有自己的极限\n\n### 处理器操作的抽象模型\n\n![一段代码在CPU的数据流](/assets/屏幕截图%202022-04-01%20160509.png)\n\n从这个图可以看出CPU是如何并行乱序执行的\n\n## 提高并行性\n\n### 多个累积变量\n\n- 通过切分不同的部分使用不同累加变量，充分并行\n\n```c\nvoid sum1(int a[],int n,int *ret){\n    int i=0;\n    int limit = n/2;\n    int tmp1=0;\n    int tmp2=0;\n\n    for(;i<limit;i++){\n        tmp1 += a[i];\n    }\n\n    for(i=limit;i<n;i++){\n        tmp2+=a[i];\n    }\n\n    *ret= tmp1 + tmp2;\n}\n```\n\n### 重新结合变换\n\n- 对于算术累加变换，使得后面两个操作可以被并行\n\n```c\ntmp = (tmp + a[i]) +a[i+1] // 1\ntmp = tmp + (a[i] +a[i+1]) // 2\n```\n\n## 限制因素\n\n### 寄存器溢出\n\n如果寄存器不够用，将会使用内存在栈上存放临时变量，造成性能下降\n\n如果循环展开过多，导致每次需要的变量数超过寄存器数，就会不够用\n\n### 分支预测和预测错误处罚\n\n- 不必过分关心\n- 编写适合用条件传送码实现的代码：使用条件分支计算值，根据值来更新程序状态\n\n```c\nfor(int i = 0; i < n; i++) {\n    if (a[i] > b[i]) {\n        int t = a[i];\n        a[i] = b[i];\n        b[i] = a[i];\n    }\n}\n// 条件传送码\nfor(int i = 0; i < n; i++) {\n    int min = a[i] < b[i]? a[i]: b[i];\n    int max = a[i] < b[i]? a[i]: b[i];\n    a[i] = min;\n    b[i] = max;\n}\n```\n\n## 理解内存性能\n\n- 加载性能：内存读操作是有依赖的，所以会受限于其他的读操作或者写操作\n- 存储性能：单纯的写是没有依赖的，可以很快，但是如果有写-读依赖，也会受限\n\n## 应用：性能提高技术\n\n### 高级设计：[算法与数据结构](/算法与数据结构/算法与数据结构.md)\n\n### 基本编码原则\n\n- 消除连续的函数调用\n- 消除不必要的内存引用：使用临时变量保存中间结果，避免频繁读写数组或者全局变量\n\n### 低级优化\n\n- 循环展开\n- 多个累积变量与重新结合, 提升指令并行程度\n- 使得编译采用条件数据传送\n\n## 确认和消除性能瓶颈\n\n- gprof\n","metadata":"tags: ['计算机', '编译原理']","hasMoreCommit":false,"totalCommits":6,"commitList":[{"date":"2022-04-02T15:28:57+08:00","author":"MY","message":"✏️更新 优化程序性能","hash":"2d52880e2019310696f72cdb91b1366bcab910c1"},{"date":"2022-04-01T17:14:27+08:00","author":"MY","message":"✏️更新 优化程序性能","hash":"4e9392431464b1683843cb282bda854413b5f5e0"},{"date":"2022-03-31T17:05:22+08:00","author":"MY","message":"✏️更新 优化程序性能","hash":"0d7e9f6917f09093baa7edf74898f08eaa125b64"},{"date":"2022-03-30T17:00:27+08:00","author":"MY","message":"✏️更新 优化程序性能","hash":"5365bd6702549de5df23d577edc849bf6d175725"},{"date":"2019-07-15T10:59:02+08:00","author":"My、","message":"20190715","hash":"1f3f5c1cdf18eb1eae8ca3f0cee4bc0fb8788a31"},{"date":"2019-07-14T12:42:11+08:00","author":"My、","message":"20190714","hash":"07fb0d8c0ca32d3f4a360448ab4e2368e5aee2b0"}],"createTime":"2019-07-14T12:42:11+08:00"}