# 存储器层次结构

## 基本存储体系

1)输入设备将程序与数据写入主存； 2) CPU取指令； 3) CPU执行指令期间读数据； 4) CPU写回运算结果； 5) 输出设备输出结果；

### 主存速度慢的原因

- 主存增速与CPU增速不同步；
- 指令执行期间多次访问存储器；

### 主存容量不足的原因

- 存在制约主存容量的技术因素

  - CPU、主板等相关技术指标确定

- 应用对主存的需求不断扩大
- 价格原因

### 存储体系的层次结构

![](http://www.pianshen.com/images/328/6f35b9255f2323c21c19478089c6d008.png)

- L1 Cache集成在CPU中，分数据Cache(D-Cache)和指令Cache(I-Cache）
- 早期L2 Cache在主板上或与CPU集成在同一电路板上。随着工艺的提高，L2Cache被集成在CPU内核中，不分D-Cache和I-Cache

### 局部性

- 时间局部性

  - 现在被访问的信息2在不久的将来还将再次被访问
  - 时间局部性的程序结构体现： 循环结构

- 空间局部性

  - 现访问信息2 ，下一次访问2附近的信息。
  - 空间局部性的程序结构体现：顺序结构

## 主存中的数据组织

- 主存的一个存储单元所包含的二进制位数
- 目前大多数计算机的主存按字节编址，存储字长也不断加大,如16位字长、32位字长和64位字长

**ISA设计时要考虑的两个问题**：

- 字的存放问题
- 字的边界对齐问题

### 数据存储与边界

按边界对齐的数据存储：浪费一些空间

![批注 2020-01-30 161009](/assets/批注%202020-01-30%20161009.png)

未按边界对齐存放：虽节省了空间，但增加了访存次数

![批注 2020-01-30 161136](/assets/批注%202020-01-30%20161136.png)

需要在性能与容量间权衡

- 双字长数据边界对齐的起始地址的最末三位为000(8字节整数倍；
- 单字长边界对齐的起始地址的末二位为00(4字节整数倍)；
- 半字长边界对齐的起始地址的最末一位为0(２字节整数倍)。

#### 大端与小端存储

- 小端存储

  - 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端

- 大端存储

  - 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端

无论是大端还是小端，每个系统内部是一致的，但在系统间通信时可能会发生问题！因为顺序不同，需要进行顺序转换

## 存储技术

## 随机访问存储器

### 静态RAM(SRAM)

![批注 2020-01-30 162459](/assets/批注%202020-01-30%20162459.png)

**工作原理**

- 读
- 写
- 保持

#### 结构

![批注 2020-01-15 092634](/assets/批注%202020-01-15%20092634.png)

#### 静态存储器的不足

- 晶体管过多
- 存储密度低
- 功耗大

### 动态RAM(DRAM)

![enter image description here](http://artimg.ishenping.com/20190430163945966_TSVNYF.jpg)

![批注 2020-01-30 164801](/assets/批注%202020-01-30%20164801.png)

DRAM与SRAM不同的是，需要间隔一段时间执行刷新操作

- 读写
- 保持

#### 刷新

- 集中刷新

![批注 2020-01-30 165930](/assets/批注%202020-01-30%20165930.png)

- 分散刷新

![批注 2020-01-30 170041](/assets/批注%202020-01-30%20170041.png)

- 异步刷新

![批注 2020-01-30 190013](/assets/批注%202020-01-30%20190013.png)

#### 其它结构的DRAM存储单元

- 单管

![批注 2020-01-30 190355](/assets/批注%202020-01-30%20190355.png)

### 传统DRAM

![](http://itfish.net/Home/Modules/Images/itfish_61045_2.jpg)

- 内存模块

  ![](http://itfish.net/Home/Modules/Images/itfish_61045_3.jpg)

- 增强DRAM

- 非易失性存储器

- 访问主存

  ![](http://itfish.net/Home/Modules/Images/itfish_61045_4.jpg)

## 存储扩展

- 位扩展

用16K X 8 的存储芯片构建16K X 32的存储器

- 字扩展

用16K X 8 的存储芯片构建128k X 8的存储器

- 字位扩展

用16K X 8 的存储芯片构建128K X 32的存储器

![批注 2020-01-30 190639](/assets/批注%202020-01-30%20190639.png)

无论哪种类型的存储扩展都要完成CPU与主存间地址线、数据线、控制线的连接

## 磁盘存储

- 磁盘构造

  ![](http://itfish.net/Home/Modules/Images/itfish_61045_5.jpg)

- 磁盘容量

  - 记录密度
  - 磁道密度
  - 面密度

- 磁盘操作

  - 寻道时间
  - 旋转时间
  - 传送时间

- 逻辑磁盘块

  （盘面，磁道，扇区）

- 连接IO设备

  ![](http://www.pianshen.com/images/281/0013ac41fa289bfec93c3c9ece6b41a9.png)

  - 通用串行总线（USB）
  - 图形卡
  - 主机总线适配器

- 访问磁盘

  **内存映射**

## 固态硬盘

## raid

- 将数据条带化后的存放在不同磁盘上，通过多磁盘的并行操作提高磁盘系统的读写速率
- 使用基于异或运算为基础的校验技术恢复损坏的数据

![批注 2020-02-08 204640](/assets/批注%202020-02-08%20204640.png)

### raid0

- 数据以条带方式均匀分散在各磁盘

![批注 2020-02-08 204953](/assets/批注%202020-02-08%20204953.png)

### raid1

- 数据采用镜像的冗余方式，同一数据有多份拷贝

![批注 2020-02-08 205138](/assets/批注%202020-02-08%20205138.png)

### RAID 3/4

- 数据按 位/条带 并行传输到多个磁盘上，同时校验数据存放到专用校验盘上

![批注 2020-02-08 205227](/assets/批注%202020-02-08%20205227.png)

### RAID5

- 数据按条带分布在不同磁盘上，校验信息被均匀分散到各磁盘上

![批注 2020-02-08 205428](/assets/批注%202020-02-08%20205428.png)

### RAID10

- 结合RAID1和RAID0，先镜像，再条带化

![批注 2020-02-08 205601](/assets/批注%202020-02-08%20205601.png)

### RAID01

- 结合RAID0和RAID1，先条带化, 再镜像

![批注 2020-02-08 205654](/assets/批注%202020-02-08%20205654.png)

只能容忍一个磁盘故障，如0号盘损坏，左边RAID0失效，只能使用右边的RAID0，不能再有盘损坏，故冗余度为1

### 实现方式

- 软件RAID
  - 功能都依赖于主机CPU完成,没有第三方的控制处理器和I/O芯片
- 硬件RAID
  - 专门RAID控制处理器和I/O处理芯片处理RAID任务，不占用主机CPU资源

### 比较

![批注 2020-02-08 205826](/assets/批注%202020-02-08%20205826.png)

## 存储技术的趋势

- 价格和性能折中
- 不同存储技术的价格与属性以不同的速率变化

## 对程序数据引用的局部性

## 取指令的局部性

## 多体交叉存储器

其基本思想是在不提高存储器速率、不扩展数据通路位数的前提下，通过存储芯片的交叉组织，提高CPU单位时间内访问的数据量，从而缓解快速的CPU与慢速的主存之间的速度差异。

### 高位多体交叉存储器

![批注 2020-01-16 113946](/assets/批注%202020-01-16%20113946.png)

### 低位多体交叉存储器

![批注 2020-01-16 113919](/assets/批注%202020-01-16%20113919.png)

![批注 2020-02-08 161132](/assets/批注%202020-02-08%20161132.png)

## 高速缓存存储器

### cache的工作过程

![批注 2020-02-08 161925](/assets/批注%202020-02-08%20161925.png)

- 如何判断数据在Cache中?
- Cache中的数据是有效吗？（DMA【直接存储访问】修改主存）

![批注 2020-02-08 162227](/assets/批注%202020-02-08%20162227.png)

### cache地址映射机制

![批注 2020-02-08 162555](/assets/批注%202020-02-08%20162555.png)

### cache的结构

- Cache被分成若干行，每行的大小与主存块相同
- Cache每行包含四部分，是Cache要保存的信息。Tag从CPU访问主存的地址中剥离得到、Data是与主存交换的数据块、Valid表示Cache中的数据是否有效、 Dirty表示主存中的数据是最新

![批注 2020-02-08 162726](/assets/批注%202020-02-08%20162726.png)

### 相联存储器

- 如何快速地查找
  - 如何快速地判断数据是否存在

### Cache地址映射与变换方法

- 主存数据如何迁至Cache才能实现快速查找

#### 全相联映射

![批注 2020-02-08 164919](/assets/批注%202020-02-08%20164919.png)

- 主存分块，Cache行 （Line），两者大小相同
- 设每块4个字，主存大小为1024个字，则第61个字的主存地址为：
  - 00001111 01 （块号 块内地址）
- 主存分块后地址就从一维变成二维
- 映射算法：主存的数据块可映射到Cache任意行，同时将该数据块地址对应行的标记存储体中保存

**特点**

- Cache利用率高
- 块冲突率低
- 淘汰算法复杂

所以应用在小容量cache

#### 直接映射

![批注 2020-02-08 165705](/assets/批注%202020-02-08%20165705.png)

- 主存分块，Cache行 （Line），两者大小相同
- 主存分块后还将以Cache行数为标准进行分区
- 设每块4个字，主存大小为1024个字，Cache分为4行，第61个字的主存地址为
  - 000011 11 01 （区号，区内块号，块内地址）
  - 主存地址从一维变成三维
- 映射算法：Cache共n行，主存第j块号映射到Cache 的行号为 i=j mod n
  - 即主存的数据块映射到Cache特定行

**特点**

- Cache利用率低
- 块冲突率高
- 淘汰算法简单

应用在大容量cache

#### 组相联映射

![批注 2020-02-08 185829](/assets/批注%202020-02-08%20185829.png)

- 主存分块，Cache行 （Line），两者大小相同；
- Cache分组（每组中包k行），本例假定K=4
- 主存分块后还将以Cache组数为标准进行分组；
- 设每块4个字，主存大小为1024个字，Cache分为4行，第61个字的主存地址为：
  - 0000111 1 01 （组号，组内块号，块内地址）
  - 主存地址从一维变成三维；
- 映射算法：
  - Cache共n组，主存第j块号映射到Cache 的组号为：i=j mod n
  - 即主存的数据块映射到Cache特定组的任意行

### 替换算法

程序运行一段时间后，Cache存储空间被占满，当再有新数据要调入时，就需要通过某种机制决定替换的对象

#### 先进先出法-FIFO

![批注 2020-02-08 191721](/assets/批注%202020-02-08%20191721.png)

#### 最不经常使用法---LFU

![批注 2020-02-08 191910](/assets/批注%202020-02-08%20191910.png)

#### 近期最少使用法--- LRU

![批注 2020-02-08 192722](/assets/批注%202020-02-08%20192722.png)

#### 替换算法的抖动

- 刚刚淘汰的块在下一时刻又被访问...

## 虚拟存储器

- 计算机能执行比主存空间大的程序吗？

### 概述

- 处于主存 –辅存存储层次
- 解决主存容量不足的问题，为程序设计者提供比主存空间大的编程空间
- 分类：页式虚拟存储器、段式虚拟存储器 、段页式虚拟存储器

### 必须解决的问题

![批注 2020-02-08 200857](/assets/批注%202020-02-08%20200857.png)

- CPU访问存储系统的地址属性（采用MMU(Memory Management Unit):管理虚拟存储器与物理存储器）
- 如何判断CPU要访问的信息是否在主存中（采用页表来判断）

### 地址划分

虚拟地址 = 虚页号+页偏移量

### 逻辑地址与物理地址的转换

## TLB (Translation Lookaside Buffer)

### 虚实地址转换过程中存在的问题

- 缺页异常

![批注 2020-02-08 202837](/assets/批注%202020-02-08%20202837.png)

### 工作原理

TLB类似页表，也是PTE的集合。为实现对TLB的快速访问，类似于Cache中的映射方法，对来自于CPU的虚页号进行逻辑划分，得到相应的标记和索引字段

![批注 2020-02-08 204051](/assets/批注%202020-02-08%20204051.png)

## 缓存写

## 高速缓存参数的性能影响

- 不命中率
- 命中率
- 命中时间
- 不命中处罚

## 存储器层次结构中的缓存

缓解快速CPU与慢速的主存之间的速度差异

![](http://www.pianshen.com/images/46/61cff5bd9636e956ae24618f4e6a90de.png)

### 工作工程

- 缓存命中
- 缓存不命中

  - 冷不命中
  - 冲突不命中

- 缓存管理

# 编写高速缓存友好的代码

# 高速缓存对程序性能的影响
