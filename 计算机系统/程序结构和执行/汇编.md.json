{"name":"汇编","id":"计算机系统-程序结构和执行-汇编","content":"# 汇编\n\n## 程序编码\n\n在编译时指定'-Og'选项让GCC产生符合原始程序结构的机器代码\n\n### 机器级代码\n\n对C语言隐藏， 但对汇编代码可见的：\n\n- 程序计数器\n- 整数寄存器文件\n- 条件码寄存器\n- 向量寄存器\n\n输出c源码的机器表示\n\n```shell\ngcc -Og -S mstore.c\n```\n\n机器代码与反汇编的特性：\n\n- x86-64的指令长度从1-15字节不等\n- 指令设计的格式， 从某个给定位置， 能将字节唯一解码成机器指令\n\n  _哈夫曼编码_\n\n- 反汇编无需访问源代码\n\n- 反汇编与gcc的命名规则有些许差别\n\n  _比如movq的q在反汇编中会被省略_\n\n### 关于格式的注解\n\n```assembly\n.file    \"mstore.c\"\n    .text\n    .globl    mulstore\n    .type    mulstore, @function\nmulstore:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbx\n    .cfi_def_cfa_offset 16\n    .cfi_offset 3, -16\n    movq    %rdx, %rbx\n    call    mult2\n    movq    %rax, (%rbx)\n    popq    %rbx\n    .cfi_def_cfa_offset 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    mulstore, .-mulstore\n    .ident    \"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n    .section    .note.GNU-stack,\"\",@progbits\n```\n\n以上是gcc完整生成的.s文件\n\n所有. 开头的是伪指令， 可以忽略\n\n#### ATT汇编代码格式\n\n```asm\n.file    \"mstore.c\"\n    .text\n    .globl    mulstore\n    .type    mulstore, @function\nmulstore:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbx\n    .cfi_def_cfa_offset 16\n    .cfi_offset 3, -16\n    movq    %rdx, %rbx\n    call    mult2\n    movq    %rax, (%rbx)\n    popq    %rbx\n    .cfi_def_cfa_offset 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    mulstore, .-mulstore\n    .ident    \"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n    .section    .note.GNU-stack,\"\",@progbits\n```\n\n## 数据格式\n\n- 8位： 字节(b)\n- 16位： 字(w)\n- 32位： 双字(l)\n- 64位： 四字(q)\n\n## 访问信息\n\nx86-64的CPU包含一组16个存储64位的通用目的寄存器\n\n```text\n63                     31         15          8          0\n%rax                   %eax       %ax         %ah         %al 返回值\n%rbx                   %ebx       %bx         %bh         %bl 被调用者保存\n%rcx                   %ecx       %cx         %ch         %cl 第4个参数\n%rdx                   %edx       %dx         %dh         %dl 第3个参数\n%rsi                   %esi       %si                     %sil 第2个参数\n%rdi                   %edi       %di                     %dil 第1个参数\n%rbp                   %ebp       %bp                     %bpl 被调用者保存\n%rsp                   %esp       %sp                     %spl 栈指针\n%r8                    %r8d       %r8w                    %r8b 第5个参数\n%r9                    %r9d       %r9w                    %r9b 第6个参数\n%r10                   %r10d      %r10w                   %r10b 调用者保存\n%r11                   %r11d      %r11w                   %r11b 调用者保存\n%r12                   %r12d      %r12w                   %r12b 被调用者保存\n%r13                   %r13d      %r13w                   %r13b 被调用者保存\n%r14                   %r14d      %r14w                   %r14b 被调用者保存\n%r15                   %r15d      %r15w                   %r15b 被调用者保存\n```\n\n每个寄存器都可以作为8位、16位、32位、64位来访问\n\n- %rax %rbx %rcx %rdx 是通用目的64位寄存器，用于存储操作数和计算结果 \n- %rsi %rdi 是源索引寄存器和目的索引寄存器，通常用于字符串和数据传输\n- %rbp %rsp 是基址指针寄存器和栈指针寄存器，用于处理函数调用和栈操作\n- %r8 %r9 %r10 %r11 %r12 %r13 %r14 %r15 是额外的通用目的寄存器，用于扩展操作数和寄存器的数量\n\n- 16位操作可以访问2位字节\n- 32位操作可以访问4位字节\n...\n\n### 操作数指示符\n\n- 立即数： 代表常数\n\n  $后面接c语言表示法的整数\n\n- 寄存器： 表示寄存器里的内容\n\n  $r_a$用来表示寄存器a 用$R[r_a]$表示里面的内容\n\n- 内存引用： 指定内存地址里的内容 M[地址]\n\n![](/assets/202331093655.png)\n\n### 数据传送指令\n\n指令|效果|描述\n-|-|-\nMOVE S,D | D←S|传送\nmovb||传送字节\nmovw||传送字\nmovl||传送双字\nmovq||传送四字\nmovabsq I,R|R←I|传送绝对的四字\n\n零扩展：用于将较窄的整数类型（如8位或16位整数）扩展为较宽的整数类型（如32位或64位整数），原始数据的低位（等于或小于原始数据位数的位）保持不变，而高位被填充为零\n\n符号扩展：用于将较窄的整数类型（如8位或16位整数）扩展为较宽的整数类型（如32位或64位整数），原始数据的低位（等于或小于原始数据位数的位）保持不变，而高位被填充为原始数据的符号位\n\n指令|效果|描述\n-|-|-\nMOVEZ S,R|R←零扩展(S)|以零扩展进行传送\nmovzbw||将做了零扩展的字节传送到字\nmovzbl||将做了零扩展的字节传送到双字\nmovzwl||将做了零扩展的字传送到双字\nmovzbq||将做了零扩展的字节传送到四字\nmovzwq||将做了零扩展的字传送到四字\nMOVS S,R|R←符号扩展(S)|以符号扩展进行传送\nmovsbw||将做了符号扩展的字节传送到字\nmovsbl||将做了符号扩展的字节传送到双字\nmovswl||将做了符号扩展的字传送到双字\nmovsbq||将做了符号扩展的字节传送到四字\nmovswq||将做了符号扩展的字传送到四字\nmovslq||将做了符号扩展的整形传送到四字\ncltq|%rax←符号扩展(%eax)|把%eax符号扩展到%rax\n\n### 压入栈和弹出栈数据\n\n```asm\n. 将四字压入栈\npushq S \n\n. 将四字弹出栈\npopq D\n```\n\n_%rsp 是栈指针 %rax是返回值_\n\n## 算术和逻辑操作\n\n指令|效果|描述\n-|-|-\nleaq S,D|D←&S|加载有效地址\nINC D|D←D+1|加1\nDEC D|D←D-1|减1\nNEG D|D←-D|取反\nNOT D|D←~D|取反\nADD S,D|D←D+S|加\nSUB S,D|D←D-S|减\nIMUL S,D|D←D*S|乘\nXOR S,D|D←D^S|异或\nOR S,D|D←D|或\nAND S,D|D←D&S|与\nSAL S,D|`D←D<<S`|左移\nSHL S,D|`D←D<<S`|左移 = SAL\nSAR S,D|$D←D>>_AS$|算术右移\nSHR S,D|$D←D>>_LS$|逻辑右移\n\n### 加载有效地址\n\n```asm\n. x= y+x*4\nleaq    (%rdi,%rsi,4), %rax\n```\n\n### 一元和二元操作\n\n```asm\n. 从%edi中减去%esi\nsubl    %esi, %edi\n```\n\n### 移位操作\n\n```asm\n. 将x左移四位\nsalq    $4, %rax\n```\n\n### 特殊的算术操作\n\n指令|效果|描述\n---|---|---\nimulq S|R[%rdx]: R[%rax]←S * R[%rax]|有符号全乘法\nmulq S|R[%rdx]: R[%rax]←S * R[%rax]|无符号全乘法\nclto|R[%rdx]: R[%rax]← 符号扩展(R[%rax])|转换为八字\nidivq S|R[%rdx]←R[%rdx]: R[%rax] mod/÷ S|有符号除法\ndivq S|R[%rdx]←R[%rdx]: R[%rax] mod/÷ S|无符号除法\n\n## 控制\n\n### 条件码\n\ncmp 指令在被执行时，会首先比较两个变量的大小，并根据比较结果，动态调整 CPU 上 FLAGS 寄存器中的相应位\n\ntest 指令的执行方式与 cmp 类似，只不过它会对传入的两个操作数做隐式的“与”操作，而非减法操作\n\n标志位名称|位|全称|什么情况下置位（即变更为值1）\n-|-|-|-\nCF|0|Carry|指令执行引起了进位或借位\nPF|2|Parity|指令执行结果的最低有效字节中值为1的位个数为偶数\nZF|6|Zero|指令执行结果为0\nSF|7|Sign|指令执行结果的最高有效位为1\nOF|11|Overtlow|当操作致被当做有符号数时，指令的执行产生了溢出\n\n指令|基于|描述\n-|-|-\nCMP S2,S1|S1-S2|比较\ncmpb|比较 byte|\ncmpw|比较 word|\ncmpl|比较 double word|\nTEST S2,S1|S1&S2|测试\ntestb|测试 byte|\ntestw|测试 word|\ntestl|测试 double word|\n\n这些指令不修改寄存器的值，只设置条件码\n\n```asm\ncmp     DWORD PTR [rbp-4], 1\n        jne     .L2\n        mov     eax, 101\n        jmp     .L3\n.L2:\n        mov     eax, 10\n.L3:\n        pop     rbp\n        ret\n```\n\n对应于\n\n```c\nif (num == 1) {\n    return 101;\n}\nreturn 10;\n```\n\n循环、选择等操作，都是通过 cmp + jmp 来实现的\n\n### 读取条件码\n\n指令|别名|效果|设置条件\n-|-|-|-\nsete D|setz|D←ZF|相等或为0\nsetne D|setnz|D←!ZF|不相等或非0\nsets D||D←SF|负数\nsetns D||D←!SF|非负数\nsetg D|setnle|D←~(SF ^ OF) & ~ZF|有符号大于\nsetge D|setnl|D←~(SF ^ OF)|有符号大于或等于\nsetl D|setnge|D←SF ^ OF|有符号小于\nsetle D|setng|`D←(SF ^ OF)|ZF`|有符号小于或等于\nseta D|setnbe|D←~CF & ~ZF|无符号大于\nsetae D|setnb|D←~CF|无符号大于或等于\nsetb D|setnae|D←CF|无符号小于\nsetbe D|setna|`D←CF|ZF`|无符号小于或等于\n\n### 跳转指令\n\n指令|别名|跳转条件|描述\n-|-|-|-\njmp LABEL||1|直接跳转\njmp *Operand||1|间接跳转\nje LABEL|jz|ZF|相等或为0\njne LABEL|jnz|ZF|不相等或不为0\njs LABEL||SF|负数\njns LABEL||~SF|非负数\njg LABEL|jnle|~(SF ^ OF) & ~ZF|有符号大于\njge LABEL|jnl|~(SF ^ OF)|有符号大于或等于\njl LABEL|jnge|SF ^ OF|有符号小于\njle LABEL|jng|(SF ^ OF) | ZF|有符号小于或等于\nja LABEL|jnbe|~CF & ~ZF|无符号大于\njae LABEL|jnb|~CF|无符号大于或等于\njb LABEL|jnae|CF|无符号小于\njbe LABEL|jna|`CF|ZF`|无符号小于或等于\n\n### 用条件控制实现分支控制\n\n```asm\ncmpq    %rsi, %rdi\n        jg      .L4\n        movq    %rdi, %rax\n        subq    %rsi, %rax\n        ret\n.L4:\n        leaq    (%rdi,%rsi), %rax\n        ret\n```\n\n对应的c代码：\n\n```c\nif (x > y){\n    return x+y;\n}else{\n    return x-y;\n}\n```\n\n### 用条件传送实现条件分支\n\n_分支预测_\n\n指令|别名|传送条件|描述\n---|---|---|---\ncmov S,R|cmovz|ZF|相等或为0\ncmovne S,R|cmovnz|~ZF|不相等或非0\ncmovs S,R||SF|负数\ncmovns S,R||~SF|非负数\ncmovg S,R|cmovnle|~(SF ^ OF) & ~ZF|有符号大于\ncmovge S,R|cmovnl|~(SF ^ OF)|有符号大于或等于\ncmovl S,R|cmovnge|SF ^ OF|有符号小于\ncmovle S,R|cmovng|`(SF ^ OF)|ZF`|有符号小于或等于\ncmova S,R|cmovnbe|~CF & ~ZF|无符号大于\ncmovae S,R|cmovnb|~CF|无符号大于或等于\ncmovb S,R|cmovnae|CF|无符号小于\ncmovbe S,R|cmovna|`CF|ZF`|无符号小于或等于\n\n### 循环\n\n- do-while\n- while\n\n  - guarded-do\n\n- for\n\n### switch语句\n\n**跳转表**：一种用空间换时间的条件匹配策略，这种优化手段通过将每个case标签生成一个唯一的标号，然后创建一个跳转表，其中每个条目对应一个case标签，再通过 jmp 指令，对输入值进行计算，以计算出跳转表的实际索引，然后跳转过去\n\n```asm\njmp qword ptr [8*rdi +.LJTIO_0]\n.LJT10_0:\n  .quad .LBBO 4\n  ...\n```\n\n## 函数调用\n\n- 传递控制\n- 传递数据\n- 分配和释放内存\n\n### 运行时栈\n\n使用栈帧，调用一个方法，就把该方法的变量表、返回地址等压入栈来实现，当从当前方法返回，把当前方法的栈帧弹掉，此时就返回上一个方法了，这点跟[JVM的实现](/编程语言/JAVA/JVM/字节码执行引擎.md#运行时栈帧结构)是一样的\n\n![](/assets/202331095059.jpg)\n\n如果被调用的函数内部没有对其他函数的调用，可以执行一项叫做[函数内联](/编程语言/JAVA/JVM/后端编译与优化.md#方法内联)的优化，内联带来的优化是，CPU 需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了，是一种空间换时间的策略\n\n### 转移控制\n\n保存当前程序地址，将程序计数器设置为新过程地址 返回时读取保存的地址，继续执行\n\n在 x86-64 架构下，其会通过 call 指令将当前的程序地址压入栈中，并跳转到指定的函数地址，被调用的函数通过 ret 指令返回结果\n\n```c\nint foo(int n) {\n    return n +1;\n}\n\nint main() {\n    foo(1);\n    return 1;\n}\n```\n\n```asm\nfoo(int):\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], edi\n        mov     eax, DWORD PTR [rbp-4]\n        add     eax, 1\n        pop     rbp\n        ret\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     edi, 1\n        call    foo(int)\n        mov     eax, 1\n        pop     rbp\n        ret\n```\n\n### 参数传递\n\n![传递函数参数的寄存器](/assets/202331095139.jpg)\n\n### 返回值传递\n\n- 函数调用产生整数类型的返回值，且小于等于 64 位时，通过寄存器 rax 进行传递\n- 大于 64 位，小于等于 128 位时，则使用寄存器 rax 与 rdx 分别存储返回值的低 64 位与高 64 位\n- 对于浮点数类型的返回值，默认使用 xmm0 与 xmm1 寄存器进行存储。而当返回值过大时，则会选择性使用 ymm 与 zmm 来替代 xmm 寄存器\n\n### 栈上的局部存储\n\n### 寄存器中的局部存储空间\n\n- 被调用者保存寄存器\n- 调用者保存寄存器\n\n### 递归过程\n\n### 尾递归优化\n\n在一定条件下，编译器可以直接利用跳转指令取代函数调用指令。尾递归调用的一个重要条件是：递归调用语句必须作为函数返回前的最后一条语句\n\n编译器会使用跳转指令（如je、jne、jle等）来替换函数调用时所使用的 call 指令，这样就\n\n```c\nint f(int i, int sum) {\n    if (i == 0) {\n        return sum;\n    }\n    return (i - 1, sum * i);\n}\n```\n\n```nasm\nf(int, int):\n        mov     eax, esi\n        test    edi, edi\n        je      .L1\n        imul    eax, edi\n.L1:\n        ret\n```\n\n## 数组的分配和访问\n\n### 基本原则\n\n```c\nT A[N]\n```\n\n### 指针运算\n\n&D [ i ] [ j ] = X\n\n<sub>D</sub>\n\nL(Ci+j)\n\n### 定长数组\n\n### 变长数组\n\n## 异质的数据结构\n\n都是对地址进行偏移得到的\n\n- 结构\n- 联合\n- 数据对齐\n\n## 指针\n\n> 在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值\n\n对于这样的一条语句\n\n```c\nint *p = &n;\n```\n\n其会通过 lea 指令找到 n 的地址，然后通过 mov 指令将 n 的值赋给 p\n\n```asm\nlea     rax, [rbp-12]\nmov     QWORD PTR [rbp-8], rax\n```\n\n## 浮点代码\n\n%ymm0 ~ %ymm15\n\n### 浮点传送和转换操作\n\n指令      | 源        | 目的       | 描述\n------- | -------- | -------- | -------------\nvmovss  | $M_{32}$ | X        | 传送单精度数\nvmovss  | X        | $M_{32}$ | 传送单精度数\nvmovsd  | $M_{64}$ | X        | 传送双精度数\nvmovsd  | X        | $M_{64}$ | 传送双精度数\nvmovaps | X        | X        | 传送对齐的封装好的单精度数\nvmovapd | X        | X        | 传送对齐的封装好的双精度数\nvcvttss2si  | $X/M_{32}$ | $R_{32}$ | 用截断的方法把单精度数转换成整数\nvevttsd2si  | $X/M_{64}$ | $R_{32}$ | 用截断的方法把双精度数转换成整数\nvcvttss2siq | $X/M_{32}$ | $R_{64}$ | 用截断的方法把单精度数转换成四字整数\nvcvttsd2siq | $X/M_{64}$ | $R_{64}$ | 用截断的方法把双精度数转换成四字整数\n\n指令         | 源1              | 源2 | 目的 | 描述\n---------- | --------------- | -- | -- | ------------\nvcvtsi2ss  | $M_{32}/R_{32}$ | X  | X  | 把整数转换成单精度数\nvcvtsi2sd  | $M_{32}/R_{32}$ | X  | X  | 把整数转换成双精度数\nvcvtsi2ssq | $M_{64}/R_{64}$ | X  | X  | 把四字整数转换成单精度数\nvcvtsi2sdq | $M_{64}/R_{64}$ | X  | X  | 把四字整数转换成双精度数\n\n### 过程中的浮点代码\n\n使用XMM寄存器来传递浮点参数\n\n### 浮点运算操作\n\n单精度    | 双精度    | 效果            | 描述\n------ | ------ | ------------- | ------\nvaddss | vaddsd | D←S2+S1       | 浮点数加\nvsubss | vsubsd | D←S2-S1       | 浮点数减\nvmulss | vmulsd | D←S2XS1       | 浮点数乘\nvdivss | vdivsd | D←S2/S1       | 浮点数除\nvmaxss | vmaxsd | D←max(S2,S1)  | 浮点数最大值\nvminss | vminsd | D←min(S2,S1)  | 浮点数最小值\nsgrtss | sqrtsd | $D←\\sqrt{S1}$ | 浮点数平方根\n\n### 定义和使用浮点常数\n\n浮点操作不能把立即数作为操作数\n\n编译器必须为所有浮点常量初始化存储空间\n\n### 在浮点代码中使用位级操作\n\n单精度    | 双精度   | 效果      | 描述\n------ | ----- | ------- | ------------------\nvxorps | vorpd | D←S2·S1 | 位级异或(EXCLUSIVE-OR)\nvandps | andpd | D←S2&S1 | 位级与(AND)\n\n### 浮点比较操作","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2024-12-03T17:16:06+08:00","author":"MY","message":"📦计算机系统","hash":"968238728e3c3b13116b44e2bdcaf504962841b9"},{"date":"2024-04-18T19:57:58+08:00","author":"MY","message":"✏C","hash":"768831c0911695fdad43e9f2c7a309a84681ce36"},{"date":"2024-04-17T19:46:39+08:00","author":"MY","message":"✏C","hash":"3aaa22140b04b80f2b53fa1aa8a6808c52ba3367"},{"date":"2024-04-16T19:27:15+08:00","author":"MY","message":"✏C","hash":"99952a8ec19fca0df0f83df82488445c09f39e33"},{"date":"2023-03-10T02:09:03Z","author":"My","message":"📦替换在线图片","hash":"a60815d3119ba219796fc71a6e23d9ea32370701"},{"date":"2019-07-15T10:59:02+08:00","author":"My、","message":"20190715","hash":"1f3f5c1cdf18eb1eae8ca3f0cee4bc0fb8788a31"},{"date":"2019-07-11T21:41:49+08:00","author":"My","message":"20190711","hash":"7f287e7209057694e416992d6ca4b978bf9c6f13"},{"date":"2019-07-09T12:04:41+08:00","author":"My","message":"20190709u","hash":"40dfb8fb151ab4130297729111842624dbb61363"},{"date":"2019-07-06T11:55:58+08:00","author":"My","message":"20190706","hash":"83a03f95e0ae02e0dcdda71139cc3e596f295779"},{"date":"2019-07-05T11:18:55+08:00","author":"My","message":"0190705","hash":"84a16c764900e4d2bb566325420f8ed35dee546b"}],"createTime":"2019-06-19T18:51:46+08:00"}