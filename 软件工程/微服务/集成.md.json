{"name":"集成","id":"软件工程-微服务-集成","content":"# 集成\n\n## 理想的集成技术\n\n- 避免破坏性修改\n  - 一个服务的修改会导致服务的消费方也发生变化\n- 保证API的技术无关性\n  - 也就说，API不管使用什么技术，应该都能实现，保证通信方式的技术无关性是非常重要的，这样各个服务才有可能使用不同的技术实现\n- 使服务易于消费方使用\n- 隐藏内部实现细节\n  - 如果消费方与服务的实现细节绑定在一起，会增加两者间的耦合\n\n## 通信\n\n### 交互方式\n\n- 一对一与一对多\n- 同步与异步\n\n模式   | 一对一          | 一对多\n---- | ------------ | -------------\n同步模式 | 请求/响应        | 无\n异步模式 | 异步请求/响应 单向通知 | 发布/订阅 发布/异步响应\n\n#### 同步还是异步\n\n同步通信，发起一个远程调用后，会阻塞自己并等待整个操作的完成\n\n异步通信，则不需要等待操作结束就可以访问\n\n使用哪种方式，要取决于哪种风格的通信解决的问题\n\n### API定义\n\n如何定义API取决于进程间通信机制。\n\n随着应用演进，API也会随着演进。\n\n- 次要且向后兼容的演进：增加可选属性、添加新操作等\n- 主要且不向后兼容的演进：此时可以引入版本号\n\n### 消息格式\n\n- 基于文本消息格式：xml、json。好处在于可读性高、自描述。缺点在于消息过度冗长。\n- 二进制消息格式：protocol buffers、avro。编译器根据定义的IDL生成序列化与反序列代码。好处性能高。\n\n## 跨服务业务流程\n\n有两种方式：编排与协同\n\n编排是有一个控制中心，指导其他服务应该做些什么，具体怎么做，则交给具体服务\n\n```\n事件发生：\n    控制中心调用服务A\n    控制中心调用服务B\n```\n\n使用这种方式的缺点是会让控制中心承担太多的职责，并会导致少量的“上帝服务（上帝视角）”\n\n若使用协同，则是可以客户触发一个事件，监听到这个事件的具体服务去做一些事情\n\n```\n事件发生：\n    服务A接收到事件，做一些事\n    服务B接收到事件，做一些事\n```\n\n这个方式的优点是能显著地消除耦合，但是缺点是无法看到清晰的业务流程，所以这种方式需要一定的监控手段来保证业务的正确性\n\n### [断路器模式](/软件工程/微服务/服务治理/服务容错.md#断路器模式)\n\n服务保护自己的方式：\n\n- 网络超时：对某个服务的超时不能无限\n- 限制客户端的请求数量\n- 断路器模式\n\n## 同步的编排方式\n\n![屏幕截图 2021-01-19 105517](/assets/屏幕截图%202021-01-19%20105517.png)\n\n### [远程过程调用](/计算机网络/rpc.md)\n\n## 异步的协作方式\n\n同步消息会降低可用性，为消除同步交互，可：\n\n- 使用消息代理来进行异步交互\n- 复制数据来避免与其他服务同步交互\n\n异步协作的两种架构：\n\n- 消息代理：需要一些中间件来实现异步协作，尽量让中间件保持简单\n  - 耦合低\n  - 更为灵活\n  - **额外的复杂性**\n- 无代理架构：直接向服务发送消息\n  - 性能较高\n  - 复杂性较低\n  - **耦合过紧**\n\n![屏幕截图 2021-01-19 142008](/assets/屏幕截图%202021-01-19%20142008.png)\n![屏幕截图 2021-01-19 142721](/assets/屏幕截图%202021-01-19%20142721.png)\n\n可实现的交互方式：\n\n- 请求/响应模型\n- 单向通知\n- 发布订阅\n- 发布/响应\n\n### API规范\n\n![屏幕截图 2021-01-19 142500](/assets/屏幕截图%202021-01-19%20142500.png)\n\n异步操作：\n\n- 请求/异步响应API\n- 单向通知API\n\n记录事件发布API\n\n### 技术选择\n\n- MQ\n- 基于HTTP的发布订阅模式\n\n### 异步架构复杂性\n\n采用异步架构，要考虑的事情就更多了\n\n- 并发与消息顺序\n  - 在kafka中，使用了分片来解决顺序\n- 重复消息\n  - 应用程序需要自己进行幂等处理\n- 事务性消息\n  - 消息队列表与分布式事务\n\n## 按引用访问\n\n在进行事件通知时，传递的数据应该是指向资源的一个引用，这样当其他服务处理这个事件时，就可以根据这个引用得到最新的数据，而避免数据不一致的情况\n\n## 服务即状态机\n\n服务拥有在限界上下文中的所有逻辑，这样可以在唯一一个地方处理逻辑\n\n## 响应式扩展\n\n把多个调用的结果组装起来，并在此上做操作（类似于stream）\n\n## 微服务中代码复用的危险\n\n不同的服务复用同一块代码，一个服务修改的代码很可能影响另一个服务\n\n## 版本管理\n\n- 尽可能推迟修改\n\n**宽进严出原则：对自己发送的东西要严格，对接收的东西可以宽容一点**\n\n- 及早发现破坏性修改\n\n- 使用语义化的版本管理\n  - 通过版本号来告知消费方功能增加或是否向后兼容\n- 多版本接口共存\n- 多版本服务共存\n\n## 用户界面\n\n- 数字化\n  - 未来的需求很难预测，提供细粒度的API\n- 不同场景的约束\n- API的组合\n  - 使用网关来缓解客户端与服务之间的过多交互\n- 服务直接提供UI片段\n\n## [BFF](/软件工程/架构/系统设计/网关.md)\n\n## 服务查询模式\n\n### API组合模式\n\n> 让拥有数据的服务的客户端调用服务，并组件服务返回的查询结果\n\n![屏幕截图 2021-01-26 150338](/assets/屏幕截图%202021-01-26%20150338.png)\n\n问题：\n\n1. 选择谁为组合器\n  - 客户端\n  - 网关\n  - 实现为独立的服务\n2. 如何在组合器编写聚合逻辑\n\n这种方式好处是简单直观。弊端：\n\n- 带来了额外的开销\n- 可用性有降低的风险\n- 查询缺乏数据一致性\n\n### CQRS模式\n\n维护一个或者多个视图数据库，进而实现查询。\n\n![屏幕截图 2021-01-26 154520](/assets/屏幕截图%202021-01-26%20154520.png)\n\n好处与弊端：\n\n- 高效实现多个服务的多种类型查询\n- 支持[事件溯源](/软件工程/微服务/业务逻辑.md#事件溯源)技术\n- 隔离了问题：领域模型不必同时处理命令和查询\n\n- **架构更加复杂**\n- **数据有一定的延迟**\n\n#### CQRS视图设计\n\n- 选择合适的数据库\n  - SQL or NoSQL\n- 数据访问模块\n  - 并发处理\n  - 幂等处理\n- 更新视图\n  - 归档\n  - 快照\n","metadata":"tags: ['微服务']","hasMoreCommit":false,"totalCommits":3,"commitList":[{"date":"2024-11-25T14:06:28+08:00","author":"MY","message":"📦微服务","hash":"984b0cab1bfa9822163a0947a83e9fea875c581a"},{"date":"2021-01-19T14:48:42+08:00","author":"cjiping","message":"✏更新 微服务 通信","hash":"849267504d6aec26829ac6f242e46a826615c83b"},{"date":"2020-02-10T15:48:13+08:00","author":"MY","message":"微服务增加集成的相关内容","hash":"62d15f0f896dda77874d507b847af34e0c761c6b"}],"createTime":"2020-02-10T15:48:13+08:00"}