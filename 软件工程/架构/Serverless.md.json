{"name":"Serverless","id":"软件工程-架构-Serverless","content":"\n# Serverless\n\n- 对服务器的关心少一点\n\n狭义 Serverless（最常见）= Serverless computing 架构 = FaaS 架构 = Trigger（事件驱动）+ FaaS（函数即服务）+ BaaS（后端即服务，持久化或第三方服务）= FaaS + BaaS\n\n广义 Serverless = 服务端免运维 = 具备 Serverless 特性的云服务\n\n## FaaS\n\n![函数计算架构](/assets/2023529103428.webp)\n\n### 分层\n\n- 容器：操作系统\n  - 运行时：语言技术栈支持\n    - 函数代码\n\n分层的好处在于容器可以被预热，并且缓存，资源可以统筹优化，公共服务能力可以被提取\n\n当一段时间内没有用户请求时，则会销毁函数实例，这样子可以达到缩容为 0\n\n运行时主要做三件事：\n\n- 获取请求信息\n- 关联用户代码\n- 调用用户代码处理请求。\n\n### 冷启动\n\n![冷启动](/assets/202212717391.webp)\n\n预热冷启动：利用构建好的缓存镜像，直接跳过冷启动的下载函数代码步骤，从镜像启动容器\n\n平台侧的优化：\n\n- 镜像加速手段优化资源调度和容器创建\n- 包的缓存、极致的压缩和内置化通用依赖\n- 利用代理模式的方法进行 VPC网络加速\n- 通过函数实例的预测算法，提前加载接下来会被调用的函数\n\n用户侧的优化：\n\n- 合理控制代码包大小\n- 选择性能较高的运行时\n- 预留实例和定时预热\n- 合理利用本地缓存\n\n### 灰度发布\n\n```mermaid\nsequenceDiagram\n    participant 用户\n    participant HTTP 触发器\n    participant 函数计算平台\n    participant 别名\n    participant 主版本\n    participant 新版本\n\n    用户 ->> HTTP 触发器: 发起请求\n    HTTP 触发器 ->> 函数计算平台: 解析请求\n    函数计算平台 -->> HTTP 触发器: 返回版本号\n    HTTP 触发器 ->> 别名: 解析版本号\n    别名 ->> 主版本: 处理请求\n    主版本 -->> 别名: 返回结果\n    别名 -->> HTTP 触发器: 返回结果\n    HTTP 触发器 -->> 用户: 返回结果\n\n    alt 需要切换流量至新版本\n        用户 ->> 函数计算平台: 请求切换流量\n        函数计算平台 ->> 别名: 更新别名指向新版本\n        别名 -->> 用户: 切换成功\n    else 不需要切换流量\n        用户 ->> 函数计算平台: 请求不切换流量\n        函数计算平台 -->> 用户: 操作完成\n    end\n\n    用户 ->> HTTP 触发器: 发起请求\n    HTTP 触发器 ->> 函数计算平台: 解析请求\n    函数计算平台 -->> HTTP 触发器: 返回版本号\n    HTTP 触发器 ->> 别名: 解析版本号\n    别名 ->> 主版本: 处理请求\n    主版本 -->> 别名: 返回结果\n    别名 -->> HTTP 触发器: 返回结果\n    HTTP 触发器 -->> 用户: 返回结果\n\n```\n\n### 削峰容灾\n\n```mermaid\nsequenceDiagram\n    participant 请求方\n    participant 消息队列\n    participant 函数计算平台\n    participant 后端资源池\n    participant 容灾队列\n    participant 容灾处理函数\n\n    请求方 ->> 消息队列: 发起请求\n    消息队列 ->> 函数计算平台: 接收请求\n    函数计算平台 ->> 后端资源池: 调度请求\n    后端资源池 -->> 函数计算平台: 返回处理结果\n    函数计算平台 -->> 请求方: 返回结果\n\n    alt 削峰处理\n        请求方 ->> 消息队列: 发起突增流量请求\n        消息队列 ->> 函数计算平台: 接收突增流量请求\n        函数计算平台 ->> 后端资源池: 调度突增流量请求\n        后端资源池 -->> 函数计算平台: 返回处理结果\n        函数计算平台 -->> 请求方: 返回结果\n    else 容灾处理\n        请求方 ->> 消息队列: 发起请求\n        消息队列 ->> 函数计算平台: 接收请求\n        函数计算平台 ->> 后端资源池: 调度请求\n        后端资源池 -->> 函数计算平台: 返回错误信息\n        函数计算平台 ->> 容灾队列: 将错误信息发送到容灾队列\n        容灾队列 ->> 容灾处理函数: 接收错误信息\n        容灾处理函数 -->> 后端资源池: 重新调度请求\n        后端资源池 -->> 容灾处理函数: 返回处理结果\n        容灾处理函数 -->> 请求方: 返回结果\n    end\n\n```\n\n### 进程模型\n\n- 用完即毁型：函数实例准备好后，执行完函数就直接结束，是天然的 Stateless\n- 常驻进程型：函数实例准备好后，执行完函数不结束，而是返回继续等待下一次函数被调用，是天然的 Stateful\n\n### 触发器\n\n```mermaid\nsequenceDiagram\n    participant 用户\n    participant 函数计算平台\n    participant MinIO\n    participant 事件监听器\n    participant 数据库MySQL\n    participant 远端云函数\n\n    用户->>函数计算平台: 绑定自定义触发器\n    Note over 函数计算平台: 设置事件源标识\n\n    loop 监听事件\n        MinIO->>事件监听器: 发生上传文件动作\n        事件监听器->>数据库MySQL: 查询触发器\n        数据库MySQL-->>事件监听器: 返回触发器信息\n\n        loop 逐个触发触发器\n            事件监听器->>远端云函数: 触发调用\n            Note over 远端云函数: 执行相应操作\n            远端云函数-->>事件监听器: 返回结果\n        end\n    end\n```\n\n触发器类型：单向集成触发器、双向集成触发器和代理集成触发器。它们的区别在于事件源和事件的规则存储在哪里，以及从哪里触发\n\n### 扩缩容\n\n云厂商容器调度服务通常有两种调度形态，一种是基于节点 Node 调度的方式，一种是基于容器实例的方式\n\n```mermaid\ngraph TD;\n    A[选择指标] --> B[收集指标];\n    B --> C[决策扩缩容];\n    C --> D[执行扩缩容];\n    D --> E[资源调整];\n    C --> F[调度方式];\n    F --> G[及时扩容];\n    F --> H[延时扩容];\n    C --> I[决策模式];\n    I --> J[稳定模式];\n    I --> K[恐慌模式];\n    J --> L[资源数量维护];\n    K --> L;\n```\n\n### 流量转发\n\n![冷启动下的流量转发](/assets/2023531102952.jpg)\n\n异步下的流量转发主要通过事件 / 消息队列的方式来缓冲一步，然后通过异步处理模块，按照同步请求的请求机制来处理\n\n### 数据编排\n\n前端的一个数据请求过来，函数触发器触发我们的函数服务；我们的函数启动后，调用后端提供的元数据接口，并将返回的元数据加工成前端需要的数据格式\n\n### 服务编排\n\n和数据编排很像，主要区别是对云服务商提供的各种服务进行组合和加工。这些步骤通常通过 JSON 或者 YAML 的格式定义好函数之间的协作关系存在，通过顺序、分支、并行的方式来协调一个或多个分布式任务，这些任务不仅包括函数，还可以是服务和应用的形式，并且还能使用平台提供的状态跟踪、日志记录和异常重试逻辑\n\n![](/assets/202361153016.webp)\n\n- 长流程场景\n- 事务型业务流程\n- 并发型业务流程\n- 需要状态全链路监测的场景\n\n### 数据存储\n\n控制面：\n\n- 函数元数据：关系型数据库\n- 函数代码：对象存储、镜像存储\n\n数据面：\n\n- 报表数据：MPP数据库\n- 服务状态：KV数据库\n\n## BaaS\n\nFaaS 提供业务逻辑层的处理，BaaS 提供基础服务层的能力，让有状态的数据、过程消息等存储在 BaaS 化的服务中，BaaS 弥补了 FaaS 的无状态，数据库、消息队列都可以 BaaS 化，可以拥有自己的生命周期，使用完即销毁\n\n- 不用运维的微服务\n\n## 私有Serverless\n\n- Knative\n\n## 平台设计\n\n### 函数管理\n\n- 需要集成函数的创建、配置、部署发布、测试、删除、上下线功能，并且支持底层资源规格的选取\n- 需要提供多种函数语言的开发，适配不同操作系统镜像\n\n### 平台管控\n\n- 用户隔离\n- 鉴权验证\n- 用户角色和权限管理\n\n### 资源控制\n\n- 需要支持计量计费及对资源的使用限制\n\n### 用户角色和权限管理\n\n- CLI 命令\n- WebIDE\n\n### 高可用\n\n### 可观测","metadata":"","hasMoreCommit":false,"totalCommits":8,"commitList":[{"date":"2023-06-06T16:02:39+08:00","author":"MY","message":"✏Serverless","hash":"4c130c6c7b8e674a1ccdd8c438a9eecd16b601ad"},{"date":"2023-06-05T17:17:22+08:00","author":"MY","message":"✏Serverless","hash":"a1d2aeb3541dcaf9fc8c11136cf06095e130396e"},{"date":"2023-06-01T17:14:59+08:00","author":"MY","message":"✏Serverless","hash":"d9cbafa1870feb8afe37ff6b07e6fce537534d24"},{"date":"2023-05-31T16:28:22+08:00","author":"MY","message":"✏Serverless","hash":"3bc47552eaeba413c24cca25d3266b756087baf0"},{"date":"2023-05-30T17:31:44+08:00","author":"MY","message":"✏Serverless","hash":"fe35a7e3a7b536d02c59bbefcb8460f69cbc2c00"},{"date":"2023-05-29T17:21:59+08:00","author":"MY","message":"✏Serverless","hash":"c78c0f2f0f27cf704857d2dec910e57302c2eb47"},{"date":"2022-12-08T16:46:51+08:00","author":"cjiping","message":"✏️Serverless","hash":"806519a744752dd50380eb86c0c2a758867cdb7c"},{"date":"2022-12-07T17:45:41+08:00","author":"cjiping","message":"➕Serverless","hash":"b49987d980ad4af406aef7fe49427c2bed3f0374"}],"createTime":"2022-12-07T17:45:41+08:00"}