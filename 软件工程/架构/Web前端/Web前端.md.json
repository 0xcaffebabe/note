{"name":"Web前端","id":"软件工程-架构-Web前端-Web前端","content":"# Web前端\n\n![屏幕截图 2020-12-01 155259](/assets/屏幕截图%202020-12-01%20155259.png)\n\n## 浏览器组成\n\n### 渲染引擎\n\n解析HTML构建DOM树 -> 构建渲染树 -> 渲染树布局阶段 -> 绘制渲染树\n\n页面生成后 如果页面元素位置发生变化 就要从布局阶段开始重新渲染\n\n#### HTML解析\n\n![token解析](/assets/202275155334.webp)\n\n当进行token解析后，就可以利用栈来构建一颗DOM树\n\n#### CSS解析\n\n依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整\n\n选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息\n\n因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建，这点跟原则冲突，所以目前并没有父元素选择器这种玩意\n\n### 持久化存储机制\n\n- HTTP缓存\n- localSorage：单个域下存放容量有限\n- sessionStorage：浏览器关闭自动清空\n- Cookie\n  - sessionCookie\n  - HTTP only\n- WebSQL：特定浏览器的特性\n- IndexDB：NoSQL类型的数据库 大小限制50M\n- Application Cache\n  - 渐渐废弃 使用ServiceWorkers替代\n- cacheStorage\n  - ServiceWorker规范中的Cache对象\n- Flash缓存\n\n### 浏览器Web安全\n\n- X-XSS-Protection\n  - 控制浏览器对反射型XSS的防护\n- Strict-Transport-Security\n  - 强制所有通信使用HTTPS\n- Content-Security-Policy\n  - 控制浏览器只信任来自指定源的内容\n- Access-Control-Allow-Origin\n\n## 前端与协议\n\n- HTTP\n\n### 实时协议\n\n- WebSocket\n- Poll（轮询）：实时性差 影响性能\n- Long-poll（长轮询）：比上面好一点\n- 前端DDP（分布式数据协议）\n  - meteor：服务端-客户端双向数据更新\n\n### Native交互协议\n\n混血应用特性：\n\n- 可用系统资源少\n- 浏览器内核支持较新的特性\n- 可实现离线应用\n- 机型兼容（屏幕兼容）\n- 支持与Native交互\n\nWeb到Native协议调用：\n\n- 通过URI\n  - Web应用通过发起一个URI请求 Native会进行捕获\n- addJavascriptInterface\n  - Native会注入一个全局对象给Web调用\n\nNative到Web：\n\n- Native通过loadURL调用Web暴露的全局对象或者方法\n\n#### JSBridge协议规范\n\n- Native注册一个自定义JSBridge Schema头\n  - 协议URL由几部分组成：欲被调用的类名、回调方法、欲被调用的方法、json对象（调用方法的参数）\n\n## 三层结构\n\n### 结构层\n\nXML -> HTML -> HTML5\n\nDOCTYPE：指示浏览器使用哪个HTML版本编写的指令进行解析\n\n语义化标签：语义化标签帮助人更容易理解\n\nAMP HTML：提升页面资源载入效率的规范\n\nShadow DOM：用来支持实现Web Component，如video标签等，其不会被外界的css或者js所影响\n\n### 浏览器脚本\n\nES5 -> CoffeScript -> ES6 -> TS\n\n### 表现层\n\nCSS\n\nCSS统一处理：\n\n- reset：清除所有元素默认样式\n- normalize：为所有元素增加默认样式\n- neat：上面两种方式的组合\n\nCSS预处理：sass less ...\n\n一个良好的预处理器的功能：\n\n- 变量声明计算\n- 语法表达式 if-else for\n- 函数处理\n- 属性继承\n- 兼容性补全 自动添加浏览器私有前缀\n\n动画实现：\n\n- js实现：由于频繁重绘 非常消耗性能\n- SVG动画：比js实现功能会更丰富 但一旦复杂起来 仍会影响性能\n- CSS3 transition：只能实现过渡变化\n- CSS3 animation：脱离JS 可以硬件加速 复杂动画也能应付\n- Canvas 动画：本质是通过js控制标签来实现\n\n### 响应式页面\n\n- 基于UA跳转\n- 基于媒体查询响应式\n\n#### 结构层响应式\n\n- 结构层数据响应式\n  - 在前端判断不同端加载不同的数据\n- 后端数据响应式\n  - 后端渲染时直接判断 差别渲染\n- 结构层媒体查询\n  - 根据不同的屏幕渲染不同的图片 节省流量\n  - Picture 可以包含多个图片 自动进行选择（Polyfill）\n  - 后端模板判断渲染不同图片\n  - CDN\n\n#### 表现层响应式\n\n- 响应式布局：栅格布局\n- 屏幕适配布局：viewport\n  - 控制zoom\n  - REM适配\n\n#### 行为层响应式\n\n- 通过js进行判断执行不同脚本\n- 后端判断直接渲染不同脚本\n\n## 现代前端交互框架\n\n### 直接DOM操作\n\n随着AJAX技术的发展 在DOM操作上面也越来越复杂\n\n这个时期的代表性框架就是jQuery，其主要功能就是封装了浏览器的DOM API\n\n### MV*交互\n\n- 前端MVC\n\n通过将组件的数据及行为划分到 M V C 来进行管理，由系统统一来控制\n\n![屏幕截图 2020-12-04 092957](/assets/屏幕截图%202020-12-04%20092957.png)\n\n- 前端MVP\n\n使用P来处理逻辑 M 和 V 只反映视图和数据\n\n![屏幕截图 2020-12-04 093202](/assets/屏幕截图%202020-12-04%20093202.png)\n\n各个部位职责更清晰 但是P的内容变得很重\n\n- 前端MVVM\n\n自动化的MVP 使用ViewModel 替代 P，这样数据的变化就会自动影响到识图 反之亦然\n\n#### 数据更新检测\n\n- 手动触发更新\n- 脏检测机制：当ViewModel的某个值发生变化时找到其相关联的所有元素 然后比较更新\n- 前端数据对象劫持：通过Object.defineProperies来监听get和set，当发生变化 则需要运行相对应节点的指令\n- ES6 Proxy：实现效果跟上面一样\n\n### Virtual DOM交互\n\n通过新建一个虚拟的DOM数据结构 并将其与真实DOM对比 找出差异部分进行更新\n\n![屏幕截图 2020-12-04 095325](/assets/屏幕截图%202020-12-04%20095325.png)\n\n#### 核心实现\n\n- 将真实DOM转换为虚拟DOM：\n\n自己解析HTML而非使用DOM API来生成\n\n- 对比虚拟DOM\n\n使用多叉树遍历算法 DFS或者BFS 遍历过程中需要记录节点改变的内容、差异化改变的类型及位置（在哪里增加、删除等）\n\n### 前端MNV*\n\nModel Native View *\n\nJS调用原生控件或者事件绑定\n\n## 前端开发规范\n\n### 通用规范\n\n- 三层结构分离：js css html 分离\n- 缩进保持一致\n- 内容编码：为html指定utf8编码\n- 注意大小写的使用场景\n  - html属性名一律使用小写以-分割\n  - 属性值可以使用驼峰命名\n- 代码单行长度限制\n- 注释可以参考java\n  - 代码自描述\n- 删除行尾空格及符号\n\n### HTML规范\n\n- 文档类型定义统一使用HTML5的!DOCTYPE 避免使用HTML4的DTD定义\n- head必须定义title keyword description等基本SEO字段 移动端注意定义viewport\n- 引入style标签或者script标签可以省略type属性\n- 标签属性值统一使用双引号\n- 诸如readonly disabled等属性的属性值可以省略\n- 元素标签必须正确嵌套 尽量使用语义化标签\n- 非自闭和标签需要添加关闭标识 自闭和标签无需添加（img br）\n- 避免img的alt属性为空\n- label标签经历增加for属性与输入域进行关联\n- 按模块添加注释 start end\n- 标签元素格式：块级元素另起一行 行内元素根据情况内联或者换行\n\n### CSS规范\n\n- 尽量使用外部样式文件，避免使用内联样式\n- 命名：避免过于笼统，根据功能和内容进行命名，可以根据需要统一添加某种前缀\n- 简写\n  - 值为0可以省略单位\n  - 0.x的单位可以省略0\n  - 颜色尽量缩写到3位\n- 属性书写顺序：优先写布局元素，然后再写元素的内容属性\n- 避免CSS奇淫技巧\n- 若要兼容多种浏览器私有样式 则私有样式写前 标准样式写后\n- 避免类名或ID与类选择器组合使用 会造成冗余\n- 使用简短的CSS实现 合并写法\n- 元素之间存在继承关系时 提取公共部分 避免重复定义\n- 使用预处理来提高编码效率\n\n### ES5规范\n\n- 语句添加分号结束可以使语句之间关系更清晰\n- 在合适的地方添加空格\n- 代码块后留空一行，使内容块更有层次\n- 字符串最外层统一使用单引号\n- 变量命名参考JAVA\n- 对象属性名不需要引号\n- 对象属性过多可以使用缩进的方式书写\n- 代码块必须加花括号\n- 不适用undefined直接进行判断 可以使用typeof\n- 避免使用 != ==\n- 禁止在条件语句或者循环语句里声明函数\n- for-in循环访问属性前要判断 避免访问不存在的属性报错\n- 避免在Array Date基础类库对象原型添加方法 否则会污染JS内置对象\n\n### ES6规范\n\n- 正确使用变量声明let const\n- 字符串拼接尽量使用模板字符串\n- 解构赋值尽量只使用一层\n- 数据拷贝使用...来高效简洁实现\n- 数组循环遍历优先使用for...of\n- 尽量使用ES6的class实现oop\n- 模块化多变量导出尽量使用对象结构 不要讲import和export写在同一行\n- 导出类时，保持模块名称和文件名相同\n- 生成器yield使用时需要注意对异常的处理\n- 使用Promise代替回调\n- 尽量避免使用迭代器 性能太差\n- 推荐使用async await\n\n### 防御性编程规范\n\n- 对于外部传入的数据 需要做校验 避免为空导致的模板报错\n- 注意错误处理\n\n## 前端组件规范\n\n### UI组件规范\n\n- 统一的页面布局方案\n- 基础UI结构和样式实现\n- 组件化UI结构和样式实现\n- 响应式布局\n- UI可扩展性\n\n### 模块化规范\n\n- AMD 浏览器端的模块化异步加载规范\n- CMD 用到模块才会执行\n- CommonJS Node端使用的模块化规范\n- import/export ES6定义的规范\n\n### 项目组件化规范\n\n- Web Component 组件化\n- MVVM框架组件化 每个组件以单文件的形式引入模块 通过构建或者动态解析的方式注入到页面\n- 虚拟DOM组件化 reactjs为代表的jsx\n- 基于目录管理的通用组件化\n\n组件化规范应该解决的问题：\n\n1. 组件之间独立 松耦合\n2. 组件可以嵌套使用\n3. 组件通信问题\n4. 组件公用部分设计\n5. 组件构建打包\n6. 异步组件加载\n7. 组件继承与复用\n8. 私有组件的管理\n\n## 自动化构建\n\n目的：对源项目文件或资源进行文件级处理 将文件或资源处理成最佳输出结构和形式\n\n![屏幕截图 2020-12-08 100242](/assets/屏幕截图%202020-12-08%20100242.png)\n\n### 构建工具的设计\n\n- 模块分析引入：通过分析依赖调用生成AST，生成依赖字典\n- 模块化规范支持：目前较多的构建工具都是将ES6转换为ES5 构建工具应尽可能支持较多标准\n- CSS编译 图片合并\n- 资源压缩优化\n- 路径分析替换\n- 环境区分\n- 异步文件打包\n- 文件目录白名单\n\n## 前端用户数据分析\n\n### 用户访问统计\n\n- PV\n- UV\n  - IP配合其他手段\n- VV:对用户访问网站多次跳转统计为一次VV\n- IP\n\n### 用户行为分析\n\n- 页面点击量\n  - 页面某个区域点击量\n- 用户点击流\n  - 在用户一次VV记录用户的点击行为\n- 用户访问路径\n- 用户点击热力图\n- 用户转化率：访问用户与注册用户之比\n- 导流转化率：原页面与导流页面之比\n- 访问时长\n\n### 前端日志上报\n\n- 性能日志上报\n- 错误日志上报\n\n获取错误日志方式：\n\n- try catch：无法捕获语法错误 无法捕捉不同作用域\n- window.onerror：功能比try catch全 ，但无法处理跨域情况\n\n错误信息上传：\n\n- 如果访问量大 注意按一定条件上传\n\n错误排查：\n\n- 对错误归类 注意版本问题\n\n## 前端跨栈技术\n\n### 后端：node\n  - web框架：koa，express\n  - 后端数据渲染\n  - 前后端同构\n    - 基于模板：不同的请求渲染不同的模板\n    - 基于MVVM：在服务端对MVVM模板语法直接渲染\n    - 基于虚拟DOM\n\n### 跨终端\n\n- 前端为主:直接将前端页面打包进安装包 主要执行这些页面\n- Native和Web结合：分别实现自己最擅长的\n  - 自己设计交互协议\n- Web资源离线和更新\n  - serviceWorker\n  - localStorage\n  - 基于增量文件\n  - 基于文件代码块\n- Native与Web资源离线和更新\n  - 根据时机向服务端主动拉取 否则使用本地缓存\n- 资源覆盖率统计\n  - 日志上报\n\n### 其他\n\n- 前端代码编译为Native\n- 桌面应用\n\n## 趋势\n\n- 标准技术趋向于稳定\n- 工具仍会持续不断发展\n- 浏览器平台新特性未来应用的可能\n- 前端开发生态\n  - 效率\n  - 维护成本\n  - 性能\n  - 扩展性\n- 前端新领域\n  - 物联网\n  - AI\n  - VR\n","metadata":"","hasMoreCommit":true,"totalCommits":13,"commitList":[{"date":"2022-07-05T17:06:37+08:00","author":"cjiping","message":"✏️更新 前端","hash":"1de088468c1e1dbc171fc7e645482d88fe913634"},{"date":"2021-12-01T17:53:59+08:00","author":"cjiping","message":"✏️更新 前端性能优化","hash":"2f287b526f87a96f7bda72143a00869bbec70bf8"},{"date":"2020-12-14T09:27:27+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"d288ce705ffb52c3eb1c9721d2b924f7f6aa20fd"},{"date":"2020-12-11T11:06:23+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"7575218e9957e92b3e7becdd86a795a5c7e1f76c"},{"date":"2020-12-10T10:44:49+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"6405f178476cb766da64809b02ef1615ed6fbea3"},{"date":"2020-12-08T11:02:16+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"0b4255a1ecd318e251ee9411a4a23bc04b0cc0aa"},{"date":"2020-12-07T16:23:59+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"3ed3d1e78caa153fb1df19cff818e4c81693a6e2"},{"date":"2020-12-05T09:54:22+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"37b3aaa45a2788d91241722cb2c3aca47dd093b5"},{"date":"2020-12-04T10:27:07+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"cd8a63e90394bd39c9b8a05d7ce76b571ec8af30"},{"date":"2020-12-03T11:45:01+08:00","author":"cjiping","message":"✏更新 Web前端","hash":"002ff79d1d310c3edb8f45846844298f0da54024"}],"createTime":"2020-12-01T15:35:27+08:00"}