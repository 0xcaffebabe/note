# 缓存

## 特征

### 命中率

某个请求能够通过访问缓存而得到响应时，称为缓存命中
缓存命中率越高，缓存的利用率也就越高

### 最大空间

缓存的利用空间是有限的
当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据

### 淘汰策略

- FIFO
- LRU
- LFU

## 位置

- 浏览器缓存
- ISP缓存
  - ISP是网络访问的第一跳，这个地方有缓存能大大加快用户的访问速度
- 反向代理缓存
- 本地缓存
  - 这里指的是将缓存存放在服务器进程内
- 分布式缓存
  - 使用专门的服务器集群来存放缓存
- 数据库缓存
  - 一般数据库都有自己的缓存机制
- CPU缓存

## cdn

## 缓存问题

### 缓存雪崩

由于于数据没有被加载到缓存中或者缓存都采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩

#### 解决方案

- 锁
  - 比如对某个key只允许一个线程数据库查询数据和写缓存，其他线程等待
  - 但是这样就只能限制同一时间只能有一个线程访问数据库，吞吐量还是不行
- 消息中间件
  - 缓存中间件没有命中的情况下，生产者将数据库查询请求通过消息中间件发送给消费者，消费者查询数据库后再返回给生产者，生产者再返回给客户端，MQ具有削峰的功能，能缓解数据库过高的请求压力
- 使用多级缓存以及分布式缓存
- 分析用户的行为，尽量让缓存失效的时间均匀分布

### 缓存穿透

指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样就会导致每次查询不存在的数据都会绕过缓存去查询数据库

#### 解决

把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透
也可以直接对这类请求进行过滤

### 缓存一致性

要求数据更新的同时缓存数据也能够实时更新

#### 解决

- 当数据更新的同时立即去更新缓存
- 读缓存之前判断缓存是否是最新，否则先进行更新缓存

保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据

### 缓存无底洞

随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作

#### 解决

- 优化细粒度的远程调用
- 减少网络通信次数
- 使用长连接或者连接池

### 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题

#### 解决方案

- 锁
- 不设置过期时间，而将过期时间设置在数据中，如果检测到数据过期了，再清除掉

## 数据分布

### 哈希分布

哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上

传统的哈希分布算法存在一个问题：当节点数量变化时，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移

### 顺序分布

将数据划分为多个连续的部分，每个节点固定存放一定范围内的数据，按数据的 ID 或者时间分布到不同节点上

可以保持数据的顺序，并且可以控制服务器的数据量

## 一致性哈希

Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题

将哈希空间看做一个环，服务器节点分布在这些环上，当一个数据计算出哈希值后，找出这个哈希值后面最近的一台服务器，将数据存放到这台服务器上

![2020317153322](/assets/2020317153322.jpg)

当服务器节点发生变更，受到影响的，只是变更节点的后一台服务器，只需对这台服务器的数据进行重新再计算哈希即可

![2020317153440](/assets/2020317153440.jpg)

### 虚拟节点

一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同

那么就可以通过增加虚拟节点的方式，把这些节点映射到真正的服务器节点，使得数据分布更加均匀

