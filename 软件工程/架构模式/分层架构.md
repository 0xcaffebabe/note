---
tags: ['数据技术', '软件工程']
---

# 分层架构

> 分层架构是所有软件架构的基础模型，是"稳定核心 + 可替换实现"的结构化设计方式。无论是 DDD、六边形架构、整洁架构，都可视为分层架构的演进形态。

## 本质：稳定性梯度（Stability Gradient）

系统内部存在不同变化速度的模块，分层即是：

```
按变化速度分区，把稳定的放核心，把易变的放边缘
```

稳定性从高到低示意：

```
Domain（本质规则）   ← 最稳定
Application（用例编排）
Presentation（交互协议）
Infrastructure（技术细节） ← 最易变
```

## 分层的目标（而非手段）

| 目标     | 解释                      |
| ------ | ----------------------- |
| 关注点分离  | 每层只关心本层的问题，不跨层思考        |
| 隔离变化   | 外部变化（协议、技术栈）不影响核心业务     |
| 建立清晰边界 | 结构化组织业务、技术、协作           |
| 提升可测试性 | 纯业务逻辑可独立测试              |
| 提升可演进性 | 基础设施可替换（DB/Cache/消息中间件） |

## 分层的黄金原则（核心规则）

### （1）依赖倒置原则 DIP

* 高层策略（Domain）不依赖低层细节（Infra）
* 由接口定义依赖方向

### （2）依赖单向流动（Unidirectional Dependency）

```
Presentation → Application → Domain → Infrastructure（接口）
Infrastructure 实现 Domain 所定义的接口
```

### （3）稳定性递增（Stability Increasing Toward Center）

越往内层越稳定，越难变化。

# 分层架构元模型（Meta Model）

这是本文最核心的抽象。

下面是一个标准 Layered Architecture 模型：

```
┌────────────────────────────┐
│        Presentation          │  ← 输入协议（API/GUI/消息）
└────────────────────────────┘
┌────────────────────────────┐
│        Application          │  ← 用例编排/事务管理/流程控制
└────────────────────────────┘
┌────────────────────────────┐
│          Domain             │  ← 业务本质（实体/值对象/规则/策略）
└────────────────────────────┘
┌────────────────────────────┐
│       Infrastructure        │  ← DB/Cache/MQ/HTTP/Config 实现
└────────────────────────────┘
```

## 各层职责、输入、输出

| 层              | 核心职责          | 输入              | 输出                     |
| -------------- | ------------- | --------------- | ---------------------- |
| Presentation   | 协议适配、参数校验、序列化 | HTTP/GRPC/消息    | DTO                    |
| Application    | 编排业务用例、事务、流程  | DTO             | Command / Domain Model |
| Domain         | 业务规则、实体、策略、限制 | Command         | Result / Event         |
| Infrastructure | 技术细节实现        | Repository 接口调用 | Data                   |

## 如何判断"是否越界"？

越界访问例子（❌）：

* Controller 直接访问 Repository
* Domain 调用 MQ
* Domain 依赖 Spring 配置
* View 直接操作数据库

越界属于"架构腐化"的主要原因之一。

# 为何分层（价值体系）

## 降低复杂度

每层只关注自己的抽象，不关注细节。

## 隔离变化

* 技术变化不影响业务（如 DB → Redis）
* 表现形式变化不影响业务（Web → App → IoT）

## 提高扩展性

* 可以替换基础设施
* 可以添加新的表现方式
* 可以横向扩展层级

## 可测试性提升

* Domain 可做纯单元测试（无外部依赖）
* Application、Infra 可独立集成测试

# 分层架构的常见问题 & 反模式

## ❌ 层次过多，导致性能差

反例：

* 工具类放在单独一层
* Repository 包装 Repository
* DTO 做两层转换

改进：**按变化速度，而非物理层数进行分层。**

## ❌ Application 层过度膨胀

原因：

* 所有逻辑都写在 Service 里
* 领域没有模型，导致"贫血领域"

改进：将业务规则下沉到 Domain。

## ❌ 基础设施反向依赖领域

例如 Domain 依赖 Spring、Redis、MySQL、MQ 等。

改进：**Infrastructure 依赖 Domain，不允许反向依赖。**

## ❌ 缺乏边界限制

没有静态规则约束，导致循环依赖、跨层访问。

改进：使用 ArchUnit/Sonar 构建架构治理规则。

# 分层架构的模型扩展

## 分层架构与现代架构的关系

| 模型       | 核心思想   | 与分层关系   |
| -------- | ------ | ------- |
| 六边形架构    | 端口-适配器 | 分层的强抽象版 |
| 整洁架构     | 同心圆稳定性 | 分层进阶    |
| DDD 分层架构 | 领域中心化  | 分层+业务建模 |

本质：**都是分层思想的递进。**

### MVC / MVP / MVVM 属于"表示层内部模式"

需强调：

### ❗它们不是系统分层架构

MVC/MVP/MVVM 解决的是"表示层内部职责分离"，属于 Presentation 层子模式。

# 架构选型指南（极重要）

| 场景          | 是否建议分层                     | 原因             |
| ----------- | -------------------------- | -------------- |
| 中小型后台系统     | ✓ 强烈建议                     | 可维护性高          |
| 中台/核心业务系统   | ✓ 必须                       | Domain 稳定层非常关键 |
| 高性能网关       | ✗ 不建议复杂分层                  | 延迟敏感           |
| 简单 CRUD API | △ 轻量分层即可                   | 避免过度工程化        |
| 微服务         | ✓ 建议两层（Application+Domain） | 简化内部结构         |

# 分层架构的治理体系（落地关键）

## 依赖扫描

* ArchUnit（Java）
* ESLint（JS）
* Sonar
* Structure101

## 边界规范

* 不允许跨层访问
* Domain 不允许依赖外部框架
* Infra 代码必须通过接口定义访问 Domain

## 测试矩阵

| 层              | 测试方式    |
| -------------- | ------- |
| Presentation   | API 测试  |
| Application    | 集成测试    |
| Domain         | 纯单测     |
| Infrastructure | Mock 测试 |

# 分层架构的演进路线（架构认知的核心）

```
三层架构（Controller-Service-DAO）
        ↓ 识别贫血模型问题
分层架构（Presentation-App-Domain-Infra）
        ↓ 技术/业务解耦
DDD 分层架构（Domain 强化）
        ↓ 接口化驱动
六边形架构 / 整洁架构（端口驱动）
        ↓ 云原生
多端协作 / 无服务化架构（BFF + 边缘层）
```

你可以看出：
**所有现代架构都是分层架构的加强版，而非替代方案。**

# 完整对照示例（传统 vs 现代）

## 传统三层架构

```
Controller → Service → DAO → DB
```

## 现代分层架构

```
Controller
   ↓
Application（用例编排）
   ↓
Domain（业务规则、实体）
   ↓
Infrastructure（DB、MQ、Cache 具体实现）
```

优势：

* 业务核心不依赖技术栈
* 实现可替换
* 增加新表现层无需动领域层

## 总结

> **分层架构本质是把"稳定的业务本质"与"易变的技术细节"分开，使系统能够长期保持可维护、可演进，并能以最小代价适应前端、协议、技术栈的变化。**

## 关联内容（自动生成）

- [/软件工程/领域驱动设计.md](/软件工程/领域驱动设计.md) 分层架构与领域驱动设计紧密结合，DDD 的分层架构将业务核心（Domain）作为稳定层
- [/软件工程/架构/架构治理.md](/软件工程/架构/架构治理.md) 分层架构需要架构治理来维护各层边界，防止跨层访问和架构腐化
- [/数据技术/数据分层.md](/数据技术/数据分层.md) 数据分层与系统架构分层有相似的稳定性梯度原理，都是为了隔离变化
- [/软件工程/架构/架构.md](/软件工程/架构/架构.md) 软件架构是分层架构的上层概念，分层架构是实现软件架构的一种重要模式
- [/软件工程/架构模式/表现层.md](/软件工程/架构模式/表现层.md) 表现层是分层架构中的一个重要层级，负责协议适配和参数校验
- [/软件工程/软件设计/软件设计.md](/软件工程/软件设计/软件设计.md) 分层架构是软件设计的重要组成部分，通过分层实现关注点分离
- [/软件工程/架构模式/Web框架.md](/软件工程/架构模式/Web框架.md) Web框架通常采用分层架构模式，实现表现层、应用层和领域层的分离
- [/软件工程/软件设计/代码质量/整洁代码.md](/软件工程/软件设计/代码质量/整洁代码.md) 整洁架构是分层架构的演进形态，强调架构的稳定性和可测试性
- [/软件工程/架构模式/响应式架构.md](/软件工程/架构模式/响应式架构.md) 响应式架构与分层架构结合可以提升系统的稳定性、可扩展性
- [/软件工程/微服务/服务建模.md](/软件工程/微服务/服务建模.md) 微服务架构中的服务内部通常也采用分层架构，实现业务逻辑与基础设施的解耦
- [/软件工程/软件设计/代码质量/软件测试/软件测试.md](/软件工程/软件设计/代码质量/软件测试/软件测试.md) 分层架构提升了可测试性，各层可以采用不同的测试策略
- [/数据技术/数据质量.md](/数据技术/数据质量.md) 数据分层架构与数据质量管理密切相关，通过分层控制数据质量
- [/数据技术/数据架构.md](/数据技术/数据架构.md) 数据架构中也体现了分层思想，与系统架构的分层有相似的稳定性和变化隔离原理
- [/软件工程/架构/系统设计/架构设计.md](/软件工程/架构/系统设计/架构设计.md) 架构设计是分层架构的应用场景，通过分层实现系统设计的目标
- [/软件工程/架构/演进式架构.md](/软件工程/架构/演进式架构.md) 演进式架构强调系统的可演进性，这与分层架构的稳定性递增原则一致
- [/软件工程/理论/结构化分析方法.md](/软件工程/理论/结构化分析方法.md) 结构化分析方法与分层架构都强调系统分解和关注点分离
- [/软件工程/软件设计/代码质量/编码规范.md](/软件工程/软件设计/代码质量/编码规范.md) 编码规范对于维护分层架构的边界和依赖规则至关重要