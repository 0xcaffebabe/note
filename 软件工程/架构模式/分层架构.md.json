{"name":"分层架构","id":"软件工程-架构模式-分层架构","content":"# 分层架构\n\n> 分层架构是所有软件架构的基础模型，是\"稳定核心 + 可替换实现\"的结构化设计方式。无论是 DDD、六边形架构、整洁架构，都可视为分层架构的演进形态。\n\n## 本质：稳定性梯度（Stability Gradient）\n\n系统内部存在不同变化速度的模块，分层即是：\n\n```\n按变化速度分区，把稳定的放核心，把易变的放边缘\n```\n\n稳定性从高到低示意：\n\n```\nDomain（本质规则）   ← 最稳定\nApplication（用例编排）\nPresentation（交互协议）\nInfrastructure（技术细节） ← 最易变\n```\n\n## 分层的目标（而非手段）\n\n| 目标     | 解释                      |\n| ------ | ----------------------- |\n| 关注点分离  | 每层只关心本层的问题，不跨层思考        |\n| 隔离变化   | 外部变化（协议、技术栈）不影响核心业务     |\n| 建立清晰边界 | 结构化组织业务、技术、协作           |\n| 提升可测试性 | 纯业务逻辑可独立测试              |\n| 提升可演进性 | 基础设施可替换（DB/Cache/消息中间件） |\n\n## 分层的黄金原则（核心规则）\n\n### （1）依赖倒置原则 DIP\n\n* 高层策略（Domain）不依赖低层细节（Infra）\n* 由接口定义依赖方向\n\n### （2）依赖单向流动（Unidirectional Dependency）\n\n```\nPresentation → Application → Domain → Infrastructure（接口）\nInfrastructure 实现 Domain 所定义的接口\n```\n\n### （3）稳定性递增（Stability Increasing Toward Center）\n\n越往内层越稳定，越难变化。\n\n# 分层架构元模型（Meta Model）\n\n这是本文最核心的抽象。\n\n下面是一个标准 Layered Architecture 模型：\n\n```\n┌────────────────────────────┐\n│        Presentation          │  ← 输入协议（API/GUI/消息）\n└────────────────────────────┘\n┌────────────────────────────┐\n│        Application          │  ← 用例编排/事务管理/流程控制\n└────────────────────────────┘\n┌────────────────────────────┐\n│          Domain             │  ← 业务本质（实体/值对象/规则/策略）\n└────────────────────────────┘\n┌────────────────────────────┐\n│       Infrastructure        │  ← DB/Cache/MQ/HTTP/Config 实现\n└────────────────────────────┘\n```\n\n## 各层职责、输入、输出\n\n| 层              | 核心职责          | 输入              | 输出                     |\n| -------------- | ------------- | --------------- | ---------------------- |\n| Presentation   | 协议适配、参数校验、序列化 | HTTP/GRPC/消息    | DTO                    |\n| Application    | 编排业务用例、事务、流程  | DTO             | Command / Domain Model |\n| Domain         | 业务规则、实体、策略、限制 | Command         | Result / Event         |\n| Infrastructure | 技术细节实现        | Repository 接口调用 | Data                   |\n\n## 如何判断\"是否越界\"？\n\n越界访问例子（❌）：\n\n* Controller 直接访问 Repository\n* Domain 调用 MQ\n* Domain 依赖 Spring 配置\n* View 直接操作数据库\n\n越界属于\"架构腐化\"的主要原因之一。\n\n# 为何分层（价值体系）\n\n## 降低复杂度\n\n每层只关注自己的抽象，不关注细节。\n\n## 隔离变化\n\n* 技术变化不影响业务（如 DB → Redis）\n* 表现形式变化不影响业务（Web → App → IoT）\n\n## 提高扩展性\n\n* 可以替换基础设施\n* 可以添加新的表现方式\n* 可以横向扩展层级\n\n## 可测试性提升\n\n* Domain 可做纯单元测试（无外部依赖）\n* Application、Infra 可独立集成测试\n\n# 分层架构的常见问题 & 反模式\n\n## ❌ 层次过多，导致性能差\n\n反例：\n\n* 工具类放在单独一层\n* Repository 包装 Repository\n* DTO 做两层转换\n\n改进：**按变化速度，而非物理层数进行分层。**\n\n## ❌ Application 层过度膨胀\n\n原因：\n\n* 所有逻辑都写在 Service 里\n* 领域没有模型，导致\"贫血领域\"\n\n改进：将业务规则下沉到 Domain。\n\n## ❌ 基础设施反向依赖领域\n\n例如 Domain 依赖 Spring、Redis、MySQL、MQ 等。\n\n改进：**Infrastructure 依赖 Domain，不允许反向依赖。**\n\n## ❌ 缺乏边界限制\n\n没有静态规则约束，导致循环依赖、跨层访问。\n\n改进：使用 ArchUnit/Sonar 构建架构治理规则。\n\n# 分层架构的模型扩展\n\n## 分层架构与现代架构的关系\n\n| 模型       | 核心思想   | 与分层关系   |\n| -------- | ------ | ------- |\n| 六边形架构    | 端口-适配器 | 分层的强抽象版 |\n| 整洁架构     | 同心圆稳定性 | 分层进阶    |\n| DDD 分层架构 | 领域中心化  | 分层+业务建模 |\n\n本质：**都是分层思想的递进。**\n\n### MVC / MVP / MVVM 属于\"表示层内部模式\"\n\n需强调：\n\n### ❗它们不是系统分层架构\n\nMVC/MVP/MVVM 解决的是\"表示层内部职责分离\"，属于 Presentation 层子模式。\n\n# 架构选型指南（极重要）\n\n| 场景          | 是否建议分层                     | 原因             |\n| ----------- | -------------------------- | -------------- |\n| 中小型后台系统     | ✓ 强烈建议                     | 可维护性高          |\n| 中台/核心业务系统   | ✓ 必须                       | Domain 稳定层非常关键 |\n| 高性能网关       | ✗ 不建议复杂分层                  | 延迟敏感           |\n| 简单 CRUD API | △ 轻量分层即可                   | 避免过度工程化        |\n| 微服务         | ✓ 建议两层（Application+Domain） | 简化内部结构         |\n\n# 分层架构的治理体系（落地关键）\n\n## 依赖扫描\n\n* ArchUnit（Java）\n* ESLint（JS）\n* Sonar\n* Structure101\n\n## 边界规范\n\n* 不允许跨层访问\n* Domain 不允许依赖外部框架\n* Infra 代码必须通过接口定义访问 Domain\n\n## 测试矩阵\n\n| 层              | 测试方式    |\n| -------------- | ------- |\n| Presentation   | API 测试  |\n| Application    | 集成测试    |\n| Domain         | 纯单测     |\n| Infrastructure | Mock 测试 |\n\n# 分层架构的演进路线（架构认知的核心）\n\n```\n三层架构（Controller-Service-DAO）\n        ↓ 识别贫血模型问题\n分层架构（Presentation-App-Domain-Infra）\n        ↓ 技术/业务解耦\nDDD 分层架构（Domain 强化）\n        ↓ 接口化驱动\n六边形架构 / 整洁架构（端口驱动）\n        ↓ 云原生\n多端协作 / 无服务化架构（BFF + 边缘层）\n```\n\n你可以看出：\n**所有现代架构都是分层架构的加强版，而非替代方案。**\n\n# 完整对照示例（传统 vs 现代）\n\n## 传统三层架构\n\n```\nController → Service → DAO → DB\n```\n\n## 现代分层架构\n\n```\nController\n   ↓\nApplication（用例编排）\n   ↓\nDomain（业务规则、实体）\n   ↓\nInfrastructure（DB、MQ、Cache 具体实现）\n```\n\n优势：\n\n* 业务核心不依赖技术栈\n* 实现可替换\n* 增加新表现层无需动领域层\n\n## 总结\n\n> **分层架构本质是把\"稳定的业务本质\"与\"易变的技术细节\"分开，使系统能够长期保持可维护、可演进，并能以最小代价适应前端、协议、技术栈的变化。**\n\n## 关联内容（自动生成）\n\n- [/软件工程/领域驱动设计.md](/软件工程/领域驱动设计.md) 分层架构与领域驱动设计紧密结合，DDD 的分层架构将业务核心（Domain）作为稳定层\n- [/软件工程/架构/架构治理.md](/软件工程/架构/架构治理.md) 分层架构需要架构治理来维护各层边界，防止跨层访问和架构腐化\n- [/数据技术/数据分层.md](/数据技术/数据分层.md) 数据分层与系统架构分层有相似的稳定性梯度原理，都是为了隔离变化\n- [/软件工程/架构/架构.md](/软件工程/架构/架构.md) 软件架构是分层架构的上层概念，分层架构是实现软件架构的一种重要模式\n- [/软件工程/架构模式/表现层.md](/软件工程/架构模式/表现层.md) 表现层是分层架构中的一个重要层级，负责协议适配和参数校验\n- [/软件工程/软件设计/软件设计.md](/软件工程/软件设计/软件设计.md) 分层架构是软件设计的重要组成部分，通过分层实现关注点分离\n- [/软件工程/架构模式/Web框架.md](/软件工程/架构模式/Web框架.md) Web框架通常采用分层架构模式，实现表现层、应用层和领域层的分离\n- [/软件工程/软件设计/代码质量/整洁代码.md](/软件工程/软件设计/代码质量/整洁代码.md) 整洁架构是分层架构的演进形态，强调架构的稳定性和可测试性\n- [/软件工程/架构模式/响应式架构.md](/软件工程/架构模式/响应式架构.md) 响应式架构与分层架构结合可以提升系统的稳定性、可扩展性\n- [/软件工程/微服务/服务建模.md](/软件工程/微服务/服务建模.md) 微服务架构中的服务内部通常也采用分层架构，实现业务逻辑与基础设施的解耦\n- [/软件工程/软件设计/代码质量/软件测试/软件测试.md](/软件工程/软件设计/代码质量/软件测试/软件测试.md) 分层架构提升了可测试性，各层可以采用不同的测试策略\n- [/数据技术/数据质量.md](/数据技术/数据质量.md) 数据分层架构与数据质量管理密切相关，通过分层控制数据质量\n- [/数据技术/数据架构.md](/数据技术/数据架构.md) 数据架构中也体现了分层思想，与系统架构的分层有相似的稳定性和变化隔离原理\n- [/软件工程/架构/系统设计/架构设计.md](/软件工程/架构/系统设计/架构设计.md) 架构设计是分层架构的应用场景，通过分层实现系统设计的目标\n- [/软件工程/架构/演进式架构.md](/软件工程/架构/演进式架构.md) 演进式架构强调系统的可演进性，这与分层架构的稳定性递增原则一致\n- [/软件工程/理论/结构化分析方法.md](/软件工程/理论/结构化分析方法.md) 结构化分析方法与分层架构都强调系统分解和关注点分离\n- [/软件工程/软件设计/代码质量/编码规范.md](/软件工程/软件设计/代码质量/编码规范.md) 编码规范对于维护分层架构的边界和依赖规则至关重要","metadata":"tags: ['数据技术', '软件工程']","hasMoreCommit":false,"totalCommits":5,"commitList":[{"date":"2026-02-12T15:23:11+08:00","author":"MY","message":"docs(SUMMARY): 移除重复的目录项和SpringMVC文档","hash":"429e3cfcfae1b84b55a4103397b82ac21b6e9255"},{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2025-12-08T15:18:02+08:00","author":"MY","message":"docs(架构文档): 移除分层架构本质部分的冗余描述","hash":"a005714728bd6fec43fc6298853c9e26942f11ef"},{"date":"2025-12-08T15:17:37+08:00","author":"MY","message":"docs(architecture): 更新分层架构文档内容与结构","hash":"58283e0eb94f77ad30e8307b488e703d2f5f9038"},{"date":"2024-10-25T11:43:52+08:00","author":"MY","message":"📦架构模式","hash":"7a4552433037b568c78fb856bbb5268f027deae4"}],"createTime":"2024-10-25T11:43:52+08:00"}