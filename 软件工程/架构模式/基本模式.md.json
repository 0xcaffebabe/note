{"name":"基本模式","id":"软件工程-架构模式-基本模式","content":"# 基本模式\n\n## [网关](/软件工程/架构/系统设计/网关.md)\n\n入口对象是对外部系统或资源访问的封装\n\n- 封装外部资源，创建一个简单的API\n\n网关模式可以是简单的接口转发，与外观模式不同的是，外观接口通常由服务端提供，具有通用性\n\n## 映射器\n\n在两个独立的对象之间的中间层\n\n主要是在两个子系统之间建立通信，并且不被子系统所感知\n\n要达到这样的目的，需要监听子系统的通信请求\n\n## 层超类型\n\n某一类型充当一层中所有类型的超类型\n\n当一层中的所有对象都具有共同的一些特性时，这些特性就可以被抽取成超类代码\n\n- 是不是一种继承滥用？\n\n## 分离接口\n\n在与接口定义分离的地方实现该接口\n\n这种模式在微服务的服务间接口很常被用到\n\n```\nparent\n|- order-service\n|-- order-service-api\n|-- order-service-impl\n```\n\n## 注册表\n\n- 在Spring大行其道的时代，这个模式似乎过时了\n\n一个全局可见的对象，其他对象可以通过此对象获得\n\n- 可以使用单例模式\n\n但当增加一种新类型时，注册表必须被修改\n\n但也可以使用隐式注册表，只是会失去编译时检查的优点\n\n## 值对象\n\n小而简单的对象，一旦创建字段就不可修改，判等时不依据标识ID\n\n## 货币\n\n表示一个货币值的对象\n\n- 封装屏蔽不同币种及精度丢失问题\n\n## 特殊情况（Null Object）\n\n提供特殊行为的子类\n\n- 主要是为了避免针对特殊情况进行编程而引入的\n\n```java\nPerson getUser(String id) {\n  // ...\n  // if not found\n  return Person.EMPTY\n}\n```\n\n## 插件\n\n通过配置来连接类，在运行时决定实际的实现类，可以使用[工厂模式](/软件工程/设计模式/创建型模式.md#工厂模式)动态化对象的创建过程\n\n像Spring的条件化注入就是一种插件的实现手段\n\n```java\n@CondtionalOnProperties(...)\nclass DevService implements Service{...}\n@CondtionalOnProperties(...)\nclass ProdService implements Service{...}\n```\n\n## 服务桩\n\n在测试时mock外部服务，其实就是插件的一种具化形式，通过提供一个统一接口，隔离生产环境与开发环境实际调用的接口\n\n## 记录集\n\nJDBC中的 ResultSet\n\n表格数据在内存的表现形式\n\n- 离线记录集\n","metadata":"","hasMoreCommit":false,"totalCommits":2,"commitList":[{"date":"2022-03-01T16:10:32+08:00","author":"cjiping","message":"✏️更新 架构模式","hash":"0c474dcf75933e0677b49aca4dc737aaf4ba238b"},{"date":"2020-01-23T16:29:37+08:00","author":"MY","message":"增加基本模式&完成架构模式","hash":"1070df9773b1ad420a24745afb60aa61d96b7c42"}],"createTime":"2020-01-23T16:29:37+08:00"}