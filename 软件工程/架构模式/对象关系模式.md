---
tags: ['软件工程', '持久化', '数据技术']
books: [
  {name: '企业应用架构模式', chapters: ['第11章', '第12章', '第13章']}
]
---

# 对象-关系模式

## 一、第一性原理：对象-关系失配的根本矛盾

在任何基于关系数据库的面向对象系统中，都不可避免地存在以下三类**不可消除的结构张力**：

### 1. 身份语义不一致

* **对象世界**：对象通过内存引用和 identity 维持同一性
* **关系世界**：数据通过主键值维持同一性

> 问题本质：如何在跨事务、跨加载周期中保持“同一个对象”的语义一致。

### 2. 结构表达不一致

* 对象模型是**图结构**（引用、导航）
* 关系模型是**集合结构**（表、行、连接）

> 问题本质：如何在不破坏领域模型表达力的前提下进行持久化。

### 3. 生命周期不一致

* 对象生命周期受业务逻辑驱动
* 数据生命周期受事务与数据库约束驱动

> 问题本质：如何协调对象级操作与事务级提交。

**所有对象-关系模式，都是对上述张力的局部缓解方案，而非根治手段。**

---

## 二、对象-关系行为模式（解决“如何修改与加载”）

行为模式关注：**对象如何被加载、修改、提交，以及这些行为如何与事务边界协同。**

### 2.1 工作单元（Unit of Work）

#### 根本问题

* 对象的修改是**离散发生的**
* 数据库更新需要**集中、有序、原子化提交**

#### 核心机制（抽象层）

* 维护一个事务内的对象变更集合
* 统一协调 insert / update / delete 的执行时机与顺序

#### 常见实现策略（非本质）

* 调用者显式注册
* 对象自注册
* 快照对比（拷贝对象 vs 原对象）

#### 系统代价

* 事务范围扩大
* 内存占用上升
* 并发冲突集中暴露

> 本质上，Unit of Work 是**对象级变更 → 事务级提交**的桥梁。

---

### 2.2 标识映射（Identity Map）

#### 根本问题

* 同一行数据在一个事务中被多次加载，导致对象语义分裂

#### 核心机制

* 使用数据库主键作为对象唯一标识
* 在会话范围内维护“主键 → 对象实例”的映射

#### 作用

* 保证对象同一性
* 作为一级缓存减少重复加载

#### 系统代价

* 会话生命周期与内存占用强绑定
* 不当使用会导致内存膨胀

> Identity Map 的本质是：**在对象世界中重建关系世界的身份语义。**

---

### 2.3 延迟加载（Lazy Load）

#### 根本问题

* 对象图往往比业务实际使用范围更大
* 过早加载会导致无谓的 IO 与内存占用

#### 抽象机制

* 对象在逻辑上完整，但在物理上部分未加载
* 在访问缺失数据时触发补全

#### 常见实现形式

* 延迟初始化
* 虚代理（最透明）
* 值保持器
* 重影对象（先 ID，后整体）

#### 系统代价

* 隐式 IO
* N+1 查询风险
* 对事务边界高度敏感

> Lazy Load 的本质是**以不确定性换取性能与资源效率**。

---

## 三、对象-关系结构模式（解决“如何表示结构”）

结构模式关注：**对象模型如何映射为关系结构而不扭曲领域含义。**

### 3.1 标识域（Identity Field）

#### 根本问题

* 对象需要在脱离内存后仍保持可识别性

#### 核心机制

* 在对象中显式保存数据库标识

#### 关键设计维度

* 有意义键 vs 无意义键
* 单一键 vs 组合键
* 应用生成 vs 数据库生成

> 标识的选择影响的不只是数据库结构，而是**领域模型的稳定性**。

---

### 3.2 关联映射

#### 外键映射

* 对象引用 → 表外键

#### 关联表映射

* 多对多关系显性化

#### 依赖映射

* 由聚合根负责依赖对象的持久化

> 关联映射的核心是：**不要让数据库结构反向污染领域模型。**

---

### 3.3 嵌入值（Embedded Value）

#### 根本问题

* 某些对象无独立身份，仅作为整体的一部分存在

#### 核心机制

* 将值对象字段展开到宿主表中

> 嵌入值体现的是**值语义优先于存储结构**。

---

### 3.4 继承映射模式

继承映射用于缓解：**面向对象的继承层次与关系模型缺乏继承能力之间的冲突**。

#### 三种经典策略

| 维度        | 单表继承 | 类表继承 | 具体表继承 |
| --------- | ---- | ---- | ----- |
| 查询复杂度     | 低    | 高    | 中     |
| 空字段       | 多    | 少    | 无     |
| Schema 演进 | 困难   | 灵活   | 中     |
| ORM 复杂度   | 低    | 高    | 中     |

> 继承映射的选择，本质上是**查询效率、演进能力与复杂度之间的权衡**。

---

## 四、对象-关系元数据与访问模式（解决“如何解耦”）

### 4.1 元数据映射

#### 根本问题

* 映射规则不应与业务代码强耦合

#### 两种策略

* 代码生成：性能高、但演进成本高
* 运行时反射：灵活、但性能与可预测性下降

> 元数据的引入，是用**间接层换取系统可演进性**。

---

### 4.2 查询对象（Query Object）

#### 根本问题

* SQL 作为字符串缺乏组合性与类型安全

#### 核心机制

* 将查询表达为对象结构

#### 设计边界

* 查询对象描述“如何查”
* 不应承担业务规则

---

### 4.3 资源库（Repository）

#### 根本问题

* 领域模型不应感知持久化细节

#### 核心定位

* Repository 是**领域对象集合的抽象**

#### 明确的非职责

* 不负责复杂报表
* 不暴露 ORM 细节
* 不承担事务编排

> Repository 的价值在于：**保护领域模型不被基础设施侵蚀。**

## 关联内容（自动生成）

- [/中间件/数据库/redis/持久化.md](/中间件/数据库/redis/持久化.md) 持久化是对象关系映射的核心问题之一，Redis的持久化机制提供了不同的设计思路和权衡考量
- [/中间件/数据库/文档数据库.md](/中间件/数据库/文档数据库.md) 文档数据库提供了不同于关系型数据库的对象持久化方案，有助于理解不同数据模型下的对象关系映射
- [/数据技术/数据存储.md](/数据技术/数据存储.md) 数据存储技术是对象关系映射的基础，理解底层存储机制有助于更好地设计映射策略
- [/软件工程/架构/系统设计/缓存.md](/软件工程/架构/系统设计/缓存.md) 缓存策略与对象关系映射密切相关，特别是在处理对象状态管理和一致性方面
- [/中间件/数据库/数据库系统/事务管理/事务.md](/中间件/数据库/数据库系统/事务管理/事务.md) 事务管理是对象关系映射的重要组成部分，特别是在实现工作单元模式时
- [/编程语言/JAVA/语言基础.md](/编程语言/JAVA/语言基础.md) JAVA语言特性对对象关系映射实现有直接影响，特别是反射和注解机制
- [/中间件/数据库/分布式数据库.md](/中间件/数据库/分布式数据库.md) 分布式数据库环境下的对象关系映射面临额外的挑战，如分布式事务和一致性问题
