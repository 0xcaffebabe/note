{"name":"对象关系模式","id":"软件工程-架构模式-对象关系模式","content":"# 对象关系模式\n\n## 对象-关系行为模式\n\n### 工作单元\n\n维护受影响的对象列表，并协调对象的修改以及解决并发问题\n\n```java\ninterface WorkUnit {\n    new(Object),Dirty(Object),Clean(Object)\n}\n```\n\n工作单元会将被修改的对象变化记录下来，存储到数据库\n\n工作单元解决的基本问题是记录各种操作过的对象\n\n- 调用者注册：修改之后调用者手动提交来保存对象\n- 对象注册：将注册方法置于对象中\n- 工作单元控制器：查询时返回一个拷贝对象，提交时比较拷贝对象与原有的对象，进行有选择的更新\n\n工作单元可以保证更新顺序，并且按照相同的数据更新表可以很少地减少死锁\n\n### 标识映射\n\n通过给每个对象指定一个标识，避免重复加载，当需要对象时，通过映射来找到对象\n\n无论需要一个什么对象，先检查标识映射，看需要的对象是否在其中\n\n- 键的选择：数据库主键\n- 显式的标识映射可以利用编译时检查的优点\n- 标识映射与会话相绑定\n\n#### 使用\n\n- 管理对象\n- 做缓存\n\n### 延迟加载\n\n一个不包含所需要的所有数据但知道如何获取这些数据的对象\n\n- 延迟初始化：每次获取都判断是否为空，如果空就去获取数据\n- 虚代理：一个获取数据的代理对象，类可以把它当做真实的对象\n- 值保持器：包装某个对象的对象，但是缺点是不如虚代理，类必须知道这个保持器的存在\n- 重影：首次加载只加载ID，当需要某个域时，则会加载入全部的域\n\n使用的最佳时机：需要额外的调用，并且当主对象被使用时，额外加载的数据没被使用的时候\n\n## 对象-关系结构模式\n\n### 标识域\n\n在对象中保存的一个数据库标识域\n\n#### 键的选择\n\n- 有意义键与无意义键\n  - 危险在于有意义键由人指定，可能会发生错误\n- 简单键与组合键\n  - 组合键的好处在于当处于多个表相关的上下文时，更容易使用\n- 表唯一键与数据库唯一键\n\n#### 键的表示\n\n对于组合键，最好的方式是建立一个键类，来存放基本类型键值\n\n#### 键的生存\n\n- 自动生成域：不断递增\n- 数据库计数器：没有统一的标准，并非所有数据库都支持\n- GUID：保证了同一时空的所有机器生成的GUID都是不唯一的，但是生成的串比较大\n- 键表，通过在数据库保存下一个有效值来生成键\n\n### 外键映射\n\n把对象的之间的关联映射到表之间的外键关联\n\n### 关联表映射\n\n将多对多的对象关联映射为数据库中的关联表\n\n### 依赖映射\n\n一个类为依赖它的类执行数据库映射\n\n### 嵌入值\n\n把对象映射成另一个对象表的一部分\n\n### 序列化LOB\n\n将小对象之间的关系保存到大对象中，并将大对象保存序列化到数据库\n\n### 类表映射\n\n```mermaid\nclassDiagram\n  class cat {\n    weight\n    height\n  }\n  class dog {\n    height\n  }\n  class animal {\n    id\n    age\n  }\n  animal <-- cat\n  animal <-- dog\n```\n\n#### 单表继承\n\n将类的整个继承层次表示为一张表\n\n```sql\nCREATE TABLE {\n  DB_TYPE\n  id\n  age\n  weight\n  height\n}\n```\n\n加载数据的时候需要决定用哪个类来实例化这些数据\n\n- 类名\n- 代码域\n\n#### 类表继承\n\n一个类一张表\n\n```sql\nCREATE TABLE animal{\n  id\n  age\n}\nCREATE TABLE dog{\n  id\n  age\n  weight\n}\nCREATE TABLE cat{\n  id\n  age\n  height\n}\n```\n将数据映射成对象需要比较复杂的方案\n\n### 具体表继承\n\n一个层次一张表\n\n### 继承映射器\n\n一种可以处理继承层次的数据库映射器\n\n子类调用父类映射器加载数据后，再加载子类的特有数据\n\n## 对象-关系元数据映射模式\n\n### 元数据映射\n\n把关系对象映射的信息保存到元数据中(meta data)\n\n#### 代码生成\n\n输入元数据，输出实现类的源代码，这种方式是现有的很多快速开发框架所具备\n\n通过读入数据库表结构，就能快速生成后端的controller、service、dao代码以及前端的一个简单增删改查模板\n\n#### 反射程序\n\n在运行时读入元数据产生动态行为\n\n这种方式的优点在于灵活性够高，相较于代码生成的源文件，一旦元数据发生变更，代码就得重新生成，并且手动修改这些生成的源文件可能会发生难以预料的错误\n\n但反射的缺点就是性能问题\n\n### 查询对象\n\n一个描述一次数据库查询的对象\n\n*解释器模式*\n\n许多ORM框架都提供了通过宿主语言的方式来描述SQL查询的API\n\n- spring data jpa中的对象查询以及JPQL\n- mybatis plus 的queryWrapper\n\n```java\nqueryWrapper.eq (\"a.del_flag\", 0 )\n```\n\n### 资源库(Repository)\n\n在使用查询对象的基础上，协调领域层与数据源层，使用类似集合的接口访问领域对象\n\n```java\nList<Person> findPersonList(QueryWrapper<Person> qw);\n```\n\n资源库提供了一个更符合面向对象观点的持久层实现","metadata":"tags: ['架构', '架构模式']\nbooks: [\n  {name: '企业应用架构模式', chapters: ['第11章', '第12章', '第13章']}\n]","hasMoreCommit":false,"totalCommits":1,"commitList":[{"date":"2022-05-13T17:04:55+08:00","author":"cjiping","message":"📦整理 对象关系模式","hash":"71409a2cd4645fa35d5f0488f17cdd4713634c42"}],"createTime":"2022-05-13T17:04:55+08:00"}