{"name":"架构模式","id":"软件工程-架构模式-架构模式","content":"# 架构模式\n\n## 数据流风格\n\n所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构，数据在流水线的各个节点上被加工。每完成一个环节，数据流都会被送入下一个环节，最终输出处理后的完整结果\n\n该风格的特点就是\n\n- 解耦\n- 复用\n- 高吞吐\n\n### 批处理\n\n特点：\n\n- 强时间顺序：只有当前一步的计算任务处理完成后，后一步处理才能开始。计算任务前后顺序明确。\n- 强完整性：数据传送在计算单元之间通过指定的数据交互方式传递。每一步要确保数据完整，才可以向下一步发起数据传送。\n- 强控制力度：有独立的顺序控制和时间把控机制，并辅以数据检查等功能。\n\n### 管道过滤\n\n从用户或者上游管道获得输入数据，进行数据的变换及增量计算，处理完成后，通过下游管道传递给另一个过滤器\n\n```mermaid\nflowchart LR\n    A[输入] --> F1[过滤器]\n    F1 -- 管道 --> P1[处理单元1]\n    F1 -- 管道 --> P2[处理单元2]\n    P1 -- 管道 --> P3[处理单元3]\n    P2 -- 管道 --> P3\n    P2 -- 管道 --> P4[处理单元4]\n    P4 -- 管道 --> P2[处理单元2]\n    P4 -- 管道 --> 输出3\n    P3 -- 管道 --> O1[输出1]\n    P3 -- 管道 --> O2[输出2]\n\n```\n\n## 调用返回风格（请求响应）\n\n指在系统中增加了调用与返回机制。利用调用和返回，实现分而治之，将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性\n\n### 主程序/子程序\n\n- 对应于面向过程开发\n\n### 面向对象风格\n\n- 面向对象编程\n\n### 层次结构风格\n\n每一层可以独立设计、开发，只要满足和上下层的接口定义即可。层间解耦\n\n## 独立构件风格\n\n描述了在一个应用系统中，各个构件是如何进行通信的\n\n### 进程通信\n\n通常以同步调用为主，辅以异步交互式通信方式\n\n### 事件驱动架构\n\n![202191423640](/assets/202191423640.jpg)\n\n基于事件的隐式调用风格，构件不直接调用一个过程，而是触发或广播一个或多个事件。后续执行过程会被注册在一个或多个事件，当对应的事件被触发或者广播时，系统会自动调用该事件中注册的过程，执行相应的模块功能\n\n- 异步分发事件\n  - 发生的事件\n  - 变化的状态\n- 耦合较低 灵活 扩展较容易\n- 由于异步与细粒度的处理单元 正常情况下性能较高 但在出现异常重试时性能会降低\n- **集成测试、维护很难**\n\n#### 两种模式\n\n##### Mediator\n\n![2021106152652](/assets/2021106152652.png)\n\n- Event Queue：只关注事件的接收和发送\n- Event Mediator：将原始事件转化成业务事件\n- Event Channel：业务事件的聚合 由感兴趣的processor监听\n- Event Processor：业务事件执行单元\n\n##### Broker\n\n![202110615598](/assets/202110615598.png)\n\n- 无中心编排控制点\n- 无业务逻辑的消息分发\n\n两种模式的processor都是单一职责的最小执行单元\n\n## 虚拟机风格\n\n### 解释器\n\n可以仿真硬件的执行过程和一些关键应用，通常被用来弥合程序语义与硬件语义之间的差异。其缺点是执行效率较低\n\n### 基于规则的系统\n\n规则的细节被引擎所解析，来决定业务、监控等策略和措施的制定\n\n- 大数据/人工智能\n\n![202191423912](/assets/202191423912.jpg)\n\n## 仓库风格\n\n关注的重点是数据的存储和共享方式，最偏重数据共享的一种风格\n\n### 数据库系统\n\n### 超文本系统\n\n- 是用于共享静态网页\n\nCMS\n\n### 黑板\n\n用于记录组织推理步骤、控制状态数据和问题求解之领域知识的框架。它将问题的解空间组织成一个或多个应用相关的分级结构。这些分级结构将由不同的专家（系统），通过不同知识表达方法、推理框架和控制机制的组合来形成各自的知识源\n\n![202191423145](/assets/202191423145.jpg)\n\n## 微内核架构\n\n- 也被称为插件化架构，是一种面向功能进行拆分的可扩展的架构\n\n![2021107221455](/assets/2021107221455.png)\n\n系统核心的作用在于资源封装与插件规范定义\n\n插件为在核心提供的接口上实现其单一的功能 插件之间应避免依赖 不能影响核心\n\n**优点**\n\n- 符合开闭原则 核心稳定 插件可扩展\n- 内核与插件之间的解耦与隔离\n- 针对核心的统一管理及插件的管理带来的性能优势\n- 动态插件带来的部署上的优势\n\n**缺点**\n\n- 开发难度高\n  - 功能位于核心还是插件难以划分\n  - 热插拔\n  - 注册协议 通信协议\n- 难以伸缩\n\n### 设计关键点\n\n- 插件管理：核心系统要知道当前哪些插件可用、如何加载这些插件、什么时候加载这些插件\n- 插件连接：核心系统必须制定插件和核心系统的连接规范\n- 插件通信：设计的插件间是完全解耦的，但是实际应用中，必然存在某个业务需要多个插件协作，这要求插件间进行通信\n\n#### 系统核心\n\n核心的功能为MVP 所有核心能实现的接口都要经过核心\n\n#### 开放规范\n\n- 版本兼容\n- 上下文、环境参数规范\n- 回调 钩子 事件\n- 业务集成规范\n\n#### 注册规范\n\n标识、功能、位置、依赖、权限\n\n#### 通信机制\n\n- 同步异步\n- 本地远程\n- 数据格式\n\n#### 插件装载\n\n- 知道插件在哪\n- 何时 启动期 运行期\n- 何地 本地 远程\n\n## 领域逻辑组织\n\n- 编写业务逻辑的以什么形式存在、协作\n\n### 事务脚本\n\n> 使用过程来组织业务逻辑，每个过程处理来自表现层的单个请求\n\n```mermaid\nclassDiagram\n   class RecognitionService {\n      +Money recognizedRevenue(long contractNumber, Date asOf)\n      +void calculateRevenueRecognitions(long contractNumber)\n   }\n   \n   RecognitionService --> Database\n```\n\n优点\n\n- 易于理解\n- 能与简单数据源层很好合作\n- 事务边界容易划分\n\n缺点\n\n- 业务复杂导致代码冗余复杂\n\n#### 事务脚本的组织\n\n- 将同一主题的事务脚本放到同一个类当中\n- 一个脚本对应一个类\n\n当业务逻辑变得越来越复杂时，这一模式很难继续保持良好的设计，许多问题本身是简单的，一个简单的解决方案可以加快开发速度\n\n### 领域模型\n\n> 使用面向对象的方法，合并了行为和数据\n\n```mermaid\nclassDiagram\n   class Contract {\n      +recognizedRevenue(Date asOf)\n      +calculateRecognitions()\n   }\n\n   class Product {\n      +calculateRecognitions(Contract contract)\n   }\n\n   class RecognitionStrategy\n   class CompleteRecognitionStrategy\n\n   Contract --> Product: N\n   Product --> Database\n   Contract --> Database\n   Product --> RecognitionStrategy : 1\n   RecognitionStrategy <-- CompleteRecognitionStrategy\n```\n\n开销来源于使用复杂以及数据源的复杂，还要面对将领域模型映射到数据库的问题\n\n#### 领域模型组织\n\n- 实体bean\n- ORM\n\n当使用领域模型时，使用数据映射器有助于保持领域模型与数据库的独立性\n\n领域模型的要点在于隐藏数据库的存在，使其对于上层不可见\n\n### 表模块\n\n> 围绕表组织领域逻辑，处理数据库中表或视图中所有行的业务逻辑的一个封装\n\n```mermaid\nclassDiagram\n   class Contract {\n      +CalculateRecognitions(ID)\n   }\n\n   class Product {\n      +GetProductType(ID)\n   }\n\n   class RevenueRecognition {\n      +Insert(ID, amount, date)\n      +RecognizedRevenue(contractID, date)\n   }\n\n   Contract --> Database\n   Product --> Database\n   RevenueRecognition --> Database\n```\n\n表模块与事务脚本的区别在于表模块的所有操作都是围绕表来进行，而事务脚本则是围绕事务过程来进行。\n\n#### 表模块组织\n\n表模块以一个类对应数据库中的一个表来组织领域逻辑，仅使用一个单一实例，表模块很大程度依赖于以表方式组织的数据\n\n### 服务层\n\n- 将领域层再拆为两层，服务层提供简单的API接口\n\n通过服务层提供一组可用的操作集合给外部使用\n\n服务层定义了应用程序的边界和从接口客户层角度所看到的的系统\n\n```mermaid\nsequenceDiagram\n  数据加载器 ->> 服务层: 访问\n  用户界面 ->> 服务层: 访问\n  系统集成入口 ->> 服务层: 访问\n  服务层 ->> 领域层: 访问\n  领域层 ->> 数据库: 访问\n```\n\n#### 业务逻辑的种类\n\n- 领域逻辑\n- 应用逻辑\n\n#### 实现\n\n- 领域外观\n  - 做的事不多，属于瘦客户端\n- 操作脚本\n  - 拥有较多的业务逻辑，对领域层进行操作\n\n#### 服务识别与操作\n\n服务层操作的起点是用例模型以及用户界面\n\n如果系统只有一种用户，那可能不需要使用服务层\n\n定义服务层的考虑就是为了复用\n\n## 与关系数据库的映射\n\n为了保证对领域对象的修改能及时存储到数据库，需要考虑如下问题：\n\n1. 标志映射，保证相同的对象只被加载一次\n2. 延迟加载，当对象附带着引用的对象，在需要时才加载\n\n### 表数据入口\n\n一个实例代表处理一张表中所有的行，通常是无状态的\n\n```java\ninterface Person {\n    RecordSet find(int id);\n    RecordSet findWithXXX(...);\n    void update(...);\n}\n```\n\n表数据入口可能是最简单的数据库接口模式\n\n### 行数据入口\n\n一个实例代表一条记录 内存对象的数据与数据库操作混杂在一起会带来一些麻烦 如不好测试 并会增加复杂度\n\n```java\nclass Person {\n    name,age;\n    insert();\n    update();\n}\ninterface PersonFinder {\n    Person find(...);\n}\n```\n\n### 活动记录\n\n一个包装表或视图中某一行的对象，封装了对数据库的操作访问\n\n```java\nclass Person {\n    name,age;\n    insert();\n    delete();\n\n    bool isAudlt();\n}\n```\n\n活动记录的本质是一个领域模型\n\n活动记录的数据结构应该与数据库完全吻合\n\n活动记录与行数据入口的区别在于行数据入口只有数据访问，而活动记录封装了一些逻辑\n\n- 活动记录适用于不太复杂的逻辑\n- 活动记录使对象与数据库的耦合过紧\n\n### 数据映射器\n\n随着ORM框架的发展，前面3种方式已逐渐过时，使用数据映射器的方式可以很好地处理大型应用下的数据源使用\n\n在对象和数据库之间的一个中间层，数据映射器自身不被领域层所察觉\n\n```java\ninterface PersonMapper {\n    Person select(...);\n    update(Person);\n}\n```\n\n当需要分离对象与数据库时，使用数据映射器\n\n### 元数据模式\n\n可以通过表结构为代表的元数据来自动生成代码，这在一些快速开发框架中很常见\n\n### 数据库连接\n\n涉及到数据库肯定也涉及到数据库连接，对于连接的管理，可以采用如下方式\n\n- 使用连接池管理连接\n- 将连接与事务绑定在一起\n\n## web表现层\n\n### 模板视图\n\n以 jsp php 为代表的模板文件，通过在HTML标记一些数据，来让处理器渲染\n\n缺点在于，很容易被插入复杂的逻辑，变得难以测试\n\n### 转换视图\n\n如 json 为代表\n\n转换视图把领域数据作为输入，HTML作为输出\n\n与模板视图的区别是转换视图侧重于数据的输入，而模板视图更侧重于输出\n\n### 两阶视图\n\n1. 生成一个逻辑视图\n2. 再将逻辑视图对应到html\n\n类似于编译，把业务数据转换为一种中间表示，再从中间表示渲染视图，两步视图的价值来源于分离了第一阶段与第二阶段，使改变更加容易\n\n## 并发模式\n\n在应用于数据库的并发处理中，本质问题是\n\n1. 更新丢失：多个工作单元对同一个数据进行修改，导致数据不一致\n2. 不一致读：读取数据时，数据可能被其他工作单元修改，导致两次读数据不一致\n\n工作单元执行在执行语境中，执语境可以是线程，也可以是进程\n\n- 一个请求对应一个会话，可以是进程，也可以是线程，但创建进程耗费资源，使用线程又会导致线程安全问题\n- 数据库中的语境是事务\n\n为了保证并发安全，有一些方案：\n\n- 隔离：划分数据，一片数据只能被一个工作单元访问\n- 不变：不变的数据是线程安全的\n\n### 乐观离线锁\n\n使用冲突检测与事务回滚来防止事务冲突\n\n- 验证一个提交的修改不会与其他修改发生冲突\n\n通过版本号来实现\n\n```mermaid\nsequenceDiagram\n  session1 ->> 数据库: 获取用户1\n  数据库 ->> session1: 返回用户1 版本号1\n  session1 ->> session1: 修改用户1\n  session2 ->> 数据库: 获取用户1\n  数据库 ->> session2: 返回用户1 版本号1\n  session2 ->> session2: 修改用户1\n  session2 ->> 数据库: 提交 用户1 版本号 1\n  数据库 ->> session2: 修改用户1成功 版本号2\n  session1 ->> 数据库: 提交 用户1 版本号 1\n  数据库 -->> session1: 失败 版本号不一致\n```\n\n```sql\nUPDATE users WHERE id = 1 AND version = 1;\n```\n\n这种乐观的离线锁是针对具体领域的解决方案\n\n### 悲观离线锁\n\n每次只允许一个会话访问数据\n\n```mermaid\nsequenceDiagram\n  par 事务边界\n    session1 ->> 数据库: 获取用户1\n    数据库 ->> session1: 返回用户1\n  end\n  par 事务边界\n    session2 ->> 数据库: 获取用户1\n    数据库 -->> session2: 失败 用户1被锁住\n  end\n  session1 ->> session1: 修改用户1\n```\n\n尽可能早检测出冲突\n\n锁的类型：\n\n- 独占写锁\n  - 当编辑数据时，需要对数据加锁\n- 独占读锁\n  - 当读取数据时，需要加锁\n- 读写锁\n  - 读锁与写锁是互斥的\n  - 可以进行并发地读\n\n锁管理：如何管理锁与锁的持有者？实现尽可能简单，可以使用散列表映射锁及锁的持有者\n\n### 粗粒度锁\n\n- 获取与释放锁的代价很小\n\n用锁锁住一组相关的对象，DDD中的[聚合根](/软件工程/领域驱动设计.md#聚合)就可以代表是锁的入口点\n\n### 隐含锁\n\n将加锁的任务交给父类或者框架，避免繁琐的客户编程加锁释放锁导致出现的问题\n\n## 会话保存\n\n无状态服务不需要在服务端存储会话信息\n\n存储会话信息的一些方法：\n\n- 客户端存储\n  - cookie\n  - 注意会话数据大小以及数据安全性完整性\n- 服务器存储\n  - session\n- 数据库存储\n  - 将会话信息存储在数据库中\n\n### 客户会话状态\n\n将会话状态保存在客户端\n\n这样服务器就可以是无状态的 可以构建性能强大的服务器集群\n\n为了避免安全问题，将会话状态保存在诸如Cookie等客户端数据上的时候，需要对其加密，如JWT就是其中的一个代表，但这样会带来一定的性能损失\n\n另外一种方式是SessionId为代表的用来保存标识号的技术，这种方式通过一个散列的随机字符串来标识用户，但这样服务器就不再是无状态了，除非引入统一Session服务器，否则服务器还是必须得存储用户的状态\n\n### 服务器会话状态\n\n将会话状态保存到服务端\n\n- 会话状态的持久化以及序列化所带来的字段兼容问题\n\n### 数据库会话状态\n\n将会话状态保存到数据库中\n\n### 会话迁移\n\n会话可以在服务器集群之间转移\n\n## 分布式\n\n进程内的过程调用非常快，而远程调用则涉及网络延迟和数据序列化等开销\n\n何时必须使用分布对象：\n\n- 客户机与服务器之间\n- 服务器与数据库之间\n- web系统之间\n- 使用软件包，当系统中有多个模块或服务时，通过定义良好的接口来实现模块间的交互\n\n注意远程调用的边界：明确哪些操作可以在本地执行，哪些必须远程调用\n\n许多现代分布式系统中，XML和HTTP被广泛用于数据交换和远程过程调用\n\n#### 远程外观\n\n对细粒度接口对象进行封装，提供粗粒度接口，提高网络传输效率\n\n进程内调用的开销比进程外的小\n\n远程外观的设计都是基于特定客户的需要\n\n### 数据传输对象（DTO）\n\n传输数据的对象\n\n一般都只用在跨进程的调用当中，跟现在所使用的DTO基本可以等同为同一个东西，现在的DTO也广泛在系统各层之间传输数据使用\n\nDTO中的域应该都是非常原始和简单的，主要是要求可被序列化\n\n### 如何序列化\n\n- 自动化\n- 传输双方保持一致\n\n#### 组装器模式\n\n组装器对象负责将领域对象转为DTO\n\n```mermaid\nclassDiagram\n  class Assembler {\n    PersonDTO createDTO(Person)\n    Person createEntity(PersonDTO)\n  }\n  Person <.. Assembler\n  PersonDTO <.. Assembler\n```\n","metadata":"tags: ['架构', '架构模式']","hasMoreCommit":true,"totalCommits":21,"commitList":[{"date":"2025-09-10T16:04:53+08:00","author":"MY","message":"docs(architecture): update architecture patterns documentation","hash":"e432bd3b11bac2375e1fb89430f70e1fcbdf9e77"},{"date":"2024-12-27T13:54:07+08:00","author":"MY","message":"📦架构模式","hash":"e31397c57f070cb93528cd5b1e2bc035fa94d032"},{"date":"2024-10-25T11:43:52+08:00","author":"MY","message":"📦架构模式","hash":"7a4552433037b568c78fb856bbb5268f027deae4"},{"date":"2024-10-24T19:49:57+08:00","author":"MY","message":"📦架构模式","hash":"a551d051619867158bb04eeaa366fa6e7a0f13d1"},{"date":"2023-03-09T09:41:00Z","author":"My","message":"🛠替换在线图片","hash":"0c8b08bc22fbe482ba02da2f1fcad211441d3c23"},{"date":"2022-05-30T18:16:33+08:00","author":"cjiping","message":"✏️更新 架构模式","hash":"3e437a94f24a8a98cbcee73c98dcf9ec8191086b"},{"date":"2022-05-09T21:01:06+08:00","author":"MY","message":"✏️更新 扩展性","hash":"6a0623425340413483e448a9c2bee55c5b6fd708"},{"date":"2022-05-03T16:55:06+08:00","author":"MY","message":"✏️更新 架构","hash":"6fd9e1ee0dc0d30595be0a9691ec375cd5496551"},{"date":"2022-01-27T11:38:09+08:00","author":"cjiping","message":"📦整理随手","hash":"f5ec44c039a7d8dec55ca7b4885582d06c059e22"},{"date":"2022-01-04T10:28:49+08:00","author":"cjiping","message":"📦整理 架构 相关","hash":"086a4c105f4e473d80fa2d44e5416a06fd30cc5c"}],"createTime":"2020-01-11T14:47:57+08:00"}