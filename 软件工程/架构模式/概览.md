# 表述

## 分层架构

![批注 2020-06-26 092443](/assets/批注%202020-06-26%20092443.png)

将系统按照职责拆分和组织，上层依赖于下层定义的各种服务，下层对上层隐藏下下层的细节

层次并不能封装所有东西，有时会带来级联修改，过多的层次也会影响性能

- OSI七层模型
- CS/BS架构
- 企业应用分层
  - 表现层
  - 领域层
  - 数据源层

### 为何分层

- 关注点分离（降低复杂度）
- 隔离变化/错误
- 扩展性伸缩性
- 可测试性

### 分层的问题

- 性能开销：通信、数据转化
- 开发成本

### 分层架构设计

- [依赖原则](/软件工程/架构/软件架构.md#依赖关系规则)
- 定义职责：职责分离 高层抽象
- 层技术栈选择：每层需求自定 参考成功架构 适合自己组织
- 集成：单层内部的单元测试 -> 层之间的集成测试

### 分层架构模型

#### MVC

随着前后端分离以及后端微服务化的不断发展，传统的MVC已不适合现在的纯后端系统，Controller其实也是API，它代表了服务对外提供的接口，是一种合约

- model:模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器
- view:视图代表模型包含的数据的可视化
- controller:控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开

- Model1模型

![2021106133223](/assets/2021106133223.jpg)

- Model2模型

![202110613336](/assets/202110613336.jpg)

当有用户的行为触发操作时，会有控制器更新模型，并通知视图进行更新，在这时视图向模型请求新的数据

**优势**

- 清晰的职责划分
- 组件独立，代码重用
- 后期维护方便
- 适合任何项目

**弊端**

- 展示数据慢（针对jsp）
- 对开发者架构设计能力要求高
- 异步交互不方便

#### MVP

![2021106132821](/assets/2021106132821.png)

- Presenter较为复杂 可以脱离view进行测试

#### [MVVM](/编程语言/JavaScript/Vue/nav.md#MVVM)

#### BFF

- 为前端而生的后端服务

![](/assets/20201119152838.png)

## 事件驱动架构

- 异步分发事件
  - 发生的事件
  - 变化的状态
- 耦合较低 灵活 扩展较容易
- 由于异步与细粒度的处理单元 正常情况下性能较高 但在出现异常重试时性能会降低
- **集成测试、维护很难**

### 两种模式

#### Mediator

![2021106152652](/assets/2021106152652.png)

- Event Queue：只关注事件的接收和发送
- Event Mediator：将原始事件转化成业务事件
- Event Channel：业务事件的聚合 由感兴趣的processor监听
- Event Processor：业务事件执行单元

#### Broker

![202110615598](/assets/202110615598.png)

- 无中心编排控制点
- 无业务逻辑的消息分发

两种模式的processor都是单一职责的最小执行单元

## 组织领域逻辑

- 编写业务逻辑

### 事务脚本

优点

- 易于理解
- 能与简单数据源层很好合作
- 事务边界容易划分

缺点

- 业务复杂导致代码冗余复杂

#### 领域模型

- 使用面向对象的方法

开销来源于使用复杂以及数据源的复杂，还要面对将领域模型映射到数据库的问题

### 表模块

- 围绕表组织领域逻辑

### 服务层

- 将领域层再拆为两层，服务层提供简单的API接口

## 映射到关系数据库

### 架构模式

- 活动记录
  - 类似于JAVA Bean
- 数据映射器
  - ORM

### 行为

如何保证对领域对象的修改能及时存储到数据库

- 标志映射
  - 保证相同的对象只被加载一次
- 延迟加载

### 读取数据

### 结构映射模式

#### 关系的映射

- 外键映射一对多
- 关联表映射多对多

#### 继承

- 单表继承
  - 多个层次共享同一张表

![](https://chuhang123.github.io/images/97.png)

- 具体表继承
  - 一个层次一张表

![](https://chuhang123.github.io/images/100.png)

- 类表继承
  - 一个类一张表

![](https://chuhang123.github.io/images/98.png)

### 建立映射

将数据库设计看做一种持久化对象数据的方法

- 双向映射
  - 将对象-数据库以及数据库-对象两种映射分开设计

### 元数据

- 通过元数据的描述自动生成代码

### 数据库连接

- 使用连接池管理连接
- 将连接与事务绑定在一起

## web表现层

### 模板视图

jsp php

### 转换视图

json

### 两阶视图

生成一个逻辑视图，再将逻辑视图对应到html

## 并发

### 本质问题

- 更新丢失
- 不一致读

### 执行语境

- 一个请求对应一个会话，可以使进程，也可以是线程，但创建进程耗费资源，使用线程又会导致线程安全问题
- 数据库中的语境是事务

### 方案

- 隔离：划分数据，一片数据只能被一个工作单元访问
- 不变：不变的数据是线程安全的

#### 乐观锁与悲观锁

- 使用读写控制
- 死锁

### 事务

事务是一个又边界的工作序列，开始和结束都有明确定义

- 事务的特性

#### 事务资源

横跨多个请求的被称为长事务

锁升级：一个事务锁住了许多行，则直接升级到对整个表的锁

#### 减少事务隔离提高灵活性

可串行化：当并发执行的结果与以某种顺序一致时

#### 系统事务与业务事务

#### 离线并发控制

只有在数据提交失败的时候才能发现

### 应用服务器并发

使用每会话一个进程的方式来避免处理线程的麻烦

## 会话状态

- 无状态服务器

### 存储方法

- 客户端存储
  - cookie
  - 注意会话数据大小以及数据安全性完整性
- 服务器存储
  - session
- 数据库存储
  - 将会话信息存储在数据库中

### 会话迁移

会话可以在服务器集群之间转移

## 分布

### 远程接口与本地接口

进程内的过程调用非常快

### 何时必须使用分布对象

- 客户机与服务器之间
- 服务器与数据库之间
- web系统之间
- 使用软件包

### 分布边界

注意远程调用的边界

### 分布接口

- 基于XML与HTTP

如果系统基于相同的平台构建，最好使用系统自己的远程调用机制







