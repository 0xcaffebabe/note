{"name":"创建型模式","id":"软件工程-设计模式-创建型模式","content":"# 创建型模式\n\n- 封装了系统使用哪些类\n- 隐藏了这些类类的实例是如何创建和放在一起的\n\n## 建造者\n\n> 将复杂对象的构建与表示相分离，同样的构建过程可以创建不同的表示\n\n为了应对在对象创建过程中，构造函数参数过多、参数间有依赖关系或约束条件、以及对象希望不可变等复杂场景。通过Builder模式，能够将对象的创建逻辑集中在一个单独的Builder类中，避免了构造函数参数过长、校验逻辑难以安放、以及对象处于无效状态等问题\n\n```mermaid\nclassDiagram\n    class Builder {\n        +buildPart()\n    }\n    class ConcreteBuilder {\n        +buildPart()\n        +getResult()\n    }\n    Builder <|-- ConcreteBuilder\n    ConcreteBuilder --> Product\n    class Director {\n        +construct()\n    }\n    Director o--> Builder\n```\n\n- 可以改变一个产品内部表示\n- 构造代码与表示代码分离\n- 对构造进行更细粒度的控制\n\n```java\ninterface Builder{\n    Builder process1();\n    Builder process2();\n    Builder process3();\n    Product build();\n}\nclass ConcreteBuilder implements Builder{\n    // 方法实现...\n}\nclass ProductDirector{\n    public Product constructProduct(Builder builder){\n        builder.process1();\n        builder.process2();\n        builder.process3();\n        return builder.build();\n    }\n}\n// 使用\nProductDirector director = new ProductDirector();\nProduct product = director.constructProduct(new ConcreteBuilder());\n```\n\n## 工厂模式\n\n- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。\n- 代码复用：创建代码抽离到独立的工厂类之后可以复用。\n- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。\n- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。\n\n### 简单工厂\n\n客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可\n\n```java\nclass Factory{\n    public Product get(int condition){\n        switch(condition){\n            case 1:\n                return new Product1();\n            case 2:\n                return new Product2();\n        }\n        return null;\n    }\n}\n```\n\n但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护\n\n### 工厂方法\n\n> 定义一个接口，让子类创建该接口的实例，也就是将实例化延迟到工厂的子类\n\n```mermaid\nclassDiagram\n    ConcreteProduct --|> Product\n    class ConcreteCreator {\n        +factoryMethod() ConcreteProduct\n    }\n    class Creator {\n        +factoryMethod() Product\n        +operation()\n    }\n    ConcreteCreator --|> Creator\n    ConcreteCreator ..> ConcreteProduct\n\n```\n\n- 工厂方法模式适合于构造同属于同一个类别的不同产品，所有的产品属于同一个系列中\n\n模板方式和工厂模式的核心思想非常类似， 都是把一些操作留给子类去实现。模板方法经常使用工厂方法作为其算法的一部分\n\n```java\nabstract class AbstractCreator{\n    abstract Product get();\n\n    public void doSomething(){\n        // do something\n        Product product = get();\n        // do something\n    }\n}\nclass Creator1 extends AbstractCreator{\n    Product get(){...}\n}\nclass Creator2 extends AbstractCreator{\n    Product get(){...}\n}\n// 使用\nFactory factory = new Creator2();\nProduct product = factory.doSomething();\n```\n\n### 抽象工厂\n\n> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类\n\n```mermaid\nclassDiagram\n    class AbstractFactory {\n        +createProductA()\n        +createProductB()\n    }\n    class ConcreteFactory1 {\n        +createProductA()\n        +createProductB()\n    }\n    class ConcreteFactory2 {\n        +createProductA()\n        +createProductB()\n    }\n    ConcreteFactory1 --|> AbstractFactory\n    ConcreteFactory2 --|> AbstractFactory\n    \n    ProductA1 --|> AbstractProductA\n    ProductA2 --|> AbstractProductA\n    \n    ProductB1 --|> AbstractProductB\n    ProductB2 --|> AbstractProductB\n\n    client ..> AbstractFactory\n    client ..> AbstractProductA\n    client ..> AbstractProductB\n```\n\n- 分离了具体的类\n- 使得产品改变变得容易\n- 利于维护产品的一致性\n- **扩展产品种类困难**\n\n```java\nabstract class Factory{\n    abstract Product get(int condition);\n}\nclass ProductAFactory extends Factory{\n    ProductA get(int condition){...}\n}\nclass ProductBFactory extends Factory{\n    ProductB get(int condition){...}\n}\n// 使用\nFactory factory = new ProductAFactory();\nProduct product = factory.get(condition);\n```\n\n在实践中，每个工厂一般都会是单例。工厂内部可使用原型模式来实现\n\n## 原型\n\n>通过一个原型对象创建新的对象\n\n为了应对创建成本较高的对象，尤其是当同类对象之间差异不大时。原型模式通过复制（或拷贝）现有对象来创建新对象，从而节省时间和资源\n\n```mermaid\nclassDiagram\n    class Prototype {\n        +clone()\n    }\n    class ConcretePrototype1 {\n        +clone()\n    }\n    class ConcretePrototype2 {\n        +clone()\n    }\n    Prototype <|-- ConcretePrototype1\n    Prototype <|-- ConcretePrototype2\n    Client --> Prototype\n```\n\n- 可以在运行时刻动态改变产品种类\n- 改变值或结构就能获得新对象\n- 动态配置\n\n```java\nclass Product {\n    Part1 part1;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Product product = (Product) super.clone();\n        product.part1 = (Part1)part1.clone();\n        return product;\n    }\n}\n```\n\n## 单例\n\n>一个类仅有一个实例，并只拥有一个全局访问点\n\n问题：谁来销毁单例对象？什么时候销毁？\n\n- 单例模式适用于生命周期很长的对象 一般不会显式销毁\n- 使用SingletonDestroyer在程序关闭时进行销毁\n    - 对于相互依赖的单例对象 需要注意顺序\n\n### 饿汉式\n\n- 类初始化时,会立即加载该对象，线程天生安全,调用效率高\n\n```java\npublic class Singleton {\n    private static final Singleton SINGLETON = new Singleton();\n    private Singleton() { }\n    \n    public static Singleton getInstance(){\n        return SINGLETON;\n    }\n}\n```\n\n### 懒汉式\n\n- 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能\n\n```java\npublic class Singleton {\n    private static Singleton SINGLETON ;\n    private Singleton() { }\n\n    // 线程不安全\n    public static Singleton getInstance(){\n        if (SINGLETON == null){\n            SINGLETON = new Singleton();\n        }\n        return SINGLETON;\n    }\n}\n```\n\n### 静态内部类方式\n\n- 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的\n\n```java\npublic class Singleton {\n    \n    private Singleton() { }\n\n    private static class SingletonClass{\n        public static final Singleton SINGLETON = new Singleton();\n    }\n    \n    public static Singleton getInstance(){\n        return SingletonClass.SINGLETON;\n    }\n}\n```\n\n### 枚举单例\n\n- 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载\n\n```java\npublic class Singleton {\n\n    private Singleton() { }\n\n    private enum  SingletonEnum{\n        INSTANCE;\n        private Singleton singleton;\n\n        SingletonEnum() {\n            singleton = new Singleton();\n        }\n\n        public Singleton getSingleton() {\n            return singleton;\n        }\n    }\n\n    public static Singleton getInstance(){\n        return SingletonEnum.INSTANCE.getSingleton();\n    }\n}\n```\n\n### 双重检测加锁\n\n```java\npublic class Singleton {\n\n    private static volatile Singleton SINGLETON; // 如果没有volatile JVM的指令重排序很有可能导致实例化多个对象\n\n    private Singleton() { }\n\n    public static Singleton getInstance(){\n        if (SINGLETON == null){\n            synchronized (Singleton.class){\n                if (SINGLETON == null){\n                    SINGLETON = new Singleton();\n                }\n            }\n        }\n        return SINGLETON;\n    }\n}\n```\n\n\n```java\n// SINGLETON = new Singleton() 可以分解为以下三个步骤\n1 memory=allocate();// 分配内存 相当于c的malloc\n2 ctorInstanc(memory) //初始化对象\n3 s=memory //设置s指向刚分配的地址\n\n// 上述三个步骤可能会被重排序为 1-3-2，也就是：\n1 memory=allocate();// 分配内存 相当于c的malloc\n3 s=memory //设置s指向刚分配的地址\n2 ctorInstanc(memory) //初始化对象\n```\n\n### 单例的问题\n\n1. 对 OOP 特性的支持不友好：单例模式对面向对象编程（OOP）的抽象、继承和多态特性支持不足。它违背了“基于接口而非实现”的设计原则，导致代码在需求变化时需要大范围修改，并且单例类的继承和多态实现也会使代码的可读性和扩展性降低。\n2. 隐藏类之间的依赖关系：单例模式直接调用类方法，而不需要通过构造函数或参数传递依赖关系。这种隐式依赖使得代码难以阅读和理解，尤其在代码复杂时，难以清晰地识别类与类之间的依赖关系。\n3. 对代码的扩展性不友好：单例模式只允许一个实例对象，当系统需求变化需要多个实例时，单例模式难以适应，可能导致大范围的代码修改\n4. 对代码的可测试性不友好：单例模式的硬编码方式难以进行依赖注入或替换，导致代码难以进行单元测试。同时，单例类如果持有可变全局变量，还会导致测试用例之间的相互影响。\n5. 不支持有参数的构造函数：单例模式通常不支持传递参数来创建实例，限制了其灵活性。虽然可以通过 init() 方法或其他方式来绕过这一限制，但这些方法可能引发新的问题，如参数无效而未提示用户的问题\n","metadata":"","hasMoreCommit":true,"totalCommits":15,"commitList":[{"date":"2024-09-03T20:07:11+08:00","author":"MY","message":"✏设计模式","hash":"3d86449a875acd8fc0644eb1edcf0fe13c648f50"},{"date":"2024-09-02T19:11:18+08:00","author":"MY","message":"✏设计模式","hash":"0cac710dd36ced4e169f855bdc8cbfccf3f1e880"},{"date":"2023-11-08T19:10:41+08:00","author":"MY","message":"📦创建型模式","hash":"916f86134b519d886d6287af2092bbb563428e39"},{"date":"2023-03-09T02:59:03Z","author":"My","message":"✏设计模式","hash":"59189b4c38ed20fc71e63bf7a64d14f88a943543"},{"date":"2021-06-04T11:41:31+08:00","author":"cjiping","message":"✏更新 工厂方法模式","hash":"9c689a24adae6437a813df30665910ae808e6dc5"},{"date":"2021-04-12T14:35:08+08:00","author":"cjiping","message":"✏更新 volatile","hash":"95d9dfe55e8c3289b722f1e25f9ea412a2c6ae73"},{"date":"2021-04-09T15:50:21+08:00","author":"cjiping","message":"✏更新 设计模式","hash":"8f5ab3ac8d7c517e66f721da31571066a8af695c"},{"date":"2020-12-14T10:37:41+08:00","author":"cjiping","message":"✏更新 设计模式 单例模式","hash":"0897488b763fb8422a564d314ef28e7bca9646fb"},{"date":"2020-08-06T12:48:58+08:00","author":"MY","message":"✏更新 设计模式 工程方法","hash":"87fe0a418d65e45cf721417e14c045d14633d128"},{"date":"2020-01-06T15:06:14+08:00","author":"MY","message":"更新原型模式","hash":"09da345424e1490234022b2605fc9089a8ea40d1"}],"createTime":"2019-11-25T09:27:14+08:00"}