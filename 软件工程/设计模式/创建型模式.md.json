{"name":"创建型模式","id":"软件工程-设计模式-创建型模式","content":"# 创建型设计模式\n\n## ——对象诞生的控制权与系统稳定性\n\n---\n\n## 一、为什么需要创建型模式（第一性原理）\n\n在软件系统中，对象的创建并不是一个“语法问题”，而是一个**架构控制问题**。\n\n> **创建型模式解决的核心不是“如何 new 对象”，\n> 而是：谁来控制对象的诞生方式、创建时机与生命周期？**\n\n当系统规模扩大，对象创建会暴露出三个根本性风险：\n\n1. **变化失控**\n\n   * 产品类型变化\n   * 构造过程变化\n   * 内部结构变化\n\n2. **复杂性泄漏**\n\n   * 构造参数过多\n   * 校验逻辑分散\n   * 对象可能处于非法状态\n\n3. **生命周期失序**\n\n   * 全局对象泛滥\n   * 隐式依赖\n   * 并发与销毁问题\n\n👉 **创建型模式的本质目标**：\n\n> **将“对象如何诞生”的不稳定性，从业务逻辑中隔离出来，\n> 并集中到可治理、可演进的位置。**\n\n---\n\n## 二、创建型模式的稳定抽象框架\n\n从原理层看，所有创建型模式都在回答同一组问题：\n\n| 维度    | 核心问题              |\n| ----- | ----------------- |\n| 创建时机  | 立即创建？延迟创建？按需创建？   |\n| 创建复杂度 | 一步完成？多步构造？复制生成？   |\n| 生命周期  | 短生命周期？长生命周期？全局唯一？ |\n| 变化来源  | 类型变化？结构变化？产品族变化？  |\n\n不同模式 = **对这些变量的不同控制策略**\n\n---\n\n## 三、构建复杂对象：Builder（建造者）\n\n### 1. 设计动机（原理层）\n\n当一个对象的创建：\n\n* 构造参数过多\n* 参数之间存在约束关系\n* 构造步骤有顺序与组合变化\n* 对象希望保持不可变\n\n此时，**“构造函数”已不再是合适的抽象**。\n\n> Builder 的本质：\n> **将“构建过程”从“最终表示”中剥离出来**\n\n---\n\n### 2. 核心思想（架构层）\n\nBuilder 引入三个角色分离关注点：\n\n| 角色              | 责任       |\n| --------------- | -------- |\n| Builder         | 定义构建步骤   |\n| ConcreteBuilder | 实现具体构建细节 |\n| Director        | 控制构建顺序   |\n\n👉 **控制权变化**：\n对象不再“被一次性构造”，而是“被过程性组装”。\n\n---\n\n### 3. Builder 解决的不是“复杂”，而是“可变复杂”\n\nBuilder 适用于：\n\n* 构建步骤 ≥ 3\n* 步骤顺序可能变化\n* 同一过程生成不同表示\n\n而**不适用于**：\n\n* 简单 DTO\n* 结构稳定、无约束的对象\n\n---\n\n### 4. 工程示例（实现层）\n\n```java\ninterface Builder {\n    Builder process1();\n    Builder process2();\n    Builder process3();\n    Product build();\n}\n```\n\nDirector 将构建逻辑集中：\n\n```java\npublic Product constructProduct(Builder builder){\n    builder.process1();\n    builder.process2();\n    builder.process3();\n    return builder.build();\n}\n```\n\n---\n\n## 四、封装“类型变化”：工厂体系\n\n### 1. 工厂模式的统一抽象\n\n> **工厂模式的本质不是“替你 new”，\n> 而是：将“产品类型变化”从使用方隔离出去**\n\n---\n\n### 2. 简单工厂：集中决策（但不可扩展）\n\n* 优点：\n\n  * 使用方无需关心具体类\n* 根本问题：\n\n  * 决策逻辑集中\n  * 违反开闭原则\n\n👉 **适合小系统，不适合演进型系统**\n\n---\n\n### 3. 工厂方法：延迟实例化到子类\n\n> **将“创建哪个产品”的决策权，下放到子类**\n\n核心思想：\n\n* 父类定义使用流程\n* 子类决定具体产品\n\n这使得：\n\n* 新产品通过新增子类完成\n* 原有逻辑无需修改\n\n👉 工厂方法本质上是一种\n**“创建逻辑的多态化”**\n\n---\n\n### 4. 抽象工厂：控制产品族一致性\n\n抽象工厂解决的是更高阶的问题：\n\n> **不是“创建一个产品”，\n> 而是“创建一组相互依赖、风格一致的产品”**\n\n典型场景：\n\n* UI 组件族\n* 跨平台适配\n* 数据库驱动族\n\n⚠️ 代价：\n\n* **扩展产品族容易**\n* **扩展产品种类困难**\n\n---\n\n### 5. 工厂体系的稳定认知总结\n\n| 模式   | 控制的变化  |\n| ---- | ------ |\n| 简单工厂 | 创建参数   |\n| 工厂方法 | 产品类型   |\n| 抽象工厂 | 产品族一致性 |\n\n---\n\n## 五、复制而非构造：Prototype（原型）\n\n### 1. 原理动机\n\n当对象：\n\n* 创建成本高\n* 同类对象差异小\n* 构建步骤复杂但稳定\n\n此时，“重新构建”是一种浪费。\n\n> 原型模式的核心思想：\n> **用已有实例作为创建模板**\n\n---\n\n### 2. Prototype 的真正价值\n\n* 运行期动态改变对象种类\n* 快速生成配置化对象\n* 避免复杂构造链\n\n但其风险在于：\n\n* 深拷贝成本\n* 状态一致性\n* 引用对象共享问题\n\n---\n\n### 3. 工程实现要点\n\n```java\n@Override\nprotected Object clone() throws CloneNotSupportedException {\n    Product product = (Product) super.clone();\n    product.part1 = (Part1) part1.clone();\n    return product;\n}\n```\n\n👉 **原型的难点不在 clone，而在“复制语义是否正确”**\n\n---\n\n## 六、全局唯一与生命周期治理：Singleton\n\n### 1. Singleton 的真实定位\n\n> Singleton 解决的不是“创建问题”，\n> 而是**“全局生命周期失控问题”**\n\n它本质上是一种：\n\n* 生命周期管理手段\n* 全局访问策略\n\n---\n\n### 2. 单例的工程实现方式（实现层）\n\n* 饿汉式：简单、安全，但无延迟加载\n* 懒汉式：需处理并发\n* 静态内部类：推荐方案\n* 枚举：JVM 级保障\n* 双重检查锁：并发优化方案\n\n这些都是**实现策略**，而非设计本身。\n\n---\n\n### 3. Singleton 的系统性问题（原理层）\n\n* 隐藏依赖关系\n* 破坏可测试性\n* 引入全局状态\n* 阻碍演进为多实例\n\n👉 **Singleton 往往是“阶段性方案”，而非终局设计**\n\n---\n\n### 4. 演进路径\n\n```\nSingleton\n   ↓\nFactory + 配置\n   ↓\nDI 容器\n   ↓\n显式生命周期管理\n```\n\n---\n\n## 七、创建型模式的统一对照（稳定知识）\n\n| 模式               | 核心控制点 | 主要代价   |\n| ---------------- | ----- | ------ |\n| Builder          | 构建过程  | 引入额外对象 |\n| Factory Method   | 产品类型  | 类数量增加  |\n| Abstract Factory | 产品族   | 扩展受限   |\n| Prototype        | 创建成本  | 拷贝复杂   |\n| Singleton        | 生命周期  | 全局状态   |\n\n## 关联内容（自动生成）\n\n- [/软件工程/设计模式/设计模式.md](/软件工程/设计模式/设计模式.md) 介绍了设计模式的基本概念、关键属性和演化规律，是理解创建型模式的基础\n- [/软件工程/设计模式/结构型模式.md](/软件工程/设计模式/结构型模式.md) 与创建型模式共同构成设计模式体系，结构型模式关注类和对象的组合，与创建型模式的对象创建问题相辅相成\n- [/软件工程/设计模式/行为模式.md](/软件工程/设计模式/行为模式.md) 与创建型模式共同构成完整的GOF设计模式体系，行为模式关注对象间的职责分配，与创建型模式的对象创建问题形成互补\n- [/软件工程/领域驱动设计.md](/软件工程/领域驱动设计.md) 中提到了工厂模式在领域驱动设计中的应用，创建型模式在领域模型构建中发挥重要作用\n- [/编程语言/JAVA/框架/Spring/Spring.md](/编程语言/JAVA/框架/Spring/Spring.md) Spring框架中的依赖注入和控制反转体现了创建型模式的思想，特别是工厂模式的应用\n- [/软件工程/架构模式/分层架构.md](/软件工程/架构模式/分层架构.md) 分层架构中的设计模式与创建型模式相关，特别是在对象创建和生命周期管理方面\n- [/操作系统/操作系统设计.md](/操作系统/操作系统设计.md) 操作系统设计中也包含创建型模式的思想，如对象管理、资源分配等\n- [/编程语言/JAVA/JAVA并发编程/并发集合.md](/编程语言/JAVA/JAVA并发编程/并发集合.md) 并发集合的实现中使用了创建型模式来管理对象的创建和生命周期\n- [/软件工程/架构/系统设计/高并发.md](/软件工程/架构/系统设计/高并发.md) 高并发系统设计中大量使用创建型模式来处理性能和扩展性问题，如对象池等\n- [/中间件/消息队列/消息队列.md](/中间件/消息队列/消息队列.md) 消息队列中也涉及创建型模式，如生产者对象的创建和管理\n","metadata":"tags: ['设计模式', '软件工程']","hasMoreCommit":true,"totalCommits":17,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2025-12-30T18:08:57+08:00","author":"MY","message":"docs(design-patterns): 重构创建型设计模式文档结构并完善内容体系","hash":"68969fe68e86fed4c03532c1b364f60721e49a41"},{"date":"2024-09-03T20:07:11+08:00","author":"MY","message":"✏设计模式","hash":"3d86449a875acd8fc0644eb1edcf0fe13c648f50"},{"date":"2024-09-02T19:11:18+08:00","author":"MY","message":"✏设计模式","hash":"0cac710dd36ced4e169f855bdc8cbfccf3f1e880"},{"date":"2023-11-08T19:10:41+08:00","author":"MY","message":"📦创建型模式","hash":"916f86134b519d886d6287af2092bbb563428e39"},{"date":"2023-03-09T02:59:03Z","author":"My","message":"✏设计模式","hash":"59189b4c38ed20fc71e63bf7a64d14f88a943543"},{"date":"2021-06-04T11:41:31+08:00","author":"cjiping","message":"✏更新 工厂方法模式","hash":"9c689a24adae6437a813df30665910ae808e6dc5"},{"date":"2021-04-12T14:35:08+08:00","author":"cjiping","message":"✏更新 volatile","hash":"95d9dfe55e8c3289b722f1e25f9ea412a2c6ae73"},{"date":"2021-04-09T15:50:21+08:00","author":"cjiping","message":"✏更新 设计模式","hash":"8f5ab3ac8d7c517e66f721da31571066a8af695c"},{"date":"2020-12-14T10:37:41+08:00","author":"cjiping","message":"✏更新 设计模式 单例模式","hash":"0897488b763fb8422a564d314ef28e7bca9646fb"}],"createTime":"2019-11-25T09:27:14+08:00"}