# 行为模式

## 责任链

> 使多个对象都有机会处理请求，避免发送者与接受者之间的耦合

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574654436690&di=48ae1c547c211016404e86d225d15050&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D519770121%2C2436189056%26fm%3D214%26gp%3D0.jpg)

- 拥有动态添加职责的灵活性
- **不保证被接受**

## 命令

> 将请求封装为对象

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574654593472&di=91a10ee12e6e2863bfb8f73c97318f13&imgtype=jpg&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1495264788%2C3257090640%26fm%3D214%26gp%3D0.jpg)

## 解释器

> 定义一个文法，定义一个解释器，解释器解释执行做一些操作

![](https://images0.cnblogs.com/blog/533121/201412/091203106181898.png)

## 迭代器

> 提供一种顺序访问对象中的各个元素，并不暴露内部表示

![](http://image.codes51.com/Article/image/20160509/20160509193506_2193.jpg)

- 外部迭代与内部迭代的区别在于是由客户还是迭代器控制迭代

## 中介者

> 用一个中介对象封装一系列对象之间的交互

- 与外观模式不同之处在于中介模式的交互是双向的，而外观模式只是从外观对象到子系统之间的单向协议

![](https://imgedu.lagou.com/1209090-20190829171805208-637969589.png)

## 备忘录

> 不破坏封装性的情况下，保存一个对象的内部状态

![](https://www.cnblogs.com/images/cnblogs_com/yangfengming/Design%20Patterns/21.Memento_01.jpg)

## 观察者

>

