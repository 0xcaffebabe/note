{"name":"整洁代码","id":"软件工程-软件设计-代码质量-整洁代码","content":"# 整洁代码\n\n代码是需求的精确性表达 代码不会消失\n\n- 读起来令人愉悦\n- 只做好一件事\n- 明确地展现出要解决问题的张力\n- 整洁代码以测试作为基础\n- 不要重复代码\n- 深合己意\n\n代码更多的时候是用来读\n\n## 命名\n\n名副其实：变量 函数 类的名称要充分体现它们的作用\n\n避免误导：\n\n- 避免使用与本意相悖的词\n\n```java\nAccounts accountList; // bad\nList<Account> accountList; // good\n```\n\n- 谨慎使用不同之处特别小的名称\n\n```java\nvar userPermissionControllService;\nvar userPermissionControllerService;\n```\n\n- 以及小写字母l与大写字母O与数字 1 0 相似的情况\n\n```java\nint l = 0;\nint o = 1;\nif (l == 0) return o = l;\n```\n\n有意义的区分：\n\n- 避免使用数字系列命名\n\n```java\nvoid copy(StringBuffer s1, StringBuffer s2); // bad\nvoid concat(StringBuffer source, StringBuffer target); // good\n```\n\n- 避免使用意义相同的名称\n\n```java\nclass Product{}\nclass ProductInfo{} // 加个Info并没有说明什么\nclass ProductDetail{}\n```\n\n使用读得出来的名称: 方便讨论\n\n使用可搜索的名称：\n\n- 为常量命名 方便维护\n\n```java\ndouble circleArea = 3.14 * Math.pow(radius, 2); // bad\n\ndouble CIRCLE_PI = 3.1415926; // good\n```\n\n- 名称长短与其作用域大小相对应\n\n```java\nprivate static final double CIRCLE_PI = 3.14;\n\nvoid calcArea() {\n  final double PI = 3.14\n  ...\n}\n```\n\n避免使用编码：这些技巧在IDE智能的时代有它的用处\n\n- 避免匈牙利标记法在变量名称携带类型\n\n```java\nint iPort = 8080; // 该变量为int类型 bad\n```\n\n- 避免前缀标记成员变量\n\n```java\nprivate List<Listeners> m_listeners; // bad\n```\n\n- 避免避免接口与实现携带I前缀或者Imp后缀\n\n```java\ninterface IUserService{} // bad\nclass UserServiceImp implements UserService {} // bad\nclass DefaultUserService implements UserService {} // good\n```\n\n避免思维映射：传统管用i j 表示循环计数器 其他情况下要避免使用单字母\n\n```java\nfor (int i=0;i<MAX;i++){...} // 遵循传统惯例\nint r = calcArea(); // bad\n```\n\n类名与对象名应该是名词或者名词短语\n\n```java\nclass Customer{}\nProcessor processor;\n```\n\n方法名应该是动词或者动词短语\n\n```java\nvoid getServerInfo();\n```\n\n命名时避免抖机灵\n\n```java\nthreadPoll.kill(); // bad\nthreadPoll.shutdown(); // good\n```\n\n使用概念一致的命名：\n\n- SELECT DELETE UPDATE INSERT\n\n避免将同一术语用于不同概念\n\n```java\n// bad\nvoid addUser();\nBigDecimal addPrice(BigDecimal target);\n```\n\n尽量使用技术性名称而非业务领域名称 是在没有技术名词 与问题领域更近的代码 可以采用业务领域的名称\n\n```java\nQueue<Job> jobQueue; // 技术名词\nDinnerOrder order; // 业务名词\n```\n\n如果无法通过类或者方法来给名称提供上下文 那么只能给名称添加前缀来添加上下文了\n\n```java\nclass Address {\n  String username;\n  String phone;\n  String country;\n  String postCode;\n}\nString addressCode; // 在一个没有上下文的环境中\n```\n\n短名称够清楚就行了 不要添加不必要的上下文 \n\n```java\nclass ShopSystemUserService {} // bad\n```\n\n## 函数\n\n短小：\n\n- 块内调用的子函数具有说明性\n\n```java\nString renderJsp(){\n  var classCode = compileJsp();\n  return executeJspService(classCode);\n}\n```\n\n- 不该有复杂的嵌套结构\n\n```java\nvoid badFunction() { // bad\n  if (..) {\n    while(){\n      ...\n      for(..){..}\n    }\n  }\n}\n```\n\n\n只做一件事：函数内部的实现充分体现函数名称\n\n确保函数中的语句在同一抽象层级上面\n\n```java\nString renderJsp(){\n  var classCode = compileJsp();\n  return executeJspService(classCode);\n}\n```\n\n使用多态取代switch语句\n\n```java\n// bad\nMoney calcPay(Employee e){\n  switch(e.type) {\n    case MANAGER:\n      return e.getPay() - 20%;\n    case COMMON:\n      return e.getPay() - 10%;\n    ...\n  }\n}\n// good\nabstract class Employee{\n  abstract Money getPay();\n}\nclass CommonEmployee{\n  Money getPay(){...}\n}\nclass ManagerEmployee{\n  Money getPay(){...}\n}\n```\n\n使用描述性的名称能理性设计思路 帮助改进之\n\n```java\nvar result;\nvar searchResult;\nvar movieSearchResult; // best\n```\n\n函数参数：\n\n- 参数越多函数越难理解\n\n```java\npublic void convertAndSend(Object object){..}\npublic void correlationConvertAndSend(Object object, CorrelationData correlationData){..}\npublic void convertAndSend(String routingKey, final Object object, CorrelationData correlationData){...} // bad\n\nexchange.send(String rotingKey,Object msg); // better\n```\n\n- 使用标志参数(boolean)就代表函数不止做一件事 应该拆分成两个函数\n\n```java\nvoid submitTask(Task t, boolean flag){ // 尤其flag命名并不能说明做什么 改成isSync 可能好一点\n  if (flag) {\n    sync\n  }else {\n    async\n  }\n}\n// good\nvoid submitTaskAsync(){...}\nvoid submitTaskSync(){...}\n```\n\n- 函数和参数应当形成一种动词/名词对形式\n\n```java\nwrite(PrintWriter pw, String msg); // bad\nprintWriter.write(msg); // good\n```\n\n副作用：避免使用输出参数(out) 需要修改状态 就将该状态作为对象的属性\n\n```java\nvoid removeNegative(List<Integer> list); // bad\nlist.removeIf(...); // good\n```\n\n分割指令与询问：函数要么做什么 要么回答什么 不能两者得兼\n\n```java\nboolean set(String k, String v){ // bad 这个函数承担了两个职责\n  if (exists){\n    return true;\n  }\n  ...\n  return false;\n}\n// good\nboolean exists(String k);\nvoid set(String k,String v);\n```\n\n异常代替错误码：\n\n- 错误处理代码就能从主路径代码分离出来\n\n```java\n// bad\nif (!err){\n  if (!err){\n    ...\n  }\n}\n// good\ntry {\n\n} catch (Error1){\n\n} catch (Error2){\n\n}\n```\n\n- 主体以及错误处理代码可以抽离成函数\n\n```java\ntry {\n  generateSearchResult();\n} catch(){\n  logError();\n  sendErrorMsg();\n}\n```\n\n- 错误码枚举一旦发生修改 依赖其的模块都要重新编译 使用继承异常的方式可以进行平滑扩展\n\n别重复自己：重复可能是软件中一切邪恶的根源\n\n结构化编程：单一出入口原则在大函数中才有明显的好处\n\n## 注释\n\n- 注释容易与代码不一致 欺骗读者\n- 注释无法美化代码 糟糕的代码还是糟糕的代码\n- 尽可能使用代码阐述你的意图 而非注释\n\n### 好的注释\n\n- 法律信息\n- 提供信息\n\n```java\ninterface SessionFactory {\n  // 新建一个数据库连接并返回\n  Session openSession();\n}\n```\n\n- 对意图的解释\n\n```java\n// 寻找0到n的素数 根据数学证明 只要到n的平方根就行了\nfor(int i=0;i<Math.sqrt(n);i++){...}\n```\n\n- 阐释一些难以理解的参数或者返回值\n\n```java\n// 发送对象为空，代表是一条广播消息\nif (StringUtils.isEmpty(payload.getTo())){\n  ...\n} else {\n  broadcast\n}\n```\n\n- 警示会出现某种后果\n\n```java\n// 该方法使用一个listener的确认 使用synchronized关键字保证只有一个线程能进入\npublic synchronized ConfirmResult sendTextMessage(String target, String text) {...}\n```\n\n- TODO注释\n\n```java\n// 向消息队列写入消息：订单 订单详情 TODO\n```\n\n- 强调方法貌似不合理之处的重要性\n\n```java\nvoid onMessage(ByteBuf buf){\n  ...\n  buf.release(); // 需要减少缓冲区的引用计数\n}\n```\n\n- 公共 API 中的 Javadoc\n\n### 坏注释\n\n- 无法给读者提供有效的信息\n\n```java\n// 提交任务\nboolean success = submitTask();\n```\n\n- 多余的注释/废话注释\n\n编写代码时 着重于代码的表现力 而非加之以注释\n\n```java\n// bad 等待timeout个时间 然后关闭\nvoid close(int timeout){\n  wait(timeout);\n  close();\n}\n```\n\n- 误导性注释 代码与注释所说的不是一回事\n- 循规蹈矩注释：每个方法变量都要javadoc\n- 日志式注释记录每一次修改 在版本控制系统出现后意义不大\n- 标记栏注释\n\n```java\n// 注意!!! ////////////\n```\n\n特别重要才使用 使用多的话 就会被淹没在大量斜杠中\n\n- 括号后面的注释\n\n对于大函数或许才有意义\n\n```java\ntry{\n  if (){\n    while(){\n\n    }//while\n  } // if\n}catch{\n\n} // catch\n```\n\n- 作者与署名 同样 VCS可以工作的更好\n- 注释掉的代码\n- 包含着HTML标签的注释\n- 携带非本地信息\n\n```java\n// 提交任务 每隔5分钟运行一次 这里的5分钟跟这个函数毫无关系\nvoid submitTask();\n```\n\n- 信息过多 将一些RFC提案整个添加到注释里\n\n## 格式\n\n原始代码其代码风格和可读性仍会影响到其可维护性和可扩展性\n\n### 垂直格式\n\n短文件比常文静更易于理解\n\n```java\n// 紧密在一起的代码代表概念相关\nDeliveryInfoDO deliveryInfoDO = new DeliveryInfoDO();\ndeliveryInfoDO.setBuilding(deliveryDTO.getBuilding());\ndeliveryInfoDO.setDetail(deliveryDTO.getDetail());\n                                        // 使用空白行隔开 每个空白行都是一个线索\ndeliveryRepository.save(deliveryInfoDO);\n\nif (deliveryDTO.getDefaultDelivery() != null && deliveryDTgetDefaultDelivery()) {\n    consumerDeliveryRepository.resetDefaultDelivery(consumer.getUserId());\n}\n```\n\n垂直距离：\n\n关系密切的概念应相互靠近\n\n- 本地变量声明尽可能靠近其使用位置\n- 实体变量声明在类的顶部(Java)\n- 有联系的函数放在一起 调用者尽可能在被调用者上面\n\n### 横向格式\n\n尽力保持代码行短小\n\n使用空格分割相关性较弱的元素：\n\n- 分割赋值操作符\n\n```java\nint[] data = new int[10];\n```\n\n- 分割函数参数\n\n```java\ndeliveryService.updateDelivery(token, deliveryId, deliveryDTO);\n```\n\n使用缩进表现源文件的继承结构 缩进可以快速展现出当前的范围\n\n## 对象和数据结构\n\n过程式代码容易在不改动数据结构的情况下增加函数\n\n面向对象则容易在不改动函数的情况下增加新类\n\n迪米特法则：模块不应了解它所操作对象的内部情形\n\n```java\n// bad\nString url = host.getContext().getServlet().getName();\n```\n\n避免在DTO中塞入逻辑 保持简单setget即可\n\n## 错误处理\n\n- 使用异常而非返回码\n- 先写try-catch语句\n\ntry-catch定义了一个范围 使用TDD开发剩下的逻辑\n\n- 使用不可控异常\n\n可控异常违反了开闭原则 底层的修改会直接贯穿到高层\n\n- 构造异常时 提供足够的环境说明 以便快速排错\n- 根据调用者需要定义异常 也就说打包第三方 API\n\n```java\ntry {\n\n} catch(ThirdPartException e){\n  throw new BusinessException(e);\n}\n```\n\n- 使用特例模式来避免应付异常\n\n```java\n// bad\ntry {\n  getEmployee().run();\n} catch(NullPointerException e){\n  ...\n}\nvoid getEmployee(){\n  maybe return null;\n}\n// good\nvoid getEmployee(){\n  normal return new Employee();\n  sometimes return new EmptyEmployee();\n}\n```\n\n- 避免传递null\n\n## 边界\n\n整洁的边界应该避免我们的代码过多了解第三方代码中的信息\n\n### 第三方包\n\n封装第三方API来避免在系统中传递使用第三方接口\n\n学习性测试：通过编写测试来学习第三方API\n\n- 不仅可以学习API使用\n- 同时测试也是更新第三方包时的保障\n\n### 使用尚不存在的代码\n\n通过适配器适配尚未实现的接口 来进行已知与未知的隔离\n\n```java\n// 未知\ninterface ThirdPartInterface{...}\n\n// 未知与已知的交界处\ninterface ThirdPartAdapter extends ThirdPartInterface{...}\n```\n\n## 类\n\n组织：\n\n```java\npublic static int PORT = 8080;\nprivate static String MAGIC_NUMBER = 0XCAFE_BABE;\nprivate String instanceName;\nprotected String subName;\n\npublic void run(){...}\nprivate void innerRun(){...}\n```\n\n尽可能进行封装 除非玩不得以 否则不要暴露\n\n类应该短小：\n\n判断类短小的标准使用职责数来衡量 而非代码行数\n\n系统应该由许多短小的类而非少量巨大的类组成\n\n类应只由少量实体变量组成 这些变量如果同时被越多的函数操作 就代表这个类内聚性越高\n\n通过拆分函数以及函数相关的实体变量到其他类来将一个大类拆分为几个小类\n\n方便修改的组织：\n\n- 符合OCP\n- 使用接口隔离修改\n\n当采取诸如DIP等原则时 系统各个组件的耦合就已经非常低了 此时也方便测试\n\n## 系统\n\n### 分离系统的构造与使用\n\n使用main组件：\n\n![2020910143051](/assets/2020910143051.png)\n\n使用工厂控制对象的创建\n\n使用依赖注入容器来管理对象\n\n### 测试驱动系统架构\n\n代码层面与架构关注面分离开 避免侵入性代码\n\n没有必要先做大设计\n\n### 延迟决策\n\n### 使用DSL\n\n填平了领域与实现之间代码的壕沟\n\n## 迭进\n\n简单设计原则：\n\n- 运行所有测试 会促使类短小且单一 符合SRP 同时测试越多 代码之间耦合越低 符合DIP\n- 重构 测试消除了对修改代码的恐惧\n- 不可重复\n- 代码具有良好的表达力 使用好名称 标准命名法 良好的单元测试也能表达出某个类的作用\n- 尽可能减少类和方法 似乎违反SRP 但是这条规则与SRP达到一个平衡\n\n## 并发编程\n\n并发解耦了目的与时机\n\n一些问题：\n\n- 并发一般只有在IO密集型的程序或者有多个处理器上的机器才有效率提升\n- 并发系统的设计与单线程设计极不相同\n- 正确的并发是很复杂的\n\n### 防御原则\n\n谨记数据封装 限制数据作用域 严格限制多个线程访问的共享数据\n\n使用数据复本 有些情况下的并发可以只读 这个时候可以使用复制的方式避免共享\n\n线程应尽可能独立 不与其他线程共享数据\n\n### 执行模型\n\n大部分并发问题都是下列模型的变种：\n\n- 生产者-消费者 限定资源模型 有着固定数量的资源\n- 读者-写者 读写问题\n- 哲学家就餐问题 资源竞争问题\n\n### 建议\n\n不要在客户端调用一个对象的多个同步方法： 这可能造成多个线程下的数据不一致问题\n\n解决：\n\n- 客户端代码锁定\n\n```java\nsynchronized(lock){\n  obj.f1();\n  obj.f1();\n}\n```\n\n- 服务端锁定\n\n```java\n// AtomicInteger\npublic int incrementAndGet(){}\n```\n\n- 适配服务端 使用适配器模式\n\n保持同步区域微小\n\n尽早考虑关闭问题\n\n###　测试\n\n将偶然的失败看做线程问题\n\n先确保单线程代码可工作\n\n配置多线程代码在不同的配置环境下执行\n\n在代码里插入试错代码：sleep yeild\n\n- 手工\n- aop\n\n## 速查\n\n### 注释\n\n- 注释应只包含有关代码的技术信息　像修改时间　作者等没必要放入注释\n- 对于过时　不正确的注释　这些注释很快就会消失　少写\n- 少写废话注释　代码已经能表达的　没必要加注释\n- 注释需要花时间写到最好\n- 代码不要注释　直接删除\n\n### 环境\n\n系统构建与运行单元测试应只需一个指令\n\n### 函数\n\n- 参数越少越好\n- 输出参数违反直觉　避免使用\n- 标识参数应该被消灭\n- 丢弃永不调用的方法\n\n### 一般性问题\n\n- 理想的源文件只包含一种编程语言\n- 函数或者类的实现应该是其他程序员所期待的\n- 对于测试需要追索每种边界条件\n- 忽视安全警告相当危险\n- 重复\n  - 最明显的是重复代码\n  - 较隐蔽的是相同的条件判断 if switch链条\n  - 最隐蔽的是算法相似　但代码不同\n- 建立合适的抽象层级\n  - 抽象类来容纳较高层的概念　实现类容纳较低层\n- 通常来说　父类对之类一无所知\n- 隐藏数据　通过隐藏来达到限制信息　从而控制耦合度\n- 删除不执行的死代码\n- 垂直分隔\n  - 本地变量应该定义在其首次使用的上面　私有函数应该定义在其首次使用的下面\n- 概念前后不一致\n- 毫无关系的东西不该耦合\n- 类的方法应该只对它自己的变量及函数感兴趣　少去依赖外部类的变量函数\n- 代码要充分展现作者意图\n- 对于需要考虑动态行为的静态方法　可能有问题\n- 使用临时变量存储计算过程　提供可读性\n- 函数名称应表达其行为\n- 要理解自己编写的算法\n- 模块的依赖应该是物理依赖\n- 使用多态取代if switch\n- 遵循团队代码规范\n- 用命名常量代替魔数\n- 避免代码含糊不清\n- 良好的结构优于良好的命名\n- 对条件表达式进行命名\n- 一个函数只做一件事\n- 暴露函数调用的前后顺序\n- 封装边界条件\n- 函数应该只有一种抽象层级\n- 配置数据放在高层\n- 避免传递浏览　也就是最小知道原则\n\n### Java\n\n- 使用导入通配符避免过长的导入列表\n- 不要通过继承的方式使用常量\n\n### 名称\n\n- 使用描述性的名称\n- 名称应与抽象层级相符\n- 使用标准命名法\n- 名称无歧义\n- 为较大的范围选用较长的名称\n- 避免编码　前缀后缀\n- 名称要说明副作用\n\n### 测试\n\n- 使用覆盖率测试覆盖大部分测试\n- 注意边界条件\n- 缺陷可能扎堆发生\n- 测试要快\n","metadata":"","hasMoreCommit":false,"totalCommits":9,"commitList":[{"date":"2022-01-11T16:25:03+08:00","author":"cjiping","message":"📦整理 单元测试","hash":"2504e9513b311030215e418550cbaafca6e71186"},{"date":"2021-08-18T17:43:55+08:00","author":"cjiping","message":"📦整理 代码质量","hash":"72ef903971f583db2157da6eecbd0dee910787c9"},{"date":"2020-09-26T10:40:14+08:00","author":"MY","message":"✏更新 单元测试","hash":"5b5ed1c2f45f1749768f6c6ab280aa5591860cb0"},{"date":"2020-09-11T15:49:07+08:00","author":"0xcaffebabe","message":"✏更新 整洁代码","hash":"a70bb695ae1142ba3f3921de1f6b925b370b5a7c"},{"date":"2020-09-11T10:05:58+08:00","author":"0xcaffebabe","message":"✏更新 整洁代码","hash":"915983bcedf1d6c042187a04111c8601d23b7691"},{"date":"2020-09-10T14:49:35+08:00","author":"MY","message":"✏更新 整洁代码","hash":"1532410479881b2acb0974aa5c3db2c8508bf335"},{"date":"2020-09-09T16:15:04+08:00","author":"MY","message":"✏更新 整洁代码","hash":"f1100f571530abc62329d1535c730a23f5adf4e7"},{"date":"2020-09-09T14:37:35+08:00","author":"MY","message":"✏更新 整洁代码 增加 代码示例","hash":"ad683124ba59a8fe05420a41cf79ef52d74eaf13"},{"date":"2020-09-08T13:38:38+08:00","author":"MY","message":"✏更新 整洁代码","hash":"afbdfa42d10bec212d0382a2107aa170b1efe855"}],"createTime":"2020-09-08T13:38:38+08:00"}