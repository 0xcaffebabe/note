{"name":"单元测试","id":"软件工程-软件设计-代码质量-软件测试-单元测试","content":"# 单元测试\n\n脏测试等同于甚至坏于没测试\n\n测试必须随着生产代码演进而修改\n\n单元测试使代码可扩展 可维护 可复用\n\n## 测试类型\n\n- 边界值测试 边界是最容易出错的地方\n- 正确的输入 并得到预期的结果\n- 错误的输入 得到预期的错误结果\n\n## 重要性\n\n- 保障质量\n- 进行风险控制\n- 限定最小爆炸范围\n- 增加重构自信\n\n## 原则\n\n### AIR\n\n- automation 自动化\n- independent 独立性\n- repeatable 可重复\n\n### FIRST\n\n- fast 测试运行要足够快\n- independent 测试之间要相互独立\n- repeatable 测试可在任何环境中重复通过\n- self-validating 通过一个布尔值表示测试是否通过（自动化）\n- timely 测试要及时编写 指的是TDD 测试在生产代码之前编写\n\n## 粒度与范围\n\n- 方法级别的粒度\n- 针对测试区分case场景\n- case职责要单一\n- 核心功能覆盖 非核心随缘\n\n## 单元测试与集成测试\n\n集成测试运行通常更慢，很难编写，很难做到自动化，需要配置，通常一次测试的东西过多，并且集成测试会使用真实的依赖，而单元测试则把被测试的单元和其依赖隔离，以保证单元测试的高度稳定，还可以轻易控制和模拟被测试单元的行为方面\n\n## 方法\n\n![传统方法](/assets/202002201211.jfif)\n\n![TDD测试驱动开发](/assets/202002201212.jfif)\n\nTDD看起来挺美好，但在现阶段国内的唯快不破商业环境下，代码迭代频繁，使用起来还是有难度的\n\n## 单元测试的复杂性\n\n1. 输入参数的复杂性：输入参数不是简单的函数输入参数，本质上讲，任何能够影响代码执行路径的参数，都是被测函数的输入参数\n2. 预期输出的复杂性：主要表现在预期输出应该包括被测函数执行完成后所改写的所有数据\n3. 关联依赖：需要采用桩代码来模拟不可用的代码，并通过打桩补齐未定义部分\n\n## 单元测试代码规范\n\n### 整洁的测试代码\n\n- 可读性\n\n构造-操作-检验\n\n通过不断重构测试就会慢慢得到一个文档的测试API 随着重构代码也会更有表现力\n\n```java\nassertUserExistsInDatabase(\"cxk\"); // 一个测试API\n```\n\n对于测试环境 CPU内存等资源没有那么紧张 所以测试也并非一定要追求效率\n\n每个测试应拥有尽可能少的断言 个人认为 可以对断言进行抽象 如上述的测试API\n\n同时 测试应只测试一个概念 将多件事混杂在一起只会导致概念的混乱\n\n```java\n@Test\nvoid testUserService(){...} // bad 过于混杂\n@Test\nvoid testUserInsertFailed(){...} // better\n```\n\n命名：不要将太多描述放到测试函数命名中，应该放到函数的注释中\n\n### 断言数量最小化\n\n### 不要迷信过高覆盖率\n\n### 单元测试的结构\n\n- **准备阶段（Given）** 主要负责创建测试数据、构造mock 方法的返回值，准备环节的编码是单元测试最复杂的部分。需要注意的是 Mockito 库中以 when 开头的函数其实是在准备阶段\n- **执行阶段（When）** 一般只是调用测试的函数，此部分代码通常较短\n- **验证阶段（Then）** 通常验证测试函数的执行的结果、 准备阶段 mock 函数的调用次数等是否符合预期\n\n### 可测的代码\n\n#### 不可测的原因\n\n1. 依赖了外部接口组件\n2. 外部接口组件没有返回期望的返回数据\n3. 执行外部接口组件会产生副作用\n\n#### 可测改造\n\n对于外部接口组件，使用依赖注入或者通过外部传参的方式来使用，这样利于在测试时进行接缝\n\n1. 对象接缝：通过继承 DOC 来改变默认行为\n2. 接口接缝：将 DOC 提取为接口，并用其他实现类来改变默认行为\n3. 新生：对于老代码，使用一个新添加的方法来完成新需求，使得新代码可测\n4. 包装：老代码不动，新代码通过包装调用老代码并添加额外职责的方式完成需求\n\n## 单元测试覆盖率\n\n### 粗粒度覆盖\n\n- 方法覆盖与类覆盖\n\n### 细粒度覆盖\n\n#### 行覆盖\n\n执行的语句总数 / 全部语句总数\n\n#### 分支覆盖\n\n- 确保判定条件的真假都会被执行\n\n```c\nif (condition) {...} // condition 为真为假的时候都要测试\n```\n\n#### 条件判定覆盖\n\n- 让判定条件中的语句真假都会被执行\n\n```c\nif (condition1 && condition2) {...} // condtion1 和 condtion2 为真为假的组合 也就是要4种组合\n```\n\n#### 条件组合覆盖\n\n- 所有参数的可能取值\n\n#### 路径覆盖\n\n- 测试所有可能的路径\n\n### 覆盖率工具\n\n- jacoco 通过ASM修改字节码实现\n\n## 构造数据\n\n- 手动\n- 半自动\n  - 依赖开发工具插件或者外部数据源\n- 自动\n  - java-faker 和 easy-random\n\n### java-faker\n\n能生成具体有意义的字符串\n\n### easy-random\n\neasy-random 可以轻松构造复杂对象，支持定义对象中集合长度，字符串长度范围，生成集合等\n\n## 对哪些代码写单测\n\n- 数据访问层\n\n一般要设置自动回滚。除此之外，还可以整合H2等内存数据库来对数据访问层代码进行测试\n\n- 服务层\n\n一般要依赖 mock 工具，将服务的所有依赖都 mock 掉\n\n- 工具类\n\n因为工具类一般在服务内共用，如果有 BUG，影响面很大，很容易造成线上问题或故障。一般需要构造正常和边界值两种类型的用例，对工具类进行全面的测试，才可放心使用\n","metadata":"","hasMoreCommit":false,"totalCommits":5,"commitList":[{"date":"2023-01-17T17:58:45+08:00","author":"cjiping","message":"✏️测试","hash":"df30734725ab56af03671093b20d5c519abc3054"},{"date":"2022-06-20T14:44:47+08:00","author":"cjiping","message":"✏️更新 单元测试","hash":"1718927f3311d11f1d3c02f1ecbe51053d9deb2e"},{"date":"2022-02-07T23:21:12+08:00","author":"MY","message":"✏️更新 测试相关","hash":"a4c55ec4f2b1f33b0ef46f36951ec0ca67a71f76"},{"date":"2022-01-11T20:57:46+08:00","author":"MY","message":"✏️更新 单元测试","hash":"f0fc8fed9506e7dc4a944590769ad68a52b161f2"},{"date":"2022-01-11T16:25:03+08:00","author":"cjiping","message":"📦整理 单元测试","hash":"2504e9513b311030215e418550cbaafca6e71186"}],"createTime":"2022-01-11T16:25:03+08:00"}