{"name":"软件设计","id":"软件工程-软件设计-软件设计","content":"# 软件设计：从复杂性到稳定性\n\n> 软件设计的本质，是在变化的世界中建立可理解、可演化的秩序。\n> 它连接需求与解决方案，用模型对抗混乱，用结构控制复杂性。\n\n---\n\n## 一、设计的本质与目标\n\n软件设计的核心工作，就是**构建模型**，用模型连接“问题空间（需求）”与“解空间（实现）”，\n并通过**规范**去约束实现，以在变化中保持系统的可控与稳定。\n\n* **战术编程**：赶紧实现功能，能跑就行。\n* **战略编程**：预先构建结构，控制复杂性。\n\n**软件设计就是战略编程的体现**——它不只是写代码，而是构建“可长期生存的系统”。\n\n设计原则是指导设计的经验总结，设计模式是问题导向的一系列方案或者设计思路，编码规范是实现可读性的约束手段。通过设计原则的指导，使用设计模式，经过编码规范约束并配合重构，保证代码的可读性、扩展性、可复用性，最终实现高内聚、低耦合的模块或系统\n\n---\n\n## 二、复杂性：设计要对抗的敌人\n\n> 复杂性不是敌人本身，而是失控的结构。\n> 设计的意义，在于让复杂性有序地分布。\n\n### 1. 复杂性的表现\n\n* **变更放大**：看似简单的修改，却需要动很多地方。\n* **认知负荷**：开发者要理解多少知识才能改动一行代码。\n* **未知的未知**：不知道改哪里能实现目标。\n\n### 2. 复杂性的根源\n\n* **依赖过多**：难以管理的依赖关系。\n* **语义模糊**：实体意义不明，职责混乱。\n\n### 3. 降低复杂性的思路\n\n在模块开发中要么**对外暴露简单接口**（方便用户），要么**保持简单实现**（方便维护）。\n抽象、分层、模块化、解耦、关注点分离，都是降低复杂性的手段。\n\n---\n\n## 三、关注点分离与信息隐藏\n\n> 一切优秀的软件设计，都是在不断回答两个问题：\n> “这部分应该知道什么？”、“这部分不该知道什么？”\n\n### 1. 关注点分离（Separation of Concerns）\n\n通过分解问题，让每个模块只关心自己的责任。\n这是一切设计原则的起点，可通过以下方式实现：\n\n* 模块化与封装\n* 单一职责\n* 分层架构\n* 清晰边界定义\n\n### 2. 信息隐藏（Information Hiding）\n\n每个模块应封装部分知识与决策，让这些细节只存在于内部实现中，而不出现在外部接口。\n这样模块间依赖的是**抽象**，而非**细节**，从而减少耦合、增强稳定性。\n\n### 3. 接口与抽象\n\n抽象是一种隔离机制。越抽象的接口代表模块越“深”，能隐藏更多复杂性。\n通过抽象与接口分离，可以让模块变得“可替换、可演化、可理解”。\n\n---\n\n## 四、设计原则：代码层的秩序\n\n> 设计原则是从无序到有序的经验总结，是控制局部复杂性的策略。\n\n### 1. SOLID 原则 —— 稳定代码结构的五根支柱\n\n| 原则           | 含义           | 核心思想    |\n| ------------ | ------------ | ------- |\n| **SRP 单一职责** | 每个模块只对一个行为负责 | 控制变更范围  |\n| **OCP 开闭原则** | 对扩展开放，对修改关闭  | 以抽象隔离变化 |\n| **LSP 里氏替换** | 子类可替代父类      | 保持行为一致性 |\n| **ISP 接口隔离** | 不依赖无关接口      | 控制依赖扩散  |\n| **DIP 依赖反转** | 依赖抽象而非实现     | 控制依赖方向  |\n\n> 这五个原则共同形成一个目标：**以抽象对抗变化，以接口维持秩序。**\n\n#### SRP:单一职责原则\n\n>任何一个软件模块都应只对某一类行为负责，修改一个类的原因应该只有一个\n\n主要讨论的是函数与类的关系，当这个类需要做过多事情的时候，也就是出现了很多不相关的函数时，就需要分解这个类\n\n#### OCP:开闭原则\n\n>设计良好的软件应该容易扩展，而禁止修改\n\n- 将旧代码的修改量降低至最小，限制变化的范围\n\n该原则要求在添加新功能时不需要修改代码。但是这条原则真的很容易做到吗？在繁杂的业务代码中，大部分情况下，业务发生变更，业务代码必须要进行修改。这就要求我们编写的代码可以适应未来的情况，可根据需求软编码的方式来变更业务逻辑。\n\n> 依赖方向的控制: 通过接口来反转组件之间的依赖关系，使得高阶组件不会因低阶组件被修改而受到影响\n\n信息隐藏：通过中间层使高层组件不过度依赖低层组件的内部细节\n\n#### LSP:里氏替换原则\n\n> 一个软件实体如果使用的是一个基类的话，那么它一定也可以使用其子类，而且它根本不能察觉出基类对象和子类对象的区别\n\n```java\nanimal.run();\n// ↓\ncat.run();\n```\n\n如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度\n\n- 是一个指导接口与其实现方式的设计原则\n\n#### ISP:接口隔离原则\n\n>对模块来说，跟它无关的接口一旦发生变更，应该不能影响到该模块，不应该强迫客户依赖于它们不用的方法\n\n使用多个专门的接口比使用单一的总接口要好\n\n- 软件设计如果依赖了它并不需要的东西，会带来麻烦\n\n#### DIP:依赖反转原则\n\n>高层模块不应该依赖于低层模块，二者都应该依赖于抽象\n>抽象不应该依赖于细节，细节应该依赖于抽象。\n\n当然某些情况下抽象必须依赖于细节，比如Object中对String的依赖\n\n想要设计一个灵活的系统，则就应多引用抽象类型，而非具体实现。这么做的原因是接口相比实现更为稳定\n\n主要关注的是系统中那些经常变动的\n\n---\n\n### 2. 平衡性原则 —— 从理性到节制\n\n* **DRY（不要重复）**：重复是复杂性的温床。\n* **YAGNI（你不会需要它）**：不要为未来的假设增加当下的负担。\n* **Rule of Three（三次原则）**：在重复中发现抽象，在抽象中追求节制。\n* **KISS（保持简单）**：设计的美感来自于“直觉一致、易于理解”。\n* **POLA（最小惊奇原则）**：让系统行为符合常识，减少认知摩擦。\n\n这些原则塑造了微观层面的“理性结构”，是代码世界的行为准则。\n\n---\n\n## 五、模块与层次：结构化复杂性的方式\n\n### 1. 模块的深度与接口\n\n模块的深度取决于其隐藏的知识量。\n深模块暴露简单接口，浅模块暴露细节。\n一个系统的深度结构，就是它抽象能力的体现。\n\n### 2. 分层架构与接口传递\n\n层与层之间的交互应最小化。\n“直通方法”虽然浅，但可以保持边界清晰。\n当参数传递变复杂时，可通过上下文对象降低复杂度。\n\n### 3. 分开与合并的取舍\n\n设计要回答的问题不是“拆还是合”，而是“哪里是知识的边界”。\n合并可减少重复，分离可隔离变化。\n关键在于**信息共享、接口简化与依赖控制**之间的平衡。\n\n---\n\n## 六、组件设计：系统层的秩序\n\n> 当软件规模扩大到无法在一个脑中完全装下时，设计的重心从函数与类上升为**组件与依赖图**。\n\n### 1. 组件的定义\n\n组件是**可独立部署与演化的最小单元**。\n它既是技术边界，也是组织边界。\n良好的组件化是系统可维护、可扩展的前提。\n\n---\n\n### 2. 组件聚合原则（Cohesion）\n\n| 原则                | 含义               |\n| ----------------- | ---------------- |\n| **REP：复用/发布等同原则** | 复用与发布的最小单元应一致    |\n| **CCP：共同闭包原则**    | 同时变更的模块应在同一组件中   |\n| **CRP：共同复用原则**    | 经常一起被复用的类应在同一组件中 |\n\n> 组件内高内聚，组件间低耦合。\n> 这些原则是 SRP 与 ISP 的组件级体现。\n\n#### REP:复用/发布等同原则\n\n组件中的模块和类之间应该有一个共同的主题或者大方向\n\n#### CCP:共同闭包原则\n\n应将那些会为了一个目的而同时修改的模块与类放到一个组件中\n\nCCP 是 SRP 的组件版\n\n#### CRP:共同复用原则\n\n将经常共同复用的模块与类放在同一组件中\n\n- 不依赖不需要用到的东西\n\nCRP 是 ISP 的组件版\n\n---\n\n### 3. 组件耦合原则（Coupling）\n\n| 原则             | 含义            |\n| -------------- | ------------- |\n| **ADP：无依赖环原则** | 组件依赖结构必须无环    |\n| **SDP：稳定依赖原则** | 只依赖比自己更稳定的组件  |\n| **SAP：稳定抽象原则** | 稳定性与抽象程度应保持一致 |\n\n> 组件设计的本质，是让稳定性与抽象性协同演化。\n> 系统的依赖图，是其稳定结构的投影。\n\n#### ADP:无依赖环原则\n\n组件不应该出现循环依赖\n\n每周构建：所有人在同一个代码库中开发所有模块的代码，将一周的前几天用来开发新代码，最后一天进行模块依赖冲突的解决\n\n为了避免循环依赖，可以通过划分独立组件进行独立开发及发布，在物理上强制隔离掉\n\n为了消除循环依赖，有两种方法：\n\n1. 依赖反转改变组件的依赖方向\n2. 将相互依赖的模块提取到一个新模块\n\n_抖动_：随着项目的开发，组件结构会不断扩张变化\n\n#### 自上而下的设计\n\n组件结构图更像是构建性与维护性方面的地图，组件结构图一个重要的目标是如何隔离频繁的组件变更\n\n组件的依赖关系是随着项目的逻辑设计而演进的，无法一开始就设计出完美的组件结构图\n\n组件的依赖关系会随着架构的演进在不断变化\n\n#### SDP:稳定依赖原则\n\n一个组件只能依赖于比他更稳定的组件\n\n##### 稳定性\n\n与依赖于该模块的模块数量成正比\n\n- 越上层的组件越不稳定\n\n不稳定性 = 依赖的组件数 / (依赖的组件数 + 依赖其的组件数)\n\n##### 抽象组件\n\n- 比如只存放接口的包\n\n抽象组件通常非常稳定\n\n#### SAP:稳定抽象原则\n\n一个组件的抽象化程度应与其稳定性程度保持一致\n\n##### 抽象化衡量程度\n\n抽象程度 = 抽象类和接口的数量 / 组件中类的数量\n\n- 痛苦区：非常稳定且非常具体\n  - 如数据库表结构与工具类\n- 无用区：无限抽象，无人使用\n\n---\n\n### 4. 组件的演化与稳定性\n\n优秀的架构并非一次性设计出来，而是在不断反馈与重构中演化的。\n架构师的目标不是“消除变化”，而是“使变化有序地发生”。\n\n* 自上而下：通过边界定义控制变化。\n* 自下而上：通过抽象提炼吸收变化。\n* 持续重构：在变化中维护秩序。\n\n---\n\n## 七、设计的兼容性与演化性\n\n> 稳定性不是不变，而是**在变中保持秩序**。\n\n### 1. 协议兼容\n\n通过版本号、编号预留等方式实现前后兼容。\n\n### 2. API 兼容\n\n保留旧接口，对外不变，内部重定向到新实现。\n\n### 3. 数据兼容\n\n旧数据的转换与兜底展示，使业务升级平滑过渡。\n\n---\n\n## 八、设计的未来：从模式到模型\n\n### 1. 框架与 DSL\n\n通过领域特定语言（DSL）描述意图，以“约定优于配置”的方式降低复杂性。\n\n### 2. 测试与重构\n\n单元测试是重构的基石；\n但“可测性”并不等于“设计良好”，二者需平衡。\n\n### 3. 多次设计\n\n比较不同方案，从多个视角评估耦合、抽象与稳定性。\n\n---\n\n## 九、结语：设计的哲学\n\n> 软件设计的终极目标不是完美结构，而是**可演化的秩序**。\n\n它既是对抗复杂性的工程技巧，\n也是在混乱世界中寻求秩序的思想实践。\n\n**好的设计：**\n\n* 让变化有边界；\n* 让复杂性被封装；\n* 让系统能够在时间维度上持续演化。\n\n> 设计不是画图，而是做选择。\n> 真正的设计师，不追求完美，而追求**在不完美中保持稳定**。\n\n## 关联内容（自动生成）\n\n- [/软件工程/理论/结构化设计方法.md](/软件工程/理论/结构化设计方法.md) 结构化设计方法与软件设计在模块化、信息隐藏和关注点分离方面有密切联系\n- [/软件工程/软件设计/代码质量/代码质量.md](/软件工程/软件设计/代码质量/代码质量.md) 代码质量是软件设计的重要目标，两者共同关注高内聚、低耦合的模块设计\n- [/软件工程/软件设计/代码质量/整洁代码.md](/软件工程/软件设计/代码质量/整洁代码.md) 整洁代码体现了软件设计原则的具体实践，特别是SOLID原则的落地\n- [/软件工程/软件设计/代码质量/代码重构.md](/软件工程/软件设计/代码质量/代码重构.md) 代码重构是软件设计原则在代码层面的落地实践，有助于实现高内聚低耦合的模块设计\n- [/软件工程/架构/系统设计/架构设计.md](/软件工程/架构/系统设计/架构设计.md) 架构设计是软件设计在更高层次上的体现，关注系统整体结构和组件间关系\n- [/软件工程/设计模式/设计模式.md](/软件工程/设计模式/设计模式.md) 设计模式是软件设计原则的具体实现方式，提供了常见问题的解决方案\n- [/软件工程/理论/软件需求.md](/软件工程/理论/软件需求.md) 软件设计承接需求分析的结果，将需求转化为具体的系统设计方案\n- [/软件工程/领域驱动设计.md](/软件工程/领域驱动设计.md) 领域驱动设计提供了复杂业务系统的设计方法，与软件设计中的模块化和边界定义密切相关\n- [/软件工程/微服务/微服务.md](/软件工程/微服务/微服务.md) 微服务架构体现了软件设计中模块化和低耦合高内聚的思想\n- [/编程语言/编程范式/面向对象.md](/编程语言/编程范式/面向对象.md) 面向对象编程范式是软件设计的重要基础，其原则如SOLID与软件设计紧密相关\n","metadata":"tags: ['软件工程', '架构设计', '编程语言']","hasMoreCommit":true,"totalCommits":15,"commitList":[{"date":"2026-02-12T14:07:03+08:00","author":"MY","message":"doc: 整理标签","hash":"290b3e8ad18f48832ac282290238d020fc030a88"},{"date":"2026-01-20T14:39:32+08:00","author":"MY","message":"docs(software-design): 更新软件设计文档的标签和关联内容","hash":"40348a452e9fb3b50c2100e30724ef4be3338650"},{"date":"2025-11-16T21:30:56+08:00","author":"MY","message":"docs: 统一并精简文档标签","hash":"21362e9d7aeb62e05364cd5e7f3a3c24d7e293c7"},{"date":"2025-10-14T15:40:50+08:00","author":"MY","message":"docs(软件工程): 重构软件设计文档结构与内容","hash":"abf1e2fd59654108b515d7ac05c83feebbc3cc15"},{"date":"2023-12-12T18:57:09+08:00","author":"MY","message":"✏软件设计","hash":"6452cdda251711e1af4b30b6f7b5ef767be3d0c5"},{"date":"2023-12-11T18:53:44+08:00","author":"MY","message":"✏软件设计","hash":"4521371f3a4b75ba0af15b2898d758d44327ad12"},{"date":"2023-12-07T18:56:11+08:00","author":"MY","message":"✏软件设计","hash":"fb354540af8f6e9e604c15b2c563e59bb665d717"},{"date":"2022-04-07T14:56:27+08:00","author":"MY","message":"✏️更新 软件设计","hash":"476b860261ce4150066e26527687b1772ed652dc"},{"date":"2022-02-17T17:38:58+08:00","author":"cjiping","message":"✏️更新 软件设计","hash":"4acad7c8c4351a0c36836d9a2d56b71211a35765"},{"date":"2022-02-16T17:42:22+08:00","author":"cjiping","message":"✏️更新 leetcode","hash":"f9ee3354f1b59833c749732a8071fa88e8b6196f"}],"createTime":"2021-08-03T19:01:36+08:00"}